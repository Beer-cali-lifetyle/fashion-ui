! function(n, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : n.anime = e()
}(this, function() {
  "use strict";
  var i = {
          update: null,
          begin: null,
          loopBegin: null,
          changeBegin: null,
          change: null,
          changeComplete: null,
          loopComplete: null,
          complete: null,
          loop: 1,
          direction: "normal",
          autoplay: !0,
          timelineOffset: 0
      },
      M = {
          duration: 1e3,
          delay: 0,
          endDelay: 0,
          easing: "easeOutElastic(1, .5)",
          round: 0
      },
      j = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"],
      l = {
          CSS: {},
          springs: {}
      };

  function C(n, e, t) {
      return Math.min(Math.max(n, e), t)
  }

  function u(n, e) {
      return -1 < n.indexOf(e)
  }

  function o(n, e) {
      return n.apply(null, e)
  }
  var w = {
      arr: function(n) {
          return Array.isArray(n)
      },
      obj: function(n) {
          return u(Object.prototype.toString.call(n), "Object")
      },
      pth: function(n) {
          return w.obj(n) && n.hasOwnProperty("totalLength")
      },
      svg: function(n) {
          return n instanceof SVGElement
      },
      inp: function(n) {
          return n instanceof HTMLInputElement
      },
      dom: function(n) {
          return n.nodeType || w.svg(n)
      },
      str: function(n) {
          return "string" == typeof n
      },
      fnc: function(n) {
          return "function" == typeof n
      },
      und: function(n) {
          return void 0 === n
      },
      nil: function(n) {
          return w.und(n) || null === n
      },
      hex: function(n) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(n)
      },
      rgb: function(n) {
          return /^rgb/.test(n)
      },
      hsl: function(n) {
          return /^hsl/.test(n)
      },
      col: function(n) {
          return w.hex(n) || w.rgb(n) || w.hsl(n)
      },
      key: function(n) {
          return !i.hasOwnProperty(n) && !M.hasOwnProperty(n) && "targets" !== n && "keyframes" !== n
      }
  };

  function d(n) {
      n = /\(([^)]+)\)/.exec(n);
      return n ? n[1].split(",").map(function(n) {
          return parseFloat(n)
      }) : []
  }

  function c(r, t) {
      var n = d(r),
          e = C(w.und(n[0]) ? 1 : n[0], .1, 100),
          a = C(w.und(n[1]) ? 100 : n[1], .1, 100),
          o = C(w.und(n[2]) ? 10 : n[2], .1, 100),
          n = C(w.und(n[3]) ? 0 : n[3], .1, 100),
          u = Math.sqrt(a / e),
          i = o / (2 * Math.sqrt(a * e)),
          c = i < 1 ? u * Math.sqrt(1 - i * i) : 0,
          s = i < 1 ? (i * u - n) / c : -n + u;

      function f(n) {
          var e = t ? t * n / 1e3 : n,
              e = i < 1 ? Math.exp(-e * i * u) * (+Math.cos(c * e) + s * Math.sin(c * e)) : (1 + s * e) * Math.exp(-e * u);
          return 0 === n || 1 === n ? n : 1 - e
      }
      return t ? f : function() {
          var n = l.springs[r];
          if (n) return n;
          for (var e = 0, t = 0;;)
              if (1 === f(e += 1 / 6)) {
                  if (16 <= ++t) break
              } else t = 0;
          return n = e * (1 / 6) * 1e3, l.springs[r] = n
      }
  }

  function q(e) {
      return void 0 === e && (e = 10),
          function(n) {
              return Math.ceil(C(n, 1e-6, 1) * e) * (1 / e)
          }
  }
  var H = function(b, e, M, t) {
      if (0 <= b && b <= 1 && 0 <= M && M <= 1) {
          var x = new Float32Array(11);
          if (b !== e || M !== t)
              for (var n = 0; n < 11; ++n) x[n] = k(.1 * n, b, M);
          return function(n) {
              return b === e && M === t || 0 === n || 1 === n ? n : k(r(n), e, t)
          }
      }

      function r(n) {
          for (var e = 0, t = 1; 10 !== t && x[t] <= n; ++t) e += .1;
          var r = e + .1 * ((n - x[--t]) / (x[t + 1] - x[t])),
              a = O(r, b, M);
          if (.001 <= a) {
              for (var o = n, u = r, i = b, c = M, s = 0; s < 4; ++s) {
                  var f = O(u, i, c);
                  if (0 === f) return u;
                  u -= (k(u, i, c) - o) / f
              }
              return u
          }
          if (0 === a) return r;
          for (var l, d, p = n, h = e, g = e + .1, m = b, v = M, y = 0; 0 < (l = k(d = h + (g - h) / 2, m, v) - p) ? g = d : h = d, 1e-7 < Math.abs(l) && ++y < 10;);
          return d
      }
  };

  function r(n, e) {
      return 1 - 3 * e + 3 * n
  }

  function k(n, e, t) {
      return ((r(e, t) * n + (3 * t - 6 * e)) * n + 3 * e) * n
  }

  function O(n, e, t) {
      return 3 * r(e, t) * n * n + 2 * (3 * t - 6 * e) * n + 3 * e
  }
  e = {
      linear: function() {
          return function(n) {
              return n
          }
      }
  }, t = {
      Sine: function() {
          return function(n) {
              return 1 - Math.cos(n * Math.PI / 2)
          }
      },
      Expo: function() {
          return function(n) {
              return n ? Math.pow(2, 10 * n - 10) : 0
          }
      },
      Circ: function() {
          return function(n) {
              return 1 - Math.sqrt(1 - n * n)
          }
      },
      Back: function() {
          return function(n) {
              return n * n * (3 * n - 2)
          }
      },
      Bounce: function() {
          return function(n) {
              for (var e, t = 4; n < ((e = Math.pow(2, --t)) - 1) / 11;);
              return 1 / Math.pow(4, 3 - t) - 7.5625 * Math.pow((3 * e - 2) / 22 - n, 2)
          }
      },
      Elastic: function(n, e) {
          void 0 === e && (e = .5);
          var t = C(n = void 0 === n ? 1 : n, 1, 10),
              r = C(e, .1, 2);
          return function(n) {
              return 0 === n || 1 === n ? n : -t * Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1 - r / (2 * Math.PI) * Math.asin(1 / t)) * (2 * Math.PI) / r)
          }
      }
  }, ["Quad", "Cubic", "Quart", "Quint"].forEach(function(n, e) {
      t[n] = function() {
          return function(n) {
              return Math.pow(n, e + 2)
          }
      }
  }), Object.keys(t).forEach(function(n) {
      var r = t[n];
      e["easeIn" + n] = r, e["easeOut" + n] = function(e, t) {
          return function(n) {
              return 1 - r(e, t)(1 - n)
          }
      }, e["easeInOut" + n] = function(e, t) {
          return function(n) {
              return n < .5 ? r(e, t)(2 * n) / 2 : 1 - r(e, t)(-2 * n + 2) / 2
          }
      }, e["easeOutIn" + n] = function(e, t) {
          return function(n) {
              return n < .5 ? (1 - r(e, t)(1 - 2 * n)) / 2 : (r(e, t)(2 * n - 1) + 1) / 2
          }
      }
  });
  var e, t, s = e;

  function P(n, e) {
      if (w.fnc(n)) return n;
      var t = n.split("(")[0],
          r = s[t],
          a = d(n);
      switch (t) {
          case "spring":
              return c(n, e);
          case "cubicBezier":
              return o(H, a);
          case "steps":
              return o(q, a);
          default:
              return o(r, a)
      }
  }

  function a(n) {
      try {
          return document.querySelectorAll(n)
      } catch (n) {}
  }

  function I(n, e) {
      for (var t, r = n.length, a = 2 <= arguments.length ? e : void 0, o = [], u = 0; u < r; u++) u in n && (t = n[u], e.call(a, t, u, n)) && o.push(t);
      return o
  }

  function f(n) {
      return n.reduce(function(n, e) {
          return n.concat(w.arr(e) ? f(e) : e)
      }, [])
  }

  function p(n) {
      return w.arr(n) ? n : (n = w.str(n) ? a(n) || n : n) instanceof NodeList || n instanceof HTMLCollection ? [].slice.call(n) : [n]
  }

  function h(n, e) {
      return n.some(function(n) {
          return n === e
      })
  }

  function g(n) {
      var e, t = {};
      for (e in n) t[e] = n[e];
      return t
  }

  function x(n, e) {
      var t, r = g(n);
      for (t in n) r[t] = (e.hasOwnProperty(t) ? e : n)[t];
      return r
  }

  function D(n, e) {
      var t, r = g(n);
      for (t in e) r[t] = (w.und(n[t]) ? e : n)[t];
      return r
  }

  function V(n) {
      var e, t, r, a, o, u, i;
      return w.rgb(n) ? (e = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(t = n)) ? "rgba(" + e[1] + ",1)" : t : w.hex(n) ? (e = (e = n).replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(n, e, t, r) {
          return e + e + t + t + r + r
      }), e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e), "rgba(" + parseInt(e[1], 16) + "," + parseInt(e[2], 16) + "," + parseInt(e[3], 16) + ",1)") : w.hsl(n) ? (t = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t = n) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(t), n = parseInt(t[1], 10) / 360, u = parseInt(t[2], 10) / 100, i = parseInt(t[3], 10) / 100, t = t[4] || 1, 0 == u ? r = a = o = i : (r = c(u = 2 * i - (i = i < .5 ? i * (1 + u) : i + u - i * u), i, n + 1 / 3), a = c(u, i, n), o = c(u, i, n - 1 / 3)), "rgba(" + 255 * r + "," + 255 * a + "," + 255 * o + "," + t + ")") : void 0;

      function c(n, e, t) {
          return t < 0 && (t += 1), 1 < t && --t, t < 1 / 6 ? n + 6 * (e - n) * t : t < .5 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
      }
  }

  function B(n) {
      n = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(n);
      if (n) return n[1]
  }

  function m(n, e) {
      return w.fnc(n) ? n(e.target, e.id, e.total) : n
  }

  function v(n, e) {
      return n.getAttribute(e)
  }

  function y(n, e, t) {
      var r, a, o;
      return h([t, "deg", "rad", "turn"], B(e)) ? e : (r = l.CSS[e + t], w.und(r) ? (a = document.createElement(n.tagName), (n = n.parentNode && n.parentNode !== document ? n.parentNode : document.body).appendChild(a), a.style.position = "absolute", a.style.width = 100 + t, o = 100 / a.offsetWidth, n.removeChild(a), n = o * parseFloat(e), l.CSS[e + t] = n) : r)
  }

  function $(n, e, t) {
      var r;
      if (e in n.style) return r = e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), e = n.style[e] || getComputedStyle(n).getPropertyValue(r) || "0", t ? y(n, e, t) : e
  }

  function b(n, e) {
      return w.dom(n) && !w.inp(n) && (!w.nil(v(n, e)) || w.svg(n) && n[e]) ? "attribute" : w.dom(n) && h(j, e) ? "transform" : w.dom(n) && "transform" !== e && $(n, e) ? "css" : null != n[e] ? "object" : void 0
  }

  function W(n) {
      if (w.dom(n)) {
          for (var e, t = n.style.transform || "", r = /(\w+)\(([^)]*)\)/g, a = new Map; e = r.exec(t);) a.set(e[1], e[2]);
          return a
      }
  }

  function X(n, e, t, r) {
      var a = u(e, "scale") ? 1 : 0 + (u(a = e, "translate") || "perspective" === a ? "px" : u(a, "rotate") || u(a, "skew") ? "deg" : void 0),
          o = W(n).get(e) || a;
      return t && (t.transforms.list.set(e, o), t.transforms.last = e), r ? y(n, o, r) : o
  }

  function T(n, e, t, r) {
      switch (b(n, e)) {
          case "transform":
              return X(n, e, r, t);
          case "css":
              return $(n, e, t);
          case "attribute":
              return v(n, e);
          default:
              return n[e] || 0
      }
  }

  function E(n, e) {
      var t = /^(\*=|\+=|-=)/.exec(n);
      if (!t) return n;
      var r = B(n) || 0,
          a = parseFloat(e),
          o = parseFloat(n.replace(t[0], ""));
      switch (t[0][0]) {
          case "+":
              return a + o + r;
          case "-":
              return a - o + r;
          case "*":
              return a * o + r
      }
  }

  function Y(n, e) {
      var t;
      return w.col(n) ? V(n) : /\s/g.test(n) ? n : (t = (t = B(n)) ? n.substr(0, n.length - t.length) : n, e ? t + e : t)
  }

  function F(n, e) {
      return Math.sqrt(Math.pow(e.x - n.x, 2) + Math.pow(e.y - n.y, 2))
  }

  function Z(n) {
      for (var e, t = n.points, r = 0, a = 0; a < t.numberOfItems; a++) {
          var o = t.getItem(a);
          0 < a && (r += F(e, o)), e = o
      }
      return r
  }

  function G(n) {
      if (n.getTotalLength) return n.getTotalLength();
      switch (n.tagName.toLowerCase()) {
          case "circle":
              return 2 * Math.PI * v(n, "r");
          case "rect":
              return 2 * v(t = n, "width") + 2 * v(t, "height");
          case "line":
              return F({
                  x: v(t = n, "x1"),
                  y: v(t, "y1")
              }, {
                  x: v(t, "x2"),
                  y: v(t, "y2")
              });
          case "polyline":
              return Z(n);
          case "polygon":
              return e = n.points, Z(n) + F(e.getItem(e.numberOfItems - 1), e.getItem(0))
      }
      var e, t
  }

  function Q(n, e) {
      var e = e || {},
          n = e.el || function(n) {
              for (var e = n.parentNode; w.svg(e) && w.svg(e.parentNode);) e = e.parentNode;
              return e
          }(n),
          t = n.getBoundingClientRect(),
          r = v(n, "viewBox"),
          a = t.width,
          t = t.height,
          e = e.viewBox || (r ? r.split(" ") : [0, 0, a, t]);
      return {
          el: n,
          viewBox: e,
          x: +e[0],
          y: +e[1],
          w: a,
          h: t,
          vW: e[2],
          vH: e[3]
      }
  }

  function z(n, e) {
      var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g,
          r = Y(w.pth(n) ? n.totalLength : n, e) + "";
      return {
          original: r,
          numbers: r.match(t) ? r.match(t).map(Number) : [0],
          strings: w.str(n) || e ? r.split(t) : []
      }
  }

  function A(n) {
      return I(n ? f(w.arr(n) ? n.map(p) : p(n)) : [], function(n, e, t) {
          return t.indexOf(n) === e
      })
  }

  function _(n) {
      var t = A(n);
      return t.map(function(n, e) {
          return {
              target: n,
              id: e,
              total: t.length,
              transforms: {
                  list: W(n)
              }
          }
      })
  }

  function R(e) {
      for (var t = I(f(e.map(function(n) {
              return Object.keys(n)
          })), function(n) {
              return w.key(n)
          }).reduce(function(n, e) {
              return n.indexOf(e) < 0 && n.push(e), n
          }, []), a = {}, n = 0; n < t.length; n++) ! function(n) {
          var r = t[n];
          a[r] = e.map(function(n) {
              var e, t = {};
              for (e in n) w.key(e) ? e == r && (t.value = n[e]) : t[e] = n[e];
              return t
          })
      }(n);
      return a
  }

  function J(n, e) {
      var t, r = [],
          a = e.keyframes;
      for (t in e = a ? D(R(a), e) : e) w.key(t) && r.push({
          name: t,
          tweens: function(n, t) {
              var e, r = g(t),
                  a = (/^spring/.test(r.easing) && (r.duration = c(r.easing)), w.arr(n) && (2 === (e = n.length) && !w.obj(n[0]) ? n = {
                      value: n
                  } : w.fnc(t.duration) || (r.duration = t.duration / e)), w.arr(n) ? n : [n]);
              return a.map(function(n, e) {
                  n = w.obj(n) && !w.pth(n) ? n : {
                      value: n
                  };
                  return w.und(n.delay) && (n.delay = e ? 0 : t.delay), w.und(n.endDelay) && (n.endDelay = e === a.length - 1 ? t.endDelay : 0), n
              }).map(function(n) {
                  return D(n, r)
              })
          }(e[t], n)
      });
      return r
  }

  function K(i, c) {
      var s;
      return i.tweens.map(function(n) {
          var n = function(n, e) {
                  var t, r = {};
                  for (t in n) {
                      var a = m(n[t], e);
                      w.arr(a) && 1 === (a = a.map(function(n) {
                          return m(n, e)
                      })).length && (a = a[0]), r[t] = a
                  }
                  return r.duration = parseFloat(r.duration), r.delay = parseFloat(r.delay), r
              }(n, c),
              e = n.value,
              t = w.arr(e) ? e[1] : e,
              r = B(t),
              a = T(c.target, i.name, r, c),
              o = s ? s.to.original : a,
              u = w.arr(e) ? e[0] : o,
              a = B(u) || B(a),
              r = r || a;
          return w.und(t) && (t = o), n.from = z(u, r), n.to = z(E(t, u), r), n.start = s ? s.end : 0, n.end = n.start + n.delay + n.duration + n.endDelay, n.easing = P(n.easing, n.duration), n.isPath = w.pth(e), n.isPathTargetInsideSVG = n.isPath && w.svg(c.target), n.isColor = w.col(n.from.original), n.isColor && (n.round = 1), s = n
      })
  }
  var U = {
      css: function(n, e, t) {
          return n.style[e] = t
      },
      attribute: function(n, e, t) {
          return n.setAttribute(e, t)
      },
      object: function(n, e, t) {
          return n[e] = t
      },
      transform: function(n, e, t, r, a) {
          var o;
          r.list.set(e, t), e !== r.last && !a || (o = "", r.list.forEach(function(n, e) {
              o += e + "(" + n + ") "
          }), n.style.transform = o)
      }
  };

  function nn(n, u) {
      _(n).forEach(function(n) {
          for (var e in u) {
              var t = m(u[e], n),
                  r = n.target,
                  a = B(t),
                  o = T(r, e, a, n),
                  t = E(Y(t, a || B(o)), o),
                  a = b(r, e);
              U[a](r, e, t, n.transforms, !0)
          }
      })
  }

  function en(n, e) {
      return I(f(n.map(function(o) {
          return e.map(function(n) {
              var e, t, r = o,
                  a = b(r.target, n.name);
              if (a) return t = (e = K(n, r))[e.length - 1], {
                  type: a,
                  property: n.name,
                  animatable: r,
                  tweens: e,
                  duration: t.end,
                  delay: e[0].delay,
                  endDelay: t.endDelay
              }
          })
      })), function(n) {
          return !w.und(n)
      })
  }

  function tn(n, e) {
      function t(n) {
          return n.timelineOffset || 0
      }
      var r = n.length,
          a = {};
      return a.duration = r ? Math.max.apply(Math, n.map(function(n) {
          return t(n) + n.duration
      })) : e.duration, a.delay = r ? Math.min.apply(Math, n.map(function(n) {
          return t(n) + n.delay
      })) : e.delay, a.endDelay = r ? a.duration - Math.max.apply(Math, n.map(function(n) {
          return t(n) + n.duration - n.endDelay
      })) : e.endDelay, a
  }
  var rn = 0;
  var N, S = [],
      an = ("undefined" != typeof document && document.addEventListener("visibilitychange", function() {
          L.suspendWhenDocumentHidden && (n() ? N = cancelAnimationFrame(N) : (S.forEach(function(n) {
              return n._onDocumentVisibility()
          }), an()))
      }), function() {
          !(N || n() && L.suspendWhenDocumentHidden) && 0 < S.length && (N = requestAnimationFrame(on))
      });

  function on(n) {
      for (var e = S.length, t = 0; t < e;) {
          var r = S[t];
          r.paused ? (S.splice(t, 1), e--) : (r.tick(n), t++)
      }
      N = 0 < t ? requestAnimationFrame(on) : void 0
  }

  function n() {
      return document && document.hidden
  }

  function L(n) {
      var c, s = 0,
          f = 0,
          l = 0,
          d = 0,
          p = null;

      function h(n) {
          var e = window.Promise && new Promise(function(n) {
              return p = n
          });
          return n.finished = e
      }
      e = x(i, n = n = void 0 === n ? {} : n), t = J(r = x(M, n), n), n = _(n.targets), r = tn(t = en(n, t), r), a = rn, rn++;
      var e, t, r, a, k = D(e, {
          id: a,
          children: [],
          animatables: n,
          animations: t,
          duration: r.duration,
          delay: r.delay,
          endDelay: r.endDelay
      });
      h(k);

      function g() {
          var n = k.direction;
          "alternate" !== n && (k.direction = "normal" !== n ? "normal" : "reverse"), k.reversed = !k.reversed, c.forEach(function(n) {
              return n.reversed = k.reversed
          })
      }

      function m(n) {
          return k.reversed ? k.duration - n : n
      }

      function o() {
          s = 0, f = m(k.currentTime) * (1 / L.speed)
      }

      function v(n, e) {
          e && e.seek(n - e.timelineOffset)
      }

      function y(e) {
          for (var n = 0, t = k.animations, r = t.length; n < r;) {
              for (var a = t[n], o = a.animatable, u = a.tweens, i = u.length - 1, c = u[i], i = (i && (c = I(u, function(n) {
                      return e < n.end
                  })[0] || c), C(e - c.start - c.delay, 0, c.duration) / c.duration), s = isNaN(i) ? 1 : c.easing(i), f = c.to.strings, l = c.round, d = [], p = c.to.numbers.length, h = void 0, g = 0; g < p; g++) {
                  var m = void 0,
                      v = c.to.numbers[g],
                      y = c.from.numbers[g] || 0,
                      m = c.isPath ? function(e, t, n) {
                          function r(n) {
                              return e.el.getPointAtLength(1 <= t + (n = void 0 === n ? 0 : n) ? t + n : 0)
                          }
                          var a = Q(e.el, e.svg),
                              o = r(),
                              u = r(-1),
                              i = r(1),
                              c = n ? 1 : a.w / a.vW,
                              s = n ? 1 : a.h / a.vH;
                          switch (e.property) {
                              case "x":
                                  return (o.x - a.x) * c;
                              case "y":
                                  return (o.y - a.y) * s;
                              case "angle":
                                  return 180 * Math.atan2(i.y - u.y, i.x - u.x) / Math.PI
                          }
                      }(c.value, s * v, c.isPathTargetInsideSVG) : y + s * (v - y);
                  !l || c.isColor && 2 < g || (m = Math.round(m * l) / l), d.push(m)
              }
              var b = f.length;
              if (b)
                  for (var h = f[0], M = 0; M < b; M++) {
                      f[M];
                      var x = f[M + 1],
                          w = d[M];
                      isNaN(w) || (h += x ? w + x : w + " ")
                  } else h = d[0];
              U[a.type](o.target, a.property, h, o.transforms), a.currentValue = h, n++
          }
      }

      function b(n) {
          k[n] && !k.passThrough && k[n](k)
      }

      function u(n) {
          var e = k.duration,
              t = k.delay,
              r = e - k.endDelay,
              a = m(n);
          if (k.progress = C(a / e * 100, 0, 100), k.reversePlayback = a < k.currentTime, c) {
              var o = a;
              if (k.reversePlayback)
                  for (var u = d; u--;) v(o, c[u]);
              else
                  for (var i = 0; i < d; i++) v(o, c[i])
          }!k.began && 0 < k.currentTime && (k.began = !0, b("begin")), !k.loopBegan && 0 < k.currentTime && (k.loopBegan = !0, b("loopBegin")), a <= t && 0 !== k.currentTime && y(0), (r <= a && k.currentTime !== e || !e) && y(e), t < a && a < r ? (k.changeBegan || (k.changeBegan = !0, k.changeCompleted = !1, b("changeBegin")), b("change"), y(a)) : k.changeBegan && (k.changeCompleted = !0, k.changeBegan = !1, b("changeComplete")), k.currentTime = C(a, 0, e), k.began && b("update"), e <= n && (f = 0, k.remaining && !0 !== k.remaining && k.remaining--, k.remaining ? (s = l, b("loopComplete"), k.loopBegan = !1, "alternate" === k.direction && g()) : (k.paused = !0, k.completed || (k.completed = !0, b("loopComplete"), b("complete"), !k.passThrough && "Promise" in window && (p(), h(k)))))
      }
      return k.reset = function() {
          var n = k.direction;
          k.passThrough = !1, k.currentTime = 0, k.progress = 0, k.paused = !0, k.began = !1, k.loopBegan = !1, k.changeBegan = !1, k.completed = !1, k.changeCompleted = !1, k.reversePlayback = !1, k.reversed = "reverse" === n, k.remaining = k.loop, c = k.children;
          for (var e = d = c.length; e--;) k.children[e].reset();
          (k.reversed && !0 !== k.loop || "alternate" === n && 1 === k.loop) && k.remaining++, y(k.reversed ? k.duration : 0)
      }, k._onDocumentVisibility = o, k.set = function(n, e) {
          return nn(n, e), k
      }, k.tick = function(n) {
          u(((l = n) + (f - (s = s || l))) * L.speed)
      }, k.seek = function(n) {
          u(m(n))
      }, k.pause = function() {
          k.paused = !0, o()
      }, k.play = function() {
          k.paused && (k.completed && k.reset(), k.paused = !1, S.push(k), o(), an())
      }, k.reverse = function() {
          g(), k.completed = !k.reversed, o()
      }, k.restart = function() {
          k.reset(), k.play()
      }, k.remove = function(n) {
          cn(A(n), k)
      }, k.reset(), k.autoplay && k.play(), k
  }

  function un(n, e) {
      for (var t = e.length; t--;) h(n, e[t].animatable.target) && e.splice(t, 1)
  }

  function cn(n, e) {
      var t = e.animations,
          r = e.children;
      un(n, t);
      for (var a = r.length; a--;) {
          var o = r[a],
              u = o.animations;
          un(n, u), u.length || o.children.length || r.splice(a, 1)
      }
      t.length || r.length || e.pause()
  }
  return L.version = "3.2.2", L.speed = 1, L.suspendWhenDocumentHidden = !0, L.running = S, L.remove = function(n) {
      for (var e = A(n), t = S.length; t--;) cn(e, S[t])
  }, L.get = T, L.set = nn, L.convertPx = y, L.path = function(n, e) {
      var t = w.str(n) ? a(n)[0] : n,
          r = e || 100;
      return function(n) {
          return {
              property: n,
              el: t,
              svg: Q(t),
              totalLength: G(t) * (r / 100)
          }
      }
  }, L.setDashoffset = function(n) {
      var e = G(n);
      return n.setAttribute("stroke-dasharray", e), e
  }, L.stagger = function(n, e) {
      var i = (e = void 0 === e ? {} : e).direction || "normal",
          c = e.easing ? P(e.easing) : null,
          s = e.grid,
          f = e.axis,
          l = e.from || 0,
          d = "first" === l,
          p = "center" === l,
          h = "last" === l,
          g = w.arr(n),
          m = g ? parseFloat(n[0]) : parseFloat(n),
          v = g ? parseFloat(n[1]) : 0,
          y = B(g ? n[1] : n) || 0,
          b = e.start || 0 + (g ? m : 0),
          M = [],
          x = 0;
      return function(n, e, t) {
          if (d && (l = 0), p && (l = (t - 1) / 2), h && (l = t - 1), !M.length) {
              for (var r, a, o, u = 0; u < t; u++) s ? (r = p ? (s[0] - 1) / 2 : l % s[0], a = p ? (s[1] - 1) / 2 : Math.floor(l / s[0]), r = r - u % s[0], a = a - Math.floor(u / s[0]), o = Math.sqrt(r * r + a * a), "x" === f && (o = -r), M.push(o = "y" === f ? -a : o)) : M.push(Math.abs(l - u)), x = Math.max.apply(Math, M);
              c && (M = M.map(function(n) {
                  return c(n / x) * x
              })), "reverse" === i && (M = M.map(function(n) {
                  return f ? n < 0 ? -1 * n : -n : Math.abs(x - n)
              }))
          }
          return b + (g ? (v - m) / x : m) * (Math.round(100 * M[e]) / 100) + y
      }
  }, L.timeline = function(u) {
      var i = L(u = void 0 === u ? {} : u);
      return i.duration = 0, i.add = function(n, e) {
          var t = S.indexOf(i),
              r = i.children;

          function a(n) {
              n.passThrough = !0
          } - 1 < t && S.splice(t, 1);
          for (var o = 0; o < r.length; o++) a(r[o]);
          t = D(n, x(M, u)), t.targets = t.targets || u.targets, n = i.duration, t.autoplay = !1, t.direction = i.direction, t.timelineOffset = w.und(e) ? n : E(e, n), a(i), i.seek(t.timelineOffset), e = L(t), a(e), r.push(e), n = tn(r, u);
          return i.delay = n.delay, i.endDelay = n.endDelay, i.duration = n.duration, i.seek(0), i.reset(), i.autoplay && i.play(), i
      }, i
  }, L.easing = P, L.penner = s, L.random = function(n, e) {
      return Math.floor(Math.random() * (e - n + 1)) + n
  }, L
});
var Atropos = function() {
  "use strict";

  function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key]
                  }
              }
          }
          return target
      };
      return _extends.apply(this, arguments)
  }
  var $ = function $(el, sel) {
      return el.querySelector(sel)
  };
  var $$ = function $$(el, sel) {
      return el.querySelectorAll(sel)
  };
  var removeUndefinedProps = function removeUndefinedProps(obj) {
      if (obj === void 0) {
          obj = {}
      }
      var result = {};
      Object.keys(obj).forEach(function(key) {
          if (typeof obj[key] !== "undefined") result[key] = obj[key]
      });
      return result
  };
  var defaults = {
      alwaysActive: false,
      activeOffset: 50,
      shadowOffset: 50,
      shadowScale: 1,
      duration: 300,
      rotate: true,
      rotateTouch: true,
      rotateXMax: 15,
      rotateYMax: 15,
      rotateXInvert: false,
      rotateYInvert: false,
      stretchX: 0,
      stretchY: 0,
      stretchZ: 0,
      commonOrigin: true,
      shadow: true,
      highlight: true
  };

  function Atropos(originalParams) {
      if (originalParams === void 0) {
          originalParams = {}
      }
      var _originalParams = originalParams,
          el = _originalParams.el,
          eventsEl = _originalParams.eventsEl;
      var _originalParams2 = originalParams,
          isComponent = _originalParams2.isComponent;
      var childrenRootEl;
      var self = {
          __atropos__: true,
          params: _extends({}, defaults, {
              onEnter: null,
              onLeave: null,
              onRotate: null
          }, removeUndefinedProps(originalParams || {})),
          destroyed: false,
          isActive: false
      };
      var params = self.params;
      var rotateEl;
      var scaleEl;
      var innerEl;
      var elBoundingClientRect;
      var eventsElBoundingClientRect;
      var shadowEl;
      var highlightEl;
      var isScrolling;
      var clientXStart;
      var clientYStart;
      var queue = [];
      var queueFrameId;
      var purgeQueue = function purgeQueue() {
          queueFrameId = requestAnimationFrame(function() {
              queue.forEach(function(data) {
                  if (typeof data === "function") {
                      data()
                  } else {
                      var element = data.element,
                          prop = data.prop,
                          value = data.value;
                      element.style[prop] = value
                  }
              });
              queue.splice(0, queue.length);
              purgeQueue()
          })
      };
      purgeQueue();
      var $setDuration = function $setDuration(element, value) {
          queue.push({
              element: element,
              prop: "transitionDuration",
              value: value
          })
      };
      var $setEasing = function $setEasing(element, value) {
          queue.push({
              element: element,
              prop: "transitionTimingFunction",
              value: value
          })
      };
      var $setTransform = function $setTransform(element, value) {
          queue.push({
              element: element,
              prop: "transform",
              value: value
          })
      };
      var $setOpacity = function $setOpacity(element, value) {
          queue.push({
              element: element,
              prop: "opacity",
              value: value
          })
      };
      var $setOrigin = function $setOrigin(element, value) {
          queue.push({
              element: element,
              prop: "transformOrigin",
              value: value
          })
      };
      var $on = function $on(element, event, handler, props) {
          return element.addEventListener(event, handler, props)
      };
      var $off = function $off(element, event, handler, props) {
          return element.removeEventListener(event, handler, props)
      };
      var createShadow = function createShadow() {
          var created;
          shadowEl = $(el, ".atropos-shadow");
          if (!shadowEl) {
              shadowEl = document.createElement("span");
              shadowEl.classList.add("atropos-shadow");
              created = true
          }
          $setTransform(shadowEl, "translate3d(0,0,-" + params.shadowOffset + "px) scale(" + params.shadowScale + ")");
          if (created) {
              rotateEl.appendChild(shadowEl)
          }
      };
      var createHighlight = function createHighlight() {
          var created;
          highlightEl = $(el, ".atropos-highlight");
          if (!highlightEl) {
              highlightEl = document.createElement("span");
              highlightEl.classList.add("atropos-highlight");
              created = true
          }
          $setTransform(highlightEl, "translate3d(0,0,0)");
          if (created) {
              innerEl.appendChild(highlightEl)
          }
      };
      var setChildrenOffset = function setChildrenOffset(_ref) {
          var _ref$rotateXPercentag = _ref.rotateXPercentage,
              rotateXPercentage = _ref$rotateXPercentag === void 0 ? 0 : _ref$rotateXPercentag,
              _ref$rotateYPercentag = _ref.rotateYPercentage,
              rotateYPercentage = _ref$rotateYPercentag === void 0 ? 0 : _ref$rotateYPercentag,
              duration = _ref.duration,
              opacityOnly = _ref.opacityOnly,
              easeOut = _ref.easeOut;
          var getOpacity = function getOpacity(element) {
              if (element.dataset.atroposOpacity && typeof element.dataset.atroposOpacity === "string") {
                  return element.dataset.atroposOpacity.split(";").map(function(v) {
                      return parseFloat(v)
                  })
              }
              return undefined
          };
          $$(childrenRootEl, "[data-atropos-offset], [data-atropos-opacity]").forEach(function(childEl) {
              $setDuration(childEl, duration);
              $setEasing(childEl, easeOut ? "ease-out" : "");
              var elementOpacity = getOpacity(childEl);
              if (rotateXPercentage === 0 && rotateYPercentage === 0) {
                  if (!opacityOnly) $setTransform(childEl, "translate3d(0, 0, 0)");
                  if (elementOpacity) $setOpacity(childEl, elementOpacity[0])
              } else {
                  var childElOffset = parseFloat(childEl.dataset.atroposOffset) / 100;
                  if (!Number.isNaN(childElOffset) && !opacityOnly) {
                      $setTransform(childEl, "translate3d(" + -rotateYPercentage * -childElOffset + "%, " + rotateXPercentage * -childElOffset + "%, 0)")
                  }
                  if (elementOpacity) {
                      var min = elementOpacity[0],
                          max = elementOpacity[1];
                      var rotatePercentage = Math.max(Math.abs(rotateXPercentage), Math.abs(rotateYPercentage));
                      $setOpacity(childEl, min + (max - min) * rotatePercentage / 100)
                  }
              }
          })
      };
      var setElements = function setElements(clientX, clientY) {
          var isMultiple = el !== eventsEl;
          if (!elBoundingClientRect) {
              elBoundingClientRect = el.getBoundingClientRect()
          }
          if (isMultiple && !eventsElBoundingClientRect) {
              eventsElBoundingClientRect = eventsEl.getBoundingClientRect()
          }
          if (typeof clientX === "undefined" && typeof clientY === "undefined") {
              var rect = isMultiple ? eventsElBoundingClientRect : elBoundingClientRect;
              clientX = rect.left + rect.width / 2;
              clientY = rect.top + rect.height / 2
          }
          var rotateX = 0;
          var rotateY = 0;
          var _elBoundingClientRect = elBoundingClientRect,
              top = _elBoundingClientRect.top,
              left = _elBoundingClientRect.left,
              width = _elBoundingClientRect.width,
              height = _elBoundingClientRect.height;
          var transformOrigin;
          if (!isMultiple) {
              var centerX = width / 2;
              var centerY = height / 2;
              var coordX = clientX - left;
              var coordY = clientY - top;
              rotateY = params.rotateYMax * (coordX - centerX) / (width / 2) * -1;
              rotateX = params.rotateXMax * (coordY - centerY) / (height / 2)
          } else {
              var _eventsElBoundingClie = eventsElBoundingClientRect,
                  parentTop = _eventsElBoundingClie.top,
                  parentLeft = _eventsElBoundingClie.left,
                  parentWidth = _eventsElBoundingClie.width,
                  parentHeight = _eventsElBoundingClie.height;
              var offsetLeft = left - parentLeft;
              var offsetTop = top - parentTop;
              var _centerX = width / 2 + offsetLeft;
              var _centerY = height / 2 + offsetTop;
              var _coordX = clientX - parentLeft;
              var _coordY = clientY - parentTop;
              rotateY = params.rotateYMax * (_coordX - _centerX) / (parentWidth - width / 2) * -1;
              rotateX = params.rotateXMax * (_coordY - _centerY) / (parentHeight - height / 2);
              transformOrigin = clientX - left + "px " + (clientY - top) + "px"
          }
          rotateX = Math.min(Math.max(-rotateX, -params.rotateXMax), params.rotateXMax);
          if (params.rotateXInvert) rotateX = -rotateX;
          rotateY = Math.min(Math.max(-rotateY, -params.rotateYMax), params.rotateYMax);
          if (params.rotateYInvert) rotateY = -rotateY;
          var rotateXPercentage = rotateX / params.rotateXMax * 100;
          var rotateYPercentage = rotateY / params.rotateYMax * 100;
          var stretchX = (isMultiple ? rotateYPercentage / 100 * params.stretchX : 0) * (params.rotateYInvert ? -1 : 1);
          var stretchY = (isMultiple ? rotateXPercentage / 100 * params.stretchY : 0) * (params.rotateXInvert ? -1 : 1);
          var stretchZ = isMultiple ? Math.max(Math.abs(rotateXPercentage), Math.abs(rotateYPercentage)) / 100 * params.stretchZ : 0;
          $setTransform(rotateEl, "translate3d(" + stretchX + "%, " + -stretchY + "%, " + -stretchZ + "px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
          if (transformOrigin && params.commonOrigin) {
              $setOrigin(rotateEl, transformOrigin)
          }
          if (highlightEl) {
              $setDuration(highlightEl, params.duration + "ms");
              $setEasing(highlightEl, "ease-out");
              $setTransform(highlightEl, "translate3d(" + -rotateYPercentage * .25 + "%, " + rotateXPercentage * .25 + "%, 0)");
              $setOpacity(highlightEl, Math.max(Math.abs(rotateXPercentage), Math.abs(rotateYPercentage)) / 100)
          }
          setChildrenOffset({
              rotateXPercentage: rotateXPercentage,
              rotateYPercentage: rotateYPercentage,
              duration: params.duration + "ms",
              easeOut: true
          });
          if (typeof params.onRotate === "function") params.onRotate(rotateX, rotateY)
      };
      var activate = function activate() {
          queue.push(function() {
              return el.classList.add("atropos-active")
          });
          $setDuration(rotateEl, params.duration + "ms");
          $setEasing(rotateEl, "ease-out");
          $setTransform(scaleEl, "translate3d(0,0, " + params.activeOffset + "px)");
          $setDuration(scaleEl, params.duration + "ms");
          $setEasing(scaleEl, "ease-out");
          if (shadowEl) {
              $setDuration(shadowEl, params.duration + "ms");
              $setEasing(shadowEl, "ease-out")
          }
          self.isActive = true
      };
      var onPointerEnter = function onPointerEnter(e) {
          isScrolling = undefined;
          if (e.type === "pointerdown" && e.pointerType === "mouse") return;
          if (e.type === "pointerenter" && e.pointerType !== "mouse") return;
          if (e.type === "pointerdown") {
              e.preventDefault()
          }
          clientXStart = e.clientX;
          clientYStart = e.clientY;
          if (params.alwaysActive) {
              elBoundingClientRect = undefined;
              eventsElBoundingClientRect = undefined;
              return
          }
          activate();
          if (typeof params.onEnter === "function") params.onEnter()
      };
      var onTouchMove = function onTouchMove(e) {
          if (isScrolling === false && e.cancelable) {
              e.preventDefault()
          }
      };
      var onPointerMove = function onPointerMove(e) {
          if (!params.rotate || !self.isActive) return;
          if (e.pointerType !== "mouse") {
              if (!params.rotateTouch) return;
              e.preventDefault()
          }
          var clientX = e.clientX,
              clientY = e.clientY;
          var diffX = clientX - clientXStart;
          var diffY = clientY - clientYStart;
          if (typeof params.rotateTouch === "string" && (diffX !== 0 || diffY !== 0) && typeof isScrolling === "undefined") {
              if (diffX * diffX + diffY * diffY >= 25) {
                  var touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                  isScrolling = params.rotateTouch === "scroll-y" ? touchAngle > 45 : 90 - touchAngle > 45
              }
              if (isScrolling === false) {
                  el.classList.add("atropos-rotate-touch");
                  if (e.cancelable) {
                      e.preventDefault()
                  }
              }
          }
          if (e.pointerType !== "mouse" && isScrolling) {
              return
          }
          setElements(clientX, clientY)
      };
      var onPointerLeave = function onPointerLeave(e) {
          elBoundingClientRect = undefined;
          eventsElBoundingClientRect = undefined;
          if (!self.isActive) return;
          if (e && e.type === "pointerup" && e.pointerType === "mouse") return;
          if (e && e.type === "pointerleave" && e.pointerType !== "mouse") return;
          if (typeof params.rotateTouch === "string" && isScrolling) {
              el.classList.remove("atropos-rotate-touch")
          }
          if (params.alwaysActive) {
              setElements();
              if (typeof params.onRotate === "function") params.onRotate(0, 0);
              if (typeof params.onLeave === "function") params.onLeave();
              return
          }
          queue.push(function() {
              return el.classList.remove("atropos-active")
          });
          $setDuration(scaleEl, params.duration + "ms");
          $setEasing(scaleEl, "");
          $setTransform(scaleEl, "translate3d(0,0, " + 0 + "px)");
          if (shadowEl) {
              $setDuration(shadowEl, params.duration + "ms");
              $setEasing(shadowEl, "")
          }
          if (highlightEl) {
              $setDuration(highlightEl, params.duration + "ms");
              $setEasing(highlightEl, "");
              $setTransform(highlightEl, "translate3d(0, 0, 0)");
              $setOpacity(highlightEl, 0)
          }
          $setDuration(rotateEl, params.duration + "ms");
          $setEasing(rotateEl, "");
          $setTransform(rotateEl, "translate3d(0,0,0) rotateX(0deg) rotateY(0deg)");
          setChildrenOffset({
              duration: params.duration + "ms"
          });
          self.isActive = false;
          if (typeof params.onRotate === "function") params.onRotate(0, 0);
          if (typeof params.onLeave === "function") params.onLeave()
      };
      var onDocumentClick = function onDocumentClick(e) {
          var clickTarget = e.target;
          if (!eventsEl.contains(clickTarget) && clickTarget !== eventsEl && self.isActive) {
              onPointerLeave()
          }
      };
      var initDOM = function initDOM() {
          if (typeof el === "string") {
              el = $(document, el)
          }
          if (!el) return;
          if (el.__atropos__) return;
          if (typeof eventsEl !== "undefined") {
              if (typeof eventsEl === "string") {
                  eventsEl = $(document, eventsEl)
              }
          } else {
              eventsEl = el
          }
          childrenRootEl = isComponent ? el.parentNode.host : el;
          Object.assign(self, {
              el: el
          });
          rotateEl = $(el, ".atropos-rotate");
          scaleEl = $(el, ".atropos-scale");
          innerEl = $(el, ".atropos-inner");
          el.__atropos__ = self
      };
      var init = function init() {
          initDOM();
          if (!el || !eventsEl) return;
          if (params.shadow) {
              createShadow()
          }
          if (params.highlight) {
              createHighlight()
          }
          if (params.rotateTouch) {
              if (typeof params.rotateTouch === "string") {
                  el.classList.add("atropos-rotate-touch-" + params.rotateTouch)
              } else {
                  el.classList.add("atropos-rotate-touch")
              }
          }
          if ($(childrenRootEl, "[data-atropos-opacity]")) {
              setChildrenOffset({
                  opacityOnly: true
              })
          }
          $on(document, "click", onDocumentClick);
          $on(eventsEl, "pointerdown", onPointerEnter);
          $on(eventsEl, "pointerenter", onPointerEnter);
          $on(eventsEl, "pointermove", onPointerMove);
          $on(eventsEl, "touchmove", onTouchMove);
          $on(eventsEl, "pointerleave", onPointerLeave);
          $on(eventsEl, "pointerup", onPointerLeave);
          $on(eventsEl, "lostpointercapture", onPointerLeave);
          if (params.alwaysActive) {
              activate();
              setElements()
          }
      };
      var destroy = function destroy() {
          self.destroyed = true;
          cancelAnimationFrame(queueFrameId);
          $off(document, "click", onDocumentClick);
          $off(eventsEl, "pointerdown", onPointerEnter);
          $off(eventsEl, "pointerenter", onPointerEnter);
          $off(eventsEl, "pointermove", onPointerMove);
          $off(eventsEl, "touchmove", onTouchMove);
          $off(eventsEl, "pointerleave", onPointerLeave);
          $off(eventsEl, "pointerup", onPointerLeave);
          $off(eventsEl, "lostpointercapture", onPointerLeave);
          delete el.__atropos__
      };
      self.destroy = destroy;
      init();
      return self
  }
  return Atropos
}();
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.bootstrap = factory())
})(this, function() {
  "use strict";
  const elementMap = new Map;
  const Data = {
      set(element, key, instance) {
          if (!elementMap.has(element)) {
              elementMap.set(element, new Map)
          }
          const instanceMap = elementMap.get(element);
          if (!instanceMap.has(key) && instanceMap.size !== 0) {
              console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
              return
          }
          instanceMap.set(key, instance)
      },
      get(element, key) {
          if (elementMap.has(element)) {
              return elementMap.get(element).get(key) || null
          }
          return null
      },
      remove(element, key) {
          if (!elementMap.has(element)) {
              return
          }
          const instanceMap = elementMap.get(element);
          instanceMap["delete"](key);
          if (instanceMap.size === 0) {
              elementMap["delete"](element)
          }
      }
  };
  const MAX_UID = 1e6;
  const MILLISECONDS_MULTIPLIER = 1e3;
  const TRANSITION_END = "transitionend";
  const parseSelector = selector => {
      if (selector && window.CSS && window.CSS.escape) {
          selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`)
      }
      return selector
  };
  const toType = object => {
      if (object === null || object === undefined) {
          return `${object}`
      }
      return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase()
  };
  const getUID = prefix => {
      do {
          prefix += Math.floor(Math.random() * MAX_UID)
      } while (document.getElementById(prefix));
      return prefix
  };
  const getTransitionDurationFromElement = element => {
      if (!element) {
          return 0
      }
      let {
          transitionDuration,
          transitionDelay
      } = window.getComputedStyle(element);
      const floatTransitionDuration = Number.parseFloat(transitionDuration);
      const floatTransitionDelay = Number.parseFloat(transitionDelay);
      if (!floatTransitionDuration && !floatTransitionDelay) {
          return 0
      }
      transitionDuration = transitionDuration.split(",")[0];
      transitionDelay = transitionDelay.split(",")[0];
      return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER
  };
  const triggerTransitionEnd = element => {
      element.dispatchEvent(new Event(TRANSITION_END))
  };
  const isElement$1 = object => {
      if (!object || typeof object !== "object") {
          return false
      }
      if (typeof object.jquery !== "undefined") {
          object = object[0]
      }
      return typeof object.nodeType !== "undefined"
  };
  const getElement = object => {
      if (isElement$1(object)) {
          return object.jquery ? object[0] : object
      }
      if (typeof object === "string" && object.length > 0) {
          return document.querySelector(parseSelector(object))
      }
      return null
  };
  const isVisible = element => {
      if (!isElement$1(element) || element.getClientRects().length === 0) {
          return false
      }
      const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
      const closedDetails = element.closest("details:not([open])");
      if (!closedDetails) {
          return elementIsVisible
      }
      if (closedDetails !== element) {
          const summary = element.closest("summary");
          if (summary && summary.parentNode !== closedDetails) {
              return false
          }
          if (summary === null) {
              return false
          }
      }
      return elementIsVisible
  };
  const isDisabled = element => {
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
          return true
      }
      if (element.classList.contains("disabled")) {
          return true
      }
      if (typeof element.disabled !== "undefined") {
          return element.disabled
      }
      return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false"
  };
  const findShadowRoot = element => {
      if (!document.documentElement.attachShadow) {
          return null
      }
      if (typeof element.getRootNode === "function") {
          const root = element.getRootNode();
          return root instanceof ShadowRoot ? root : null
      }
      if (element instanceof ShadowRoot) {
          return element
      }
      if (!element.parentNode) {
          return null
      }
      return findShadowRoot(element.parentNode)
  };
  const noop = () => {};
  const reflow = element => {
      element.offsetHeight
  };
  const getjQuery = () => {
      if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
          return window.jQuery
      }
      return null
  };
  const DOMContentLoadedCallbacks = [];
  const onDOMContentLoaded = callback => {
      if (document.readyState === "loading") {
          if (!DOMContentLoadedCallbacks.length) {
              document.addEventListener("DOMContentLoaded", () => {
                  for (const callback of DOMContentLoadedCallbacks) {
                      callback()
                  }
              })
          }
          DOMContentLoadedCallbacks.push(callback)
      } else {
          callback()
      }
  };
  const isRTL = () => document.documentElement.dir === "rtl";
  const defineJQueryPlugin = plugin => {
      onDOMContentLoaded(() => {
          const $ = getjQuery();
          if ($) {
              const name = plugin.NAME;
              const JQUERY_NO_CONFLICT = $.fn[name];
              $.fn[name] = plugin.jQueryInterface;
              $.fn[name].Constructor = plugin;
              $.fn[name].noConflict = () => {
                  $.fn[name] = JQUERY_NO_CONFLICT;
                  return plugin.jQueryInterface
              }
          }
      })
  };
  const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
      return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue
  };
  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
      if (!waitForTransition) {
          execute(callback);
          return
      }
      const durationPadding = 5;
      const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
      let called = false;
      const handler = ({
          target
      }) => {
          if (target !== transitionElement) {
              return
          }
          called = true;
          transitionElement.removeEventListener(TRANSITION_END, handler);
          execute(callback)
      };
      transitionElement.addEventListener(TRANSITION_END, handler);
      setTimeout(() => {
          if (!called) {
              triggerTransitionEnd(transitionElement)
          }
      }, emulatedDuration)
  };
  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
      const listLength = list.length;
      let index = list.indexOf(activeElement);
      if (index === -1) {
          return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0]
      }
      index += shouldGetNext ? 1 : -1;
      if (isCycleAllowed) {
          index = (index + listLength) % listLength
      }
      return list[Math.max(0, Math.min(index, listLength - 1))]
  };
  const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  const stripNameRegex = /\..*/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {};
  let uidEvent = 1;
  const customEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
  };
  const nativeEvents = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

  function makeEventUid(element, uid) {
      return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++
  }

  function getElementEvents(element) {
      const uid = makeEventUid(element);
      element.uidEvent = uid;
      eventRegistry[uid] = eventRegistry[uid] || {};
      return eventRegistry[uid]
  }

  function bootstrapHandler(element, fn) {
      return function handler(event) {
          hydrateObj(event, {
              delegateTarget: element
          });
          if (handler.oneOff) {
              EventHandler.off(element, event.type, fn)
          }
          return fn.apply(element, [event])
      }
  }

  function bootstrapDelegationHandler(element, selector, fn) {
      return function handler(event) {
          const domElements = element.querySelectorAll(selector);
          for (let {
                  target
              } = event; target && target !== this; target = target.parentNode) {
              for (const domElement of domElements) {
                  if (domElement !== target) {
                      continue
                  }
                  hydrateObj(event, {
                      delegateTarget: target
                  });
                  if (handler.oneOff) {
                      EventHandler.off(element, event.type, selector, fn)
                  }
                  return fn.apply(target, [event])
              }
          }
      }
  }

  function findHandler(events, callable, delegationSelector = null) {
      return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector)
  }

  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
      const isDelegated = typeof handler === "string";
      const callable = isDelegated ? delegationFunction : handler || delegationFunction;
      let typeEvent = getTypeEvent(originalTypeEvent);
      if (!nativeEvents.has(typeEvent)) {
          typeEvent = originalTypeEvent
      }
      return [isDelegated, callable, typeEvent]
  }

  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
      if (typeof originalTypeEvent !== "string" || !element) {
          return
      }
      let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      if (originalTypeEvent in customEvents) {
          const wrapFunction = fn => {
              return function(event) {
                  if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
                      return fn.call(this, event)
                  }
              }
          };
          callable = wrapFunction(callable)
      }
      const events = getElementEvents(element);
      const handlers = events[typeEvent] || (events[typeEvent] = {});
      const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
      if (previousFunction) {
          previousFunction.oneOff = previousFunction.oneOff && oneOff;
          return
      }
      const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
      const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
      fn.delegationSelector = isDelegated ? handler : null;
      fn.callable = callable;
      fn.oneOff = oneOff;
      fn.uidEvent = uid;
      handlers[uid] = fn;
      element.addEventListener(typeEvent, fn, isDelegated)
  }

  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
      const fn = findHandler(events[typeEvent], handler, delegationSelector);
      if (!fn) {
          return
      }
      element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
      delete events[typeEvent][fn.uidEvent]
  }

  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
      const storeElementEvent = events[typeEvent] || {};
      for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
          if (handlerKey.includes(namespace)) {
              removeHandler(element, events, typeEvent, event.callable, event.delegationSelector)
          }
      }
  }

  function getTypeEvent(event) {
      event = event.replace(stripNameRegex, "");
      return customEvents[event] || event
  }
  const EventHandler = {
      on(element, event, handler, delegationFunction) {
          addHandler(element, event, handler, delegationFunction, false)
      },
      one(element, event, handler, delegationFunction) {
          addHandler(element, event, handler, delegationFunction, true)
      },
      off(element, originalTypeEvent, handler, delegationFunction) {
          if (typeof originalTypeEvent !== "string" || !element) {
              return
          }
          const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
          const inNamespace = typeEvent !== originalTypeEvent;
          const events = getElementEvents(element);
          const storeElementEvent = events[typeEvent] || {};
          const isNamespace = originalTypeEvent.startsWith(".");
          if (typeof callable !== "undefined") {
              if (!Object.keys(storeElementEvent).length) {
                  return
              }
              removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
              return
          }
          if (isNamespace) {
              for (const elementEvent of Object.keys(events)) {
                  removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1))
              }
          }
          for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
              const handlerKey = keyHandlers.replace(stripUidRegex, "");
              if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                  removeHandler(element, events, typeEvent, event.callable, event.delegationSelector)
              }
          }
      },
      trigger(element, event, args) {
          if (typeof event !== "string" || !element) {
              return null
          }
          const $ = getjQuery();
          const typeEvent = getTypeEvent(event);
          const inNamespace = event !== typeEvent;
          let jQueryEvent = null;
          let bubbles = true;
          let nativeDispatch = true;
          let defaultPrevented = false;
          if (inNamespace && $) {
              jQueryEvent = $.Event(event, args);
              $(element).trigger(jQueryEvent);
              bubbles = !jQueryEvent.isPropagationStopped();
              nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
              defaultPrevented = jQueryEvent.isDefaultPrevented()
          }
          const evt = hydrateObj(new Event(event, {
              bubbles: bubbles,
              cancelable: true
          }), args);
          if (defaultPrevented) {
              evt.preventDefault()
          }
          if (nativeDispatch) {
              element.dispatchEvent(evt)
          }
          if (evt.defaultPrevented && jQueryEvent) {
              jQueryEvent.preventDefault()
          }
          return evt
      }
  };

  function hydrateObj(obj, meta = {}) {
      for (const [key, value] of Object.entries(meta)) {
          try {
              obj[key] = value
          } catch (_unused) {
              Object.defineProperty(obj, key, {
                  configurable: true,
                  get() {
                      return value
                  }
              })
          }
      }
      return obj
  }

  function normalizeData(value) {
      if (value === "true") {
          return true
      }
      if (value === "false") {
          return false
      }
      if (value === Number(value).toString()) {
          return Number(value)
      }
      if (value === "" || value === "null") {
          return null
      }
      if (typeof value !== "string") {
          return value
      }
      try {
          return JSON.parse(decodeURIComponent(value))
      } catch (_unused) {
          return value
      }
  }

  function normalizeDataKey(key) {
      return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`)
  }
  const Manipulator = {
      setDataAttribute(element, key, value) {
          element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value)
      },
      removeDataAttribute(element, key) {
          element.removeAttribute(`data-bs-${normalizeDataKey(key)}`)
      },
      getDataAttributes(element) {
          if (!element) {
              return {}
          }
          const attributes = {};
          const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith("bs") && !key.startsWith("bsConfig"));
          for (const key of bsKeys) {
              let pureKey = key.replace(/^bs/, "");
              pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
              attributes[pureKey] = normalizeData(element.dataset[key])
          }
          return attributes
      },
      getDataAttribute(element, key) {
          return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`))
      }
  };
  class Config {
      static get Default() {
          return {}
      }
      static get DefaultType() {
          return {}
      }
      static get NAME() {
          throw new Error('You have to implement the static method "NAME", for each component!')
      }
      _getConfig(config) {
          config = this._mergeConfigObj(config);
          config = this._configAfterMerge(config);
          this._typeCheckConfig(config);
          return config
      }
      _configAfterMerge(config) {
          return config
      }
      _mergeConfigObj(config, element) {
          const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, "config") : {};
          return {
              ...this.constructor.Default,
              ...typeof jsonConfig === "object" ? jsonConfig : {},
              ...isElement$1(element) ? Manipulator.getDataAttributes(element) : {},
              ...typeof config === "object" ? config : {}
          }
      }
      _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
          for (const [property, expectedTypes] of Object.entries(configTypes)) {
              const value = config[property];
              const valueType = isElement$1(value) ? "element" : toType(value);
              if (!new RegExp(expectedTypes).test(valueType)) {
                  throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`)
              }
          }
      }
  }
  const VERSION = "5.3.2";
  class BaseComponent extends Config {
      constructor(element, config) {
          super();
          element = getElement(element);
          if (!element) {
              return
          }
          this._element = element;
          this._config = this._getConfig(config);
          Data.set(this._element, this.constructor.DATA_KEY, this)
      }
      dispose() {
          Data.remove(this._element, this.constructor.DATA_KEY);
          EventHandler.off(this._element, this.constructor.EVENT_KEY);
          for (const propertyName of Object.getOwnPropertyNames(this)) {
              this[propertyName] = null
          }
      }
      _queueCallback(callback, element, isAnimated = true) {
          executeAfterTransition(callback, element, isAnimated)
      }
      _getConfig(config) {
          config = this._mergeConfigObj(config, this._element);
          config = this._configAfterMerge(config);
          this._typeCheckConfig(config);
          return config
      }
      static getInstance(element) {
          return Data.get(getElement(element), this.DATA_KEY)
      }
      static getOrCreateInstance(element, config = {}) {
          return this.getInstance(element) || new this(element, typeof config === "object" ? config : null)
      }
      static get VERSION() {
          return VERSION
      }
      static get DATA_KEY() {
          return `bs.${this.NAME}`
      }
      static get EVENT_KEY() {
          return `.${this.DATA_KEY}`
      }
      static eventName(name) {
          return `${name}${this.EVENT_KEY}`
      }
  }
  const getSelector = element => {
      let selector = element.getAttribute("data-bs-target");
      if (!selector || selector === "#") {
          let hrefAttribute = element.getAttribute("href");
          if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
              return null
          }
          if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
              hrefAttribute = `#${hrefAttribute.split("#")[1]}`
          }
          selector = hrefAttribute && hrefAttribute !== "#" ? parseSelector(hrefAttribute.trim()) : null
      }
      return selector
  };
  const SelectorEngine = {
      find(selector, element = document.documentElement) {
          return [].concat(...Element.prototype.querySelectorAll.call(element, selector))
      },
      findOne(selector, element = document.documentElement) {
          return Element.prototype.querySelector.call(element, selector)
      },
      children(element, selector) {
          return [].concat(...element.children).filter(child => child.matches(selector))
      },
      parents(element, selector) {
          const parents = [];
          let ancestor = element.parentNode.closest(selector);
          while (ancestor) {
              parents.push(ancestor);
              ancestor = ancestor.parentNode.closest(selector)
          }
          return parents
      },
      prev(element, selector) {
          let previous = element.previousElementSibling;
          while (previous) {
              if (previous.matches(selector)) {
                  return [previous]
              }
              previous = previous.previousElementSibling
          }
          return []
      },
      next(element, selector) {
          let next = element.nextElementSibling;
          while (next) {
              if (next.matches(selector)) {
                  return [next]
              }
              next = next.nextElementSibling
          }
          return []
      },
      focusableChildren(element) {
          const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(",");
          return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el))
      },
      getSelectorFromElement(element) {
          const selector = getSelector(element);
          if (selector) {
              return SelectorEngine.findOne(selector) ? selector : null
          }
          return null
      },
      getElementFromSelector(element) {
          const selector = getSelector(element);
          return selector ? SelectorEngine.findOne(selector) : null
      },
      getMultipleElementsFromSelector(element) {
          const selector = getSelector(element);
          return selector ? SelectorEngine.find(selector) : []
      }
  };
  const enableDismissTrigger = (component, method = "hide") => {
      const clickEvent = `click.dismiss${component.EVENT_KEY}`;
      const name = component.NAME;
      EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
          if (["A", "AREA"].includes(this.tagName)) {
              event.preventDefault()
          }
          if (isDisabled(this)) {
              return
          }
          const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
          const instance = component.getOrCreateInstance(target);
          instance[method]()
      })
  };
  const NAME$f = "alert";
  const DATA_KEY$a = "bs.alert";
  const EVENT_KEY$b = `.${DATA_KEY$a}`;
  const EVENT_CLOSE = `close${EVENT_KEY$b}`;
  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  const CLASS_NAME_FADE$5 = "fade";
  const CLASS_NAME_SHOW$8 = "show";
  class Alert extends BaseComponent {
      static get NAME() {
          return NAME$f
      }
      close() {
          const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
          if (closeEvent.defaultPrevented) {
              return
          }
          this._element.classList.remove(CLASS_NAME_SHOW$8);
          const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
          this._queueCallback(() => this._destroyElement(), this._element, isAnimated)
      }
      _destroyElement() {
          this._element.remove();
          EventHandler.trigger(this._element, EVENT_CLOSED);
          this.dispose()
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Alert.getOrCreateInstance(this);
              if (typeof config !== "string") {
                  return
              }
              if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config](this)
          })
      }
  }
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  const NAME$e = "button";
  const DATA_KEY$9 = "bs.button";
  const EVENT_KEY$a = `.${DATA_KEY$9}`;
  const DATA_API_KEY$6 = ".data-api";
  const CLASS_NAME_ACTIVE$3 = "active";
  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  class Button extends BaseComponent {
      static get NAME() {
          return NAME$e
      }
      toggle() {
          this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3))
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Button.getOrCreateInstance(this);
              if (config === "toggle") {
                  data[config]()
              }
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
      event.preventDefault();
      const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
      const data = Button.getOrCreateInstance(button);
      data.toggle()
  });
  defineJQueryPlugin(Button);
  const NAME$d = "swipe";
  const EVENT_KEY$9 = ".bs.swipe";
  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  const POINTER_TYPE_TOUCH = "touch";
  const POINTER_TYPE_PEN = "pen";
  const CLASS_NAME_POINTER_EVENT = "pointer-event";
  const SWIPE_THRESHOLD = 40;
  const Default$c = {
      endCallback: null,
      leftCallback: null,
      rightCallback: null
  };
  const DefaultType$c = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)"
  };
  class Swipe extends Config {
      constructor(element, config) {
          super();
          this._element = element;
          if (!element || !Swipe.isSupported()) {
              return
          }
          this._config = this._getConfig(config);
          this._deltaX = 0;
          this._supportPointerEvents = Boolean(window.PointerEvent);
          this._initEvents()
      }
      static get Default() {
          return Default$c
      }
      static get DefaultType() {
          return DefaultType$c
      }
      static get NAME() {
          return NAME$d
      }
      dispose() {
          EventHandler.off(this._element, EVENT_KEY$9)
      }
      _start(event) {
          if (!this._supportPointerEvents) {
              this._deltaX = event.touches[0].clientX;
              return
          }
          if (this._eventIsPointerPenTouch(event)) {
              this._deltaX = event.clientX
          }
      }
      _end(event) {
          if (this._eventIsPointerPenTouch(event)) {
              this._deltaX = event.clientX - this._deltaX
          }
          this._handleSwipe();
          execute(this._config.endCallback)
      }
      _move(event) {
          this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX
      }
      _handleSwipe() {
          const absDeltaX = Math.abs(this._deltaX);
          if (absDeltaX <= SWIPE_THRESHOLD) {
              return
          }
          const direction = absDeltaX / this._deltaX;
          this._deltaX = 0;
          if (!direction) {
              return
          }
          execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback)
      }
      _initEvents() {
          if (this._supportPointerEvents) {
              EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
              EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
              this._element.classList.add(CLASS_NAME_POINTER_EVENT)
          } else {
              EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
              EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
              EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event))
          }
      }
      _eventIsPointerPenTouch(event) {
          return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)
      }
      static isSupported() {
          return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
      }
  }
  const NAME$c = "carousel";
  const DATA_KEY$8 = "bs.carousel";
  const EVENT_KEY$8 = `.${DATA_KEY$8}`;
  const DATA_API_KEY$5 = ".data-api";
  const ARROW_LEFT_KEY$1 = "ArrowLeft";
  const ARROW_RIGHT_KEY$1 = "ArrowRight";
  const TOUCHEVENT_COMPAT_WAIT = 500;
  const ORDER_NEXT = "next";
  const ORDER_PREV = "prev";
  const DIRECTION_LEFT = "left";
  const DIRECTION_RIGHT = "right";
  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  const EVENT_SLID = `slid${EVENT_KEY$8}`;
  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const CLASS_NAME_CAROUSEL = "carousel";
  const CLASS_NAME_ACTIVE$2 = "active";
  const CLASS_NAME_SLIDE = "slide";
  const CLASS_NAME_END = "carousel-item-end";
  const CLASS_NAME_START = "carousel-item-start";
  const CLASS_NAME_NEXT = "carousel-item-next";
  const CLASS_NAME_PREV = "carousel-item-prev";
  const SELECTOR_ACTIVE = ".active";
  const SELECTOR_ITEM = ".carousel-item";
  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  const SELECTOR_ITEM_IMG = ".carousel-item img";
  const SELECTOR_INDICATORS = ".carousel-indicators";
  const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  const KEY_TO_DIRECTION = {
      [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
      [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  const Default$b = {
      interval: 5e3,
      keyboard: true,
      pause: "hover",
      ride: false,
      touch: true,
      wrap: true
  };
  const DefaultType$b = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean"
  };
  class Carousel extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._interval = null;
          this._activeElement = null;
          this._isSliding = false;
          this.touchTimeout = null;
          this._swipeHelper = null;
          this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
          this._addEventListeners();
          if (this._config.ride === CLASS_NAME_CAROUSEL) {
              this.cycle()
          }
      }
      static get Default() {
          return Default$b
      }
      static get DefaultType() {
          return DefaultType$b
      }
      static get NAME() {
          return NAME$c
      }
      next() {
          this._slide(ORDER_NEXT)
      }
      nextWhenVisible() {
          if (!document.hidden && isVisible(this._element)) {
              this.next()
          }
      }
      prev() {
          this._slide(ORDER_PREV)
      }
      pause() {
          if (this._isSliding) {
              triggerTransitionEnd(this._element)
          }
          this._clearInterval()
      }
      cycle() {
          this._clearInterval();
          this._updateInterval();
          this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval)
      }
      _maybeEnableCycle() {
          if (!this._config.ride) {
              return
          }
          if (this._isSliding) {
              EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
              return
          }
          this.cycle()
      }
      to(index) {
          const items = this._getItems();
          if (index > items.length - 1 || index < 0) {
              return
          }
          if (this._isSliding) {
              EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
              return
          }
          const activeIndex = this._getItemIndex(this._getActive());
          if (activeIndex === index) {
              return
          }
          const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
          this._slide(order, items[index])
      }
      dispose() {
          if (this._swipeHelper) {
              this._swipeHelper.dispose()
          }
          super.dispose()
      }
      _configAfterMerge(config) {
          config.defaultInterval = config.interval;
          return config
      }
      _addEventListeners() {
          if (this._config.keyboard) {
              EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event))
          }
          if (this._config.pause === "hover") {
              EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
              EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle())
          }
          if (this._config.touch && Swipe.isSupported()) {
              this._addTouchEventListeners()
          }
      }
      _addTouchEventListeners() {
          for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
              EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault())
          }
          const endCallBack = () => {
              if (this._config.pause !== "hover") {
                  return
              }
              this.pause();
              if (this.touchTimeout) {
                  clearTimeout(this.touchTimeout)
              }
              this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval)
          };
          const swipeConfig = {
              leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
              rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
              endCallback: endCallBack
          };
          this._swipeHelper = new Swipe(this._element, swipeConfig)
      }
      _keydown(event) {
          if (/input|textarea/i.test(event.target.tagName)) {
              return
          }
          const direction = KEY_TO_DIRECTION[event.key];
          if (direction) {
              event.preventDefault();
              this._slide(this._directionToOrder(direction))
          }
      }
      _getItemIndex(element) {
          return this._getItems().indexOf(element)
      }
      _setActiveIndicatorElement(index) {
          if (!this._indicatorsElement) {
              return
          }
          const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
          activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
          activeIndicator.removeAttribute("aria-current");
          const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
          if (newActiveIndicator) {
              newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
              newActiveIndicator.setAttribute("aria-current", "true")
          }
      }
      _updateInterval() {
          const element = this._activeElement || this._getActive();
          if (!element) {
              return
          }
          const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
          this._config.interval = elementInterval || this._config.defaultInterval
      }
      _slide(order, element = null) {
          if (this._isSliding) {
              return
          }
          const activeElement = this._getActive();
          const isNext = order === ORDER_NEXT;
          const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
          if (nextElement === activeElement) {
              return
          }
          const nextElementIndex = this._getItemIndex(nextElement);
          const triggerEvent = eventName => {
              return EventHandler.trigger(this._element, eventName, {
                  relatedTarget: nextElement,
                  direction: this._orderToDirection(order),
                  from: this._getItemIndex(activeElement),
                  to: nextElementIndex
              })
          };
          const slideEvent = triggerEvent(EVENT_SLIDE);
          if (slideEvent.defaultPrevented) {
              return
          }
          if (!activeElement || !nextElement) {
              return
          }
          const isCycling = Boolean(this._interval);
          this.pause();
          this._isSliding = true;
          this._setActiveIndicatorElement(nextElementIndex);
          this._activeElement = nextElement;
          const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
          const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
          nextElement.classList.add(orderClassName);
          reflow(nextElement);
          activeElement.classList.add(directionalClassName);
          nextElement.classList.add(directionalClassName);
          const completeCallBack = () => {
              nextElement.classList.remove(directionalClassName, orderClassName);
              nextElement.classList.add(CLASS_NAME_ACTIVE$2);
              activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
              this._isSliding = false;
              triggerEvent(EVENT_SLID)
          };
          this._queueCallback(completeCallBack, activeElement, this._isAnimated());
          if (isCycling) {
              this.cycle()
          }
      }
      _isAnimated() {
          return this._element.classList.contains(CLASS_NAME_SLIDE)
      }
      _getActive() {
          return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element)
      }
      _getItems() {
          return SelectorEngine.find(SELECTOR_ITEM, this._element)
      }
      _clearInterval() {
          if (this._interval) {
              clearInterval(this._interval);
              this._interval = null
          }
      }
      _directionToOrder(direction) {
          if (isRTL()) {
              return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT
          }
          return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV
      }
      _orderToDirection(order) {
          if (isRTL()) {
              return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT
          }
          return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Carousel.getOrCreateInstance(this, config);
              if (typeof config === "number") {
                  data.to(config);
                  return
              }
              if (typeof config === "string") {
                  if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                      throw new TypeError(`No method named "${config}"`)
                  }
                  data[config]()
              }
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
          return
      }
      event.preventDefault();
      const carousel = Carousel.getOrCreateInstance(target);
      const slideIndex = this.getAttribute("data-bs-slide-to");
      if (slideIndex) {
          carousel.to(slideIndex);
          carousel._maybeEnableCycle();
          return
      }
      if (Manipulator.getDataAttribute(this, "slide") === "next") {
          carousel.next();
          carousel._maybeEnableCycle();
          return
      }
      carousel.prev();
      carousel._maybeEnableCycle()
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
      const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
      for (const carousel of carousels) {
          Carousel.getOrCreateInstance(carousel)
      }
  });
  defineJQueryPlugin(Carousel);
  const NAME$b = "collapse";
  const DATA_KEY$7 = "bs.collapse";
  const EVENT_KEY$7 = `.${DATA_KEY$7}`;
  const DATA_API_KEY$4 = ".data-api";
  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  const CLASS_NAME_SHOW$7 = "show";
  const CLASS_NAME_COLLAPSE = "collapse";
  const CLASS_NAME_COLLAPSING = "collapsing";
  const CLASS_NAME_COLLAPSED = "collapsed";
  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  const WIDTH = "width";
  const HEIGHT = "height";
  const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  const Default$a = {
      parent: null,
      toggle: true
  };
  const DefaultType$a = {
      parent: "(null|element)",
      toggle: "boolean"
  };
  class Collapse extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._isTransitioning = false;
          this._triggerArray = [];
          const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
          for (const elem of toggleList) {
              const selector = SelectorEngine.getSelectorFromElement(elem);
              const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
              if (selector !== null && filterElement.length) {
                  this._triggerArray.push(elem)
              }
          }
          this._initializeChildren();
          if (!this._config.parent) {
              this._addAriaAndCollapsedClass(this._triggerArray, this._isShown())
          }
          if (this._config.toggle) {
              this.toggle()
          }
      }
      static get Default() {
          return Default$a
      }
      static get DefaultType() {
          return DefaultType$a
      }
      static get NAME() {
          return NAME$b
      }
      toggle() {
          if (this._isShown()) {
              this.hide()
          } else {
              this.show()
          }
      }
      show() {
          if (this._isTransitioning || this._isShown()) {
              return
          }
          let activeChildren = [];
          if (this._config.parent) {
              activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
                  toggle: false
              }))
          }
          if (activeChildren.length && activeChildren[0]._isTransitioning) {
              return
          }
          const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
          if (startEvent.defaultPrevented) {
              return
          }
          for (const activeInstance of activeChildren) {
              activeInstance.hide()
          }
          const dimension = this._getDimension();
          this._element.classList.remove(CLASS_NAME_COLLAPSE);
          this._element.classList.add(CLASS_NAME_COLLAPSING);
          this._element.style[dimension] = 0;
          this._addAriaAndCollapsedClass(this._triggerArray, true);
          this._isTransitioning = true;
          const complete = () => {
              this._isTransitioning = false;
              this._element.classList.remove(CLASS_NAME_COLLAPSING);
              this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
              this._element.style[dimension] = "";
              EventHandler.trigger(this._element, EVENT_SHOWN$6)
          };
          const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
          const scrollSize = `scroll${capitalizedDimension}`;
          this._queueCallback(complete, this._element, true);
          this._element.style[dimension] = `${this._element[scrollSize]}px`
      }
      hide() {
          if (this._isTransitioning || !this._isShown()) {
              return
          }
          const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
          if (startEvent.defaultPrevented) {
              return
          }
          const dimension = this._getDimension();
          this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
          reflow(this._element);
          this._element.classList.add(CLASS_NAME_COLLAPSING);
          this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
          for (const trigger of this._triggerArray) {
              const element = SelectorEngine.getElementFromSelector(trigger);
              if (element && !this._isShown(element)) {
                  this._addAriaAndCollapsedClass([trigger], false)
              }
          }
          this._isTransitioning = true;
          const complete = () => {
              this._isTransitioning = false;
              this._element.classList.remove(CLASS_NAME_COLLAPSING);
              this._element.classList.add(CLASS_NAME_COLLAPSE);
              EventHandler.trigger(this._element, EVENT_HIDDEN$6)
          };
          this._element.style[dimension] = "";
          this._queueCallback(complete, this._element, true)
      }
      _isShown(element = this._element) {
          return element.classList.contains(CLASS_NAME_SHOW$7)
      }
      _configAfterMerge(config) {
          config.toggle = Boolean(config.toggle);
          config.parent = getElement(config.parent);
          return config
      }
      _getDimension() {
          return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT
      }
      _initializeChildren() {
          if (!this._config.parent) {
              return
          }
          const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
          for (const element of children) {
              const selected = SelectorEngine.getElementFromSelector(element);
              if (selected) {
                  this._addAriaAndCollapsedClass([element], this._isShown(selected))
              }
          }
      }
      _getFirstLevelChildren(selector) {
          const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
          return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element))
      }
      _addAriaAndCollapsedClass(triggerArray, isOpen) {
          if (!triggerArray.length) {
              return
          }
          for (const element of triggerArray) {
              element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
              element.setAttribute("aria-expanded", isOpen)
          }
      }
      static jQueryInterface(config) {
          const _config = {};
          if (typeof config === "string" && /show|hide/.test(config)) {
              _config.toggle = false
          }
          return this.each(function() {
              const data = Collapse.getOrCreateInstance(this, _config);
              if (typeof config === "string") {
                  if (typeof data[config] === "undefined") {
                      throw new TypeError(`No method named "${config}"`)
                  }
                  data[config]()
              }
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
      if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
          event.preventDefault()
      }
      for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
          Collapse.getOrCreateInstance(element, {
              toggle: false
          }).toggle()
      }
  });
  defineJQueryPlugin(Collapse);
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end])
  }, []);
  var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end])
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null
  }

  function getWindow(node) {
      if (node == null) {
          return window
      }
      if (node.toString() !== "[object Window]") {
          var ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window
      }
      return node
  }

  function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element
  }

  function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement
  }

  function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
          return false
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot
  }

  function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
          var style = state.styles[name] || {};
          var attributes = state.attributes[name] || {};
          var element = state.elements[name];
          if (!isHTMLElement(element) || !getNodeName(element)) {
              return
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(name) {
              var value = attributes[name];
              if (value === false) {
                  element.removeAttribute(name)
              } else {
                  element.setAttribute(name, value === true ? "" : value)
              }
          })
      })
  }

  function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
          popper: {
              position: state.options.strategy,
              left: "0",
              top: "0",
              margin: "0"
          },
          arrow: {
              position: "absolute"
          },
          reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow)
      }
      return function() {
          Object.keys(state.elements).forEach(function(name) {
              var element = state.elements[name];
              var attributes = state.attributes[name] || {};
              var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
              var style = styleProperties.reduce(function(style, property) {
                  style[property] = "";
                  return style
              }, {});
              if (!isHTMLElement(element) || !getNodeName(element)) {
                  return
              }
              Object.assign(element.style, style);
              Object.keys(attributes).forEach(function(attribute) {
                  element.removeAttribute(attribute)
              })
          })
      }
  }
  const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
  };

  function getBasePlacement(placement) {
      return placement.split("-")[0]
  }
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
          return uaData.brands.map(function(item) {
              return item.brand + "/" + item.version
          }).join(" ")
      }
      return navigator.userAgent
  }

  function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString())
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
          includeScale = false
      }
      if (isFixedStrategy === void 0) {
          isFixedStrategy = false
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
          scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
          scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1
      }
      var _ref = isElement(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
          width: width,
          height: height,
          top: y,
          right: x + width,
          bottom: y + height,
          left: x,
          x: x,
          y: y
      }
  }

  function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
          width = clientRect.width
      }
      if (Math.abs(clientRect.height - height) <= 1) {
          height = clientRect.height
      }
      return {
          x: element.offsetLeft,
          y: element.offsetTop,
          width: width,
          height: height
      }
  }

  function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
          return true
      } else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;
          do {
              if (next && parent.isSameNode(next)) {
                  return true
              }
              next = next.parentNode || next.host
          } while (next)
      }
      return false
  }

  function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element)
  }

  function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0
  }

  function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement
  }

  function getParentNode(element) {
      if (getNodeName(element) === "html") {
          return element
      }
      return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element)
  }

  function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
          return null
      }
      return element.offsetParent
  }

  function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
          var elementCss = getComputedStyle$1(element);
          if (elementCss.position === "fixed") {
              return null
          }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
          currentNode = currentNode.host
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
          var css = getComputedStyle$1(currentNode);
          if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
              return currentNode
          } else {
              currentNode = currentNode.parentNode
          }
      }
      return null
  }

  function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent)
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
          return window
      }
      return offsetParent || getContainingBlock(element) || window
  }

  function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y"
  }

  function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1))
  }

  function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v
  }

  function getFreshSideObject() {
      return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
      }
  }

  function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject)
  }

  function expandToHashMap(value, keys) {
      return keys.reduce(function(hashMap, key) {
          hashMap[key] = value;
          return hashMap
      }, {})
  }
  var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
          placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements))
  };

  function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets) {
          return
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$)
  }

  function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
          return
      }
      if (typeof arrowElement === "string") {
          arrowElement = state.elements.popper.querySelector(arrowElement);
          if (!arrowElement) {
              return
          }
      }
      if (!contains(state.elements.popper, arrowElement)) {
          return
      }
      state.elements.arrow = arrowElement
  }
  const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
  };

  function getVariation(placement) {
      return placement.split("-")[1]
  }
  var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
  };

  function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x,
          y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
          x: round(x * dpr) / dpr || 0,
          y: round(y * dpr) / dpr || 0
      }
  }

  function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
          x: x,
          y: y
      }) : {
          x: x,
          y: y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
          var offsetParent = getOffsetParent(popper);
          var heightProp = "clientHeight";
          var widthProp = "clientWidth";
          if (offsetParent === getWindow(popper)) {
              offsetParent = getDocumentElement(popper);
              if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
                  heightProp = "scrollHeight";
                  widthProp = "scrollWidth"
              }
          }
          offsetParent = offsetParent;
          if (placement === top || (placement === left || placement === right) && variation === end) {
              sideY = bottom;
              var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
              y -= offsetY - popperRect.height;
              y *= gpuAcceleration ? 1 : -1
          }
          if (placement === left || (placement === top || placement === bottom) && variation === end) {
              sideX = right;
              var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
              x -= offsetX - popperRect.width;
              x *= gpuAcceleration ? 1 : -1
          }
      }
      var commonStyles = Object.assign({
          position: position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
          x: x,
          y: y
      }, getWindow(popper)) : {
          x: x,
          y: y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
          var _Object$assign;
          return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign))
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2))
  }

  function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
          placement: getBasePlacement(state.placement),
          variation: getVariation(state.placement),
          popper: state.elements.popper,
          popperRect: state.rects.popper,
          gpuAcceleration: gpuAcceleration,
          isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
          state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.popperOffsets,
              position: state.options.strategy,
              adaptive: adaptive,
              roundOffsets: roundOffsets
          })))
      }
      if (state.modifiersData.arrow != null) {
          state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
              offsets: state.modifiersData.arrow,
              position: "absolute",
              adaptive: false,
              roundOffsets: roundOffsets
          })))
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-placement": state.placement
      })
  }
  const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
  };
  var passive = {
      passive: true
  };

  function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
          scrollParents.forEach(function(scrollParent) {
              scrollParent.addEventListener("scroll", instance.update, passive)
          })
      }
      if (resize) {
          window.addEventListener("resize", instance.update, passive)
      }
      return function() {
          if (scroll) {
              scrollParents.forEach(function(scrollParent) {
                  scrollParent.removeEventListener("scroll", instance.update, passive)
              })
          }
          if (resize) {
              window.removeEventListener("resize", instance.update, passive)
          }
      }
  }
  const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {},
      effect: effect,
      data: {}
  };
  var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
  };

  function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
          return hash$1[matched]
      })
  }
  var hash = {
      start: "end",
      end: "start"
  };

  function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
          return hash[matched]
      })
  }

  function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
          scrollLeft: scrollLeft,
          scrollTop: scrollTop
      }
  }

  function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft
  }

  function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          var layoutViewport = isLayoutViewport();
          if (layoutViewport || !layoutViewport && strategy === "fixed") {
              x = visualViewport.offsetLeft;
              y = visualViewport.offsetTop
          }
      }
      return {
          width: width,
          height: height,
          x: x + getWindowScrollBarX(element),
          y: y
      }
  }

  function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
          x += max(html.clientWidth, body ? body.clientWidth : 0) - width
      }
      return {
          width: width,
          height: height,
          x: x,
          y: y
      }
  }

  function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)
  }

  function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
          return node.ownerDocument.body
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
          return node
      }
      return getScrollParent(getParentNode(node))
  }

  function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
          list = []
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)))
  }

  function rectToClientRect(rect) {
      return Object.assign({}, rect, {
          left: rect.x,
          top: rect.y,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
      })
  }

  function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)))
  }

  function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
          return []
      }
      return clippingParents.filter(function(clippingParent) {
          return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body"
      })
  }

  function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
          var rect = getClientRectFromMixedType(element, clippingParent, strategy);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect
  }

  function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
          case top:
              offsets = {
                  x: commonX,
                  y: reference.y - element.height
              };
              break;
          case bottom:
              offsets = {
                  x: commonX,
                  y: reference.y + reference.height
              };
              break;
          case right:
              offsets = {
                  x: reference.x + reference.width,
                  y: commonY
              };
              break;
          case left:
              offsets = {
                  x: reference.x - element.width,
                  y: commonY
              };
              break;
          default:
              offsets = {
                  x: reference.x,
                  y: reference.y
              }
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
          var len = mainAxis === "y" ? "height" : "width";
          switch (variation) {
              case start:
                  offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                  break;
              case end:
                  offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                  break
          }
      }
      return offsets
  }

  function detectOverflow(state, options) {
      if (options === void 0) {
          options = {}
      }
      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
          reference: referenceClientRect,
          element: popperRect,
          strategy: "absolute",
          placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
          var offset = offsetData[placement];
          Object.keys(overflowOffsets).forEach(function(key) {
              var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
              var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
              overflowOffsets[key] += offset[axis] * multiply
          })
      }
      return overflowOffsets
  }

  function computeAutoPlacement(state, options) {
      if (options === void 0) {
          options = {}
      }
      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {
          return getVariation(placement) === variation
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement) {
          return allowedAutoPlacements.indexOf(placement) >= 0
      });
      if (allowedPlacements.length === 0) {
          allowedPlacements = placements$1
      }
      var overflows = allowedPlacements.reduce(function(acc, placement) {
          acc[placement] = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding
          })[getBasePlacement(placement)];
          return acc
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
          return overflows[a] - overflows[b]
      })
  }

  function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
          return []
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)]
  }

  function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      if (state.modifiersData[name]._skip) {
          return
      }
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement) {
          return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              padding: padding,
              flipVariations: flipVariations,
              allowedAutoPlacements: allowedAutoPlacements
          }) : placement)
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map;
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];
      for (var i = 0; i < placements.length; i++) {
          var placement = placements[i];
          var _basePlacement = getBasePlacement(placement);
          var isStartVariation = getVariation(placement) === start;
          var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
          var len = isVertical ? "width" : "height";
          var overflow = detectOverflow(state, {
              placement: placement,
              boundary: boundary,
              rootBoundary: rootBoundary,
              altBoundary: altBoundary,
              padding: padding
          });
          var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
          if (referenceRect[len] > popperRect[len]) {
              mainVariationSide = getOppositePlacement(mainVariationSide)
          }
          var altVariationSide = getOppositePlacement(mainVariationSide);
          var checks = [];
          if (checkMainAxis) {
              checks.push(overflow[_basePlacement] <= 0)
          }
          if (checkAltAxis) {
              checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0)
          }
          if (checks.every(function(check) {
                  return check
              })) {
              firstFittingPlacement = placement;
              makeFallbackChecks = false;
              break
          }
          checksMap.set(placement, checks)
      }
      if (makeFallbackChecks) {
          var numberOfChecks = flipVariations ? 3 : 1;
          var _loop = function _loop(_i) {
              var fittingPlacement = placements.find(function(placement) {
                  var checks = checksMap.get(placement);
                  if (checks) {
                      return checks.slice(0, _i).every(function(check) {
                          return check
                      })
                  }
              });
              if (fittingPlacement) {
                  firstFittingPlacement = fittingPlacement;
                  return "break"
              }
          };
          for (var _i = numberOfChecks; _i > 0; _i--) {
              var _ret = _loop(_i);
              if (_ret === "break") break
          }
      }
      if (state.placement !== firstFittingPlacement) {
          state.modifiersData[name]._skip = true;
          state.placement = firstFittingPlacement;
          state.reset = true
      }
  }
  const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
          _skip: false
      }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
          preventedOffsets = {
              x: 0,
              y: 0
          }
      }
      return {
          top: overflow.top - rect.height - preventedOffsets.y,
          right: overflow.right - rect.width + preventedOffsets.x,
          bottom: overflow.bottom - rect.height + preventedOffsets.y,
          left: overflow.left - rect.width - preventedOffsets.x
      }
  }

  function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
          return overflow[side] >= 0
      })
  }

  function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
          elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
          altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
          referenceClippingOffsets: referenceClippingOffsets,
          popperEscapeOffsets: popperEscapeOffsets,
          isReferenceHidden: isReferenceHidden,
          hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
          "data-popper-reference-hidden": isReferenceHidden,
          "data-popper-escaped": hasPopperEscaped
      })
  }
  const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
              placement: placement
          })) : offset,
          skidding = _ref[0],
          distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
          x: distance,
          y: skidding
      } : {
          x: skidding,
          y: distance
      }
  }

  function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
          acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
          return acc
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
          state.modifiersData.popperOffsets.x += x;
          state.modifiersData.popperOffsets.y += y
      }
      state.modifiersData[name] = data
  }
  const offset$1 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset
  };

  function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      state.modifiersData[name] = computeOffsets({
          reference: state.rects.reference,
          element: state.rects.popper,
          strategy: "absolute",
          placement: state.placement
      })
  }
  const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
  };

  function getAltAxis(axis) {
      return axis === "x" ? "y" : "x"
  }

  function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
          placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
          mainAxis: tetherOffsetValue,
          altAxis: tetherOffsetValue
      } : Object.assign({
          mainAxis: 0,
          altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
          x: 0,
          y: 0
      };
      if (!popperOffsets) {
          return
      }
      if (checkMainAxis) {
          var _offsetModifierState$;
          var mainSide = mainAxis === "y" ? top : left;
          var altSide = mainAxis === "y" ? bottom : right;
          var len = mainAxis === "y" ? "height" : "width";
          var offset = popperOffsets[mainAxis];
          var min$1 = offset + overflow[mainSide];
          var max$1 = offset - overflow[altSide];
          var additive = tether ? -popperRect[len] / 2 : 0;
          var minLen = variation === start ? referenceRect[len] : popperRect[len];
          var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
          var arrowElement = state.elements.arrow;
          var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
              width: 0,
              height: 0
          };
          var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
          var arrowPaddingMin = arrowPaddingObject[mainSide];
          var arrowPaddingMax = arrowPaddingObject[altSide];
          var arrowLen = within(0, referenceRect[len], arrowRect[len]);
          var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
          var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
          var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
          var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
          var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
          var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
          var tetherMax = offset + maxOffset - offsetModifierValue;
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset
      }
      if (checkAltAxis) {
          var _offsetModifierState$2;
          var _mainSide = mainAxis === "x" ? top : left;
          var _altSide = mainAxis === "x" ? bottom : right;
          var _offset = popperOffsets[altAxis];
          var _len = altAxis === "y" ? "height" : "width";
          var _min = _offset + overflow[_mainSide];
          var _max = _offset - overflow[_altSide];
          var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
          var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
          var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
          var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
          var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset
      }
      state.modifiersData[name] = data
  }
  const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
  };

  function getHTMLElementScroll(element) {
      return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
      }
  }

  function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
          return getWindowScroll(node)
      } else {
          return getHTMLElementScroll(node)
      }
  }

  function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1
  }

  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
          isFixed = false
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
          scrollLeft: 0,
          scrollTop: 0
      };
      var offsets = {
          x: 0,
          y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
              scroll = getNodeScroll(offsetParent)
          }
          if (isHTMLElement(offsetParent)) {
              offsets = getBoundingClientRect(offsetParent, true);
              offsets.x += offsetParent.clientLeft;
              offsets.y += offsetParent.clientTop
          } else if (documentElement) {
              offsets.x = getWindowScrollBarX(documentElement)
          }
      }
      return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
      }
  }

  function order(modifiers) {
      var map = new Map;
      var visited = new Set;
      var result = [];
      modifiers.forEach(function(modifier) {
          map.set(modifier.name, modifier)
      });

      function sort(modifier) {
          visited.add(modifier.name);
          var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
          requires.forEach(function(dep) {
              if (!visited.has(dep)) {
                  var depModifier = map.get(dep);
                  if (depModifier) {
                      sort(depModifier)
                  }
              }
          });
          result.push(modifier)
      }
      modifiers.forEach(function(modifier) {
          if (!visited.has(modifier.name)) {
              sort(modifier)
          }
      });
      return result
  }

  function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
          return acc.concat(orderedModifiers.filter(function(modifier) {
              return modifier.phase === phase
          }))
      }, [])
  }

  function debounce(fn) {
      var pending;
      return function() {
          if (!pending) {
              pending = new Promise(function(resolve) {
                  Promise.resolve().then(function() {
                      pending = undefined;
                      resolve(fn())
                  })
              })
          }
          return pending
      }
  }

  function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged, current) {
          var existing = merged[current.name];
          merged[current.name] = existing ? Object.assign({}, existing, current, {
              options: Object.assign({}, existing.options, current.options),
              data: Object.assign({}, existing.data, current.data)
          }) : current;
          return merged
      }, {});
      return Object.keys(merged).map(function(key) {
          return merged[key]
      })
  }
  var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
  };

  function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key]
      }
      return !args.some(function(element) {
          return !(element && typeof element.getBoundingClientRect === "function")
      })
  }

  function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
          generatorOptions = {}
      }
      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
          if (options === void 0) {
              options = defaultOptions
          }
          var state = {
              placement: "bottom",
              orderedModifiers: [],
              options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
              modifiersData: {},
              elements: {
                  reference: reference,
                  popper: popper
              },
              attributes: {},
              styles: {}
          };
          var effectCleanupFns = [];
          var isDestroyed = false;
          var instance = {
              state: state,
              setOptions: function setOptions(setOptionsAction) {
                  var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                  cleanupModifierEffects();
                  state.options = Object.assign({}, defaultOptions, state.options, options);
                  state.scrollParents = {
                      reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                      popper: listScrollParents(popper)
                  };
                  var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
                  state.orderedModifiers = orderedModifiers.filter(function(m) {
                      return m.enabled
                  });
                  runModifierEffects();
                  return instance.update()
              },
              forceUpdate: function forceUpdate() {
                  if (isDestroyed) {
                      return
                  }
                  var _state$elements = state.elements,
                      reference = _state$elements.reference,
                      popper = _state$elements.popper;
                  if (!areValidElements(reference, popper)) {
                      return
                  }
                  state.rects = {
                      reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                      popper: getLayoutRect(popper)
                  };
                  state.reset = false;
                  state.placement = state.options.placement;
                  state.orderedModifiers.forEach(function(modifier) {
                      return state.modifiersData[modifier.name] = Object.assign({}, modifier.data)
                  });
                  for (var index = 0; index < state.orderedModifiers.length; index++) {
                      if (state.reset === true) {
                          state.reset = false;
                          index = -1;
                          continue
                      }
                      var _state$orderedModifie = state.orderedModifiers[index],
                          fn = _state$orderedModifie.fn,
                          _state$orderedModifie2 = _state$orderedModifie.options,
                          _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                          name = _state$orderedModifie.name;
                      if (typeof fn === "function") {
                          state = fn({
                              state: state,
                              options: _options,
                              name: name,
                              instance: instance
                          }) || state
                      }
                  }
              },
              update: debounce(function() {
                  return new Promise(function(resolve) {
                      instance.forceUpdate();
                      resolve(state)
                  })
              }),
              destroy: function destroy() {
                  cleanupModifierEffects();
                  isDestroyed = true
              }
          };
          if (!areValidElements(reference, popper)) {
              return instance
          }
          instance.setOptions(options).then(function(state) {
              if (!isDestroyed && options.onFirstUpdate) {
                  options.onFirstUpdate(state)
              }
          });

          function runModifierEffects() {
              state.orderedModifiers.forEach(function(_ref) {
                  var name = _ref.name,
                      _ref$options = _ref.options,
                      options = _ref$options === void 0 ? {} : _ref$options,
                      effect = _ref.effect;
                  if (typeof effect === "function") {
                      var cleanupFn = effect({
                          state: state,
                          name: name,
                          instance: instance,
                          options: options
                      });
                      var noopFn = function noopFn() {};
                      effectCleanupFns.push(cleanupFn || noopFn)
                  }
              })
          }

          function cleanupModifierEffects() {
              effectCleanupFns.forEach(function(fn) {
                  return fn()
              });
              effectCleanupFns = []
          }
          return instance
      }
  }
  var createPopper$2 = popperGenerator();
  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
  var createPopper$1 = popperGenerator({
      defaultModifiers: defaultModifiers$1
  });
  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = popperGenerator({
      defaultModifiers: defaultModifiers
  });
  const Popper = Object.freeze(Object.defineProperty({
      __proto__: null,
      afterMain: afterMain,
      afterRead: afterRead,
      afterWrite: afterWrite,
      applyStyles: applyStyles$1,
      arrow: arrow$1,
      auto: auto,
      basePlacements: basePlacements,
      beforeMain: beforeMain,
      beforeRead: beforeRead,
      beforeWrite: beforeWrite,
      bottom: bottom,
      clippingParents: clippingParents,
      computeStyles: computeStyles$1,
      createPopper: createPopper,
      createPopperBase: createPopper$2,
      createPopperLite: createPopper$1,
      detectOverflow: detectOverflow,
      end: end,
      eventListeners: eventListeners,
      flip: flip$1,
      hide: hide$1,
      left: left,
      main: main,
      modifierPhases: modifierPhases,
      offset: offset$1,
      placements: placements,
      popper: popper,
      popperGenerator: popperGenerator,
      popperOffsets: popperOffsets$1,
      preventOverflow: preventOverflow$1,
      read: read,
      reference: reference,
      right: right,
      start: start,
      top: top,
      variationPlacements: variationPlacements,
      viewport: viewport,
      write: write
  }, Symbol.toStringTag, {
      value: "Module"
  }));
  const NAME$a = "dropdown";
  const DATA_KEY$6 = "bs.dropdown";
  const EVENT_KEY$6 = `.${DATA_KEY$6}`;
  const DATA_API_KEY$3 = ".data-api";
  const ESCAPE_KEY$2 = "Escape";
  const TAB_KEY$1 = "Tab";
  const ARROW_UP_KEY$1 = "ArrowUp";
  const ARROW_DOWN_KEY$1 = "ArrowDown";
  const RIGHT_MOUSE_BUTTON = 2;
  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const CLASS_NAME_SHOW$6 = "show";
  const CLASS_NAME_DROPUP = "dropup";
  const CLASS_NAME_DROPEND = "dropend";
  const CLASS_NAME_DROPSTART = "dropstart";
  const CLASS_NAME_DROPUP_CENTER = "dropup-center";
  const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  const SELECTOR_MENU = ".dropdown-menu";
  const SELECTOR_NAVBAR = ".navbar";
  const SELECTOR_NAVBAR_NAV = ".navbar-nav";
  const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  const PLACEMENT_TOPCENTER = "top";
  const PLACEMENT_BOTTOMCENTER = "bottom";
  const Default$9 = {
      autoClose: true,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle"
  };
  const DefaultType$9 = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)"
  };
  class Dropdown extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._popper = null;
          this._parent = this._element.parentNode;
          this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
          this._inNavbar = this._detectNavbar()
      }
      static get Default() {
          return Default$9
      }
      static get DefaultType() {
          return DefaultType$9
      }
      static get NAME() {
          return NAME$a
      }
      toggle() {
          return this._isShown() ? this.hide() : this.show()
      }
      show() {
          if (isDisabled(this._element) || this._isShown()) {
              return
          }
          const relatedTarget = {
              relatedTarget: this._element
          };
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
          if (showEvent.defaultPrevented) {
              return
          }
          this._createPopper();
          if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
              for (const element of [].concat(...document.body.children)) {
                  EventHandler.on(element, "mouseover", noop)
              }
          }
          this._element.focus();
          this._element.setAttribute("aria-expanded", true);
          this._menu.classList.add(CLASS_NAME_SHOW$6);
          this._element.classList.add(CLASS_NAME_SHOW$6);
          EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget)
      }
      hide() {
          if (isDisabled(this._element) || !this._isShown()) {
              return
          }
          const relatedTarget = {
              relatedTarget: this._element
          };
          this._completeHide(relatedTarget)
      }
      dispose() {
          if (this._popper) {
              this._popper.destroy()
          }
          super.dispose()
      }
      update() {
          this._inNavbar = this._detectNavbar();
          if (this._popper) {
              this._popper.update()
          }
      }
      _completeHide(relatedTarget) {
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
          if (hideEvent.defaultPrevented) {
              return
          }
          if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                  EventHandler.off(element, "mouseover", noop)
              }
          }
          if (this._popper) {
              this._popper.destroy()
          }
          this._menu.classList.remove(CLASS_NAME_SHOW$6);
          this._element.classList.remove(CLASS_NAME_SHOW$6);
          this._element.setAttribute("aria-expanded", "false");
          Manipulator.removeDataAttribute(this._menu, "popper");
          EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget)
      }
      _getConfig(config) {
          config = super._getConfig(config);
          if (typeof config.reference === "object" && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
              throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`)
          }
          return config
      }
      _createPopper() {
          if (typeof Popper === "undefined") {
              throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)")
          }
          let referenceElement = this._element;
          if (this._config.reference === "parent") {
              referenceElement = this._parent
          } else if (isElement$1(this._config.reference)) {
              referenceElement = getElement(this._config.reference)
          } else if (typeof this._config.reference === "object") {
              referenceElement = this._config.reference
          }
          const popperConfig = this._getPopperConfig();
          this._popper = createPopper(referenceElement, this._menu, popperConfig)
      }
      _isShown() {
          return this._menu.classList.contains(CLASS_NAME_SHOW$6)
      }
      _getPlacement() {
          const parentDropdown = this._parent;
          if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
              return PLACEMENT_RIGHT
          }
          if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
              return PLACEMENT_LEFT
          }
          if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
              return PLACEMENT_TOPCENTER
          }
          if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
              return PLACEMENT_BOTTOMCENTER
          }
          const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
          if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
              return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP
          }
          return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM
      }
      _detectNavbar() {
          return this._element.closest(SELECTOR_NAVBAR) !== null
      }
      _getOffset() {
          const {
              offset
          } = this._config;
          if (typeof offset === "string") {
              return offset.split(",").map(value => Number.parseInt(value, 10))
          }
          if (typeof offset === "function") {
              return popperData => offset(popperData, this._element)
          }
          return offset
      }
      _getPopperConfig() {
          const defaultBsPopperConfig = {
              placement: this._getPlacement(),
              modifiers: [{
                  name: "preventOverflow",
                  options: {
                      boundary: this._config.boundary
                  }
              }, {
                  name: "offset",
                  options: {
                      offset: this._getOffset()
                  }
              }]
          };
          if (this._inNavbar || this._config.display === "static") {
              Manipulator.setDataAttribute(this._menu, "popper", "static");
              defaultBsPopperConfig.modifiers = [{
                  name: "applyStyles",
                  enabled: false
              }]
          }
          return {
              ...defaultBsPopperConfig,
              ...execute(this._config.popperConfig, [defaultBsPopperConfig])
          }
      }
      _selectMenuItem({
          key,
          target
      }) {
          const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
          if (!items.length) {
              return
          }
          getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus()
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Dropdown.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config]()
          })
      }
      static clearMenus(event) {
          if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
              return
          }
          const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
          for (const toggle of openToggles) {
              const context = Dropdown.getInstance(toggle);
              if (!context || context._config.autoClose === false) {
                  continue
              }
              const composedPath = event.composedPath();
              const isMenuTarget = composedPath.includes(context._menu);
              if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
                  continue
              }
              if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
                  continue
              }
              const relatedTarget = {
                  relatedTarget: context._element
              };
              if (event.type === "click") {
                  relatedTarget.clickEvent = event
              }
              context._completeHide(relatedTarget)
          }
      }
      static dataApiKeydownHandler(event) {
          const isInput = /input|textarea/i.test(event.target.tagName);
          const isEscapeEvent = event.key === ESCAPE_KEY$2;
          const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
          if (!isUpOrDownEvent && !isEscapeEvent) {
              return
          }
          if (isInput && !isEscapeEvent) {
              return
          }
          event.preventDefault();
          const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
          const instance = Dropdown.getOrCreateInstance(getToggleButton);
          if (isUpOrDownEvent) {
              event.stopPropagation();
              instance.show();
              instance._selectMenuItem(event);
              return
          }
          if (instance._isShown()) {
              event.stopPropagation();
              instance.hide();
              getToggleButton.focus()
          }
      }
  }
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
      event.preventDefault();
      Dropdown.getOrCreateInstance(this).toggle()
  });
  defineJQueryPlugin(Dropdown);
  const NAME$9 = "backdrop";
  const CLASS_NAME_FADE$4 = "fade";
  const CLASS_NAME_SHOW$5 = "show";
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  const Default$8 = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: false,
      isVisible: true,
      rootElement: "body"
  };
  const DefaultType$8 = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)"
  };
  class Backdrop extends Config {
      constructor(config) {
          super();
          this._config = this._getConfig(config);
          this._isAppended = false;
          this._element = null
      }
      static get Default() {
          return Default$8
      }
      static get DefaultType() {
          return DefaultType$8
      }
      static get NAME() {
          return NAME$9
      }
      show(callback) {
          if (!this._config.isVisible) {
              execute(callback);
              return
          }
          this._append();
          const element = this._getElement();
          if (this._config.isAnimated) {
              reflow(element)
          }
          element.classList.add(CLASS_NAME_SHOW$5);
          this._emulateAnimation(() => {
              execute(callback)
          })
      }
      hide(callback) {
          if (!this._config.isVisible) {
              execute(callback);
              return
          }
          this._getElement().classList.remove(CLASS_NAME_SHOW$5);
          this._emulateAnimation(() => {
              this.dispose();
              execute(callback)
          })
      }
      dispose() {
          if (!this._isAppended) {
              return
          }
          EventHandler.off(this._element, EVENT_MOUSEDOWN);
          this._element.remove();
          this._isAppended = false
      }
      _getElement() {
          if (!this._element) {
              const backdrop = document.createElement("div");
              backdrop.className = this._config.className;
              if (this._config.isAnimated) {
                  backdrop.classList.add(CLASS_NAME_FADE$4)
              }
              this._element = backdrop
          }
          return this._element
      }
      _configAfterMerge(config) {
          config.rootElement = getElement(config.rootElement);
          return config
      }
      _append() {
          if (this._isAppended) {
              return
          }
          const element = this._getElement();
          this._config.rootElement.append(element);
          EventHandler.on(element, EVENT_MOUSEDOWN, () => {
              execute(this._config.clickCallback)
          });
          this._isAppended = true
      }
      _emulateAnimation(callback) {
          executeAfterTransition(callback, this._getElement(), this._config.isAnimated)
      }
  }
  const NAME$8 = "focustrap";
  const DATA_KEY$5 = "bs.focustrap";
  const EVENT_KEY$5 = `.${DATA_KEY$5}`;
  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  const TAB_KEY = "Tab";
  const TAB_NAV_FORWARD = "forward";
  const TAB_NAV_BACKWARD = "backward";
  const Default$7 = {
      autofocus: true,
      trapElement: null
  };
  const DefaultType$7 = {
      autofocus: "boolean",
      trapElement: "element"
  };
  class FocusTrap extends Config {
      constructor(config) {
          super();
          this._config = this._getConfig(config);
          this._isActive = false;
          this._lastTabNavDirection = null
      }
      static get Default() {
          return Default$7
      }
      static get DefaultType() {
          return DefaultType$7
      }
      static get NAME() {
          return NAME$8
      }
      activate() {
          if (this._isActive) {
              return
          }
          if (this._config.autofocus) {
              this._config.trapElement.focus()
          }
          EventHandler.off(document, EVENT_KEY$5);
          EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
          EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
          this._isActive = true
      }
      deactivate() {
          if (!this._isActive) {
              return
          }
          this._isActive = false;
          EventHandler.off(document, EVENT_KEY$5)
      }
      _handleFocusin(event) {
          const {
              trapElement
          } = this._config;
          if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
              return
          }
          const elements = SelectorEngine.focusableChildren(trapElement);
          if (elements.length === 0) {
              trapElement.focus()
          } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
              elements[elements.length - 1].focus()
          } else {
              elements[0].focus()
          }
      }
      _handleKeydown(event) {
          if (event.key !== TAB_KEY) {
              return
          }
          this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD
      }
  }
  const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  const SELECTOR_STICKY_CONTENT = ".sticky-top";
  const PROPERTY_PADDING = "padding-right";
  const PROPERTY_MARGIN = "margin-right";
  class ScrollBarHelper {
      constructor() {
          this._element = document.body
      }
      getWidth() {
          const documentWidth = document.documentElement.clientWidth;
          return Math.abs(window.innerWidth - documentWidth)
      }
      hide() {
          const width = this.getWidth();
          this._disableOverFlow();
          this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
          this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
          this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width)
      }
      reset() {
          this._resetElementAttributes(this._element, "overflow");
          this._resetElementAttributes(this._element, PROPERTY_PADDING);
          this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
          this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN)
      }
      isOverflowing() {
          return this.getWidth() > 0
      }
      _disableOverFlow() {
          this._saveInitialAttribute(this._element, "overflow");
          this._element.style.overflow = "hidden"
      }
      _setElementAttributes(selector, styleProperty, callback) {
          const scrollbarWidth = this.getWidth();
          const manipulationCallBack = element => {
              if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
                  return
              }
              this._saveInitialAttribute(element, styleProperty);
              const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
              element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`)
          };
          this._applyManipulationCallback(selector, manipulationCallBack)
      }
      _saveInitialAttribute(element, styleProperty) {
          const actualValue = element.style.getPropertyValue(styleProperty);
          if (actualValue) {
              Manipulator.setDataAttribute(element, styleProperty, actualValue)
          }
      }
      _resetElementAttributes(selector, styleProperty) {
          const manipulationCallBack = element => {
              const value = Manipulator.getDataAttribute(element, styleProperty);
              if (value === null) {
                  element.style.removeProperty(styleProperty);
                  return
              }
              Manipulator.removeDataAttribute(element, styleProperty);
              element.style.setProperty(styleProperty, value)
          };
          this._applyManipulationCallback(selector, manipulationCallBack)
      }
      _applyManipulationCallback(selector, callBack) {
          if (isElement$1(selector)) {
              callBack(selector);
              return
          }
          for (const sel of SelectorEngine.find(selector, this._element)) {
              callBack(sel)
          }
      }
  }
  const NAME$7 = "modal";
  const DATA_KEY$4 = "bs.modal";
  const EVENT_KEY$4 = `.${DATA_KEY$4}`;
  const DATA_API_KEY$2 = ".data-api";
  const ESCAPE_KEY$1 = "Escape";
  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  const CLASS_NAME_OPEN = "modal-open";
  const CLASS_NAME_FADE$3 = "fade";
  const CLASS_NAME_SHOW$4 = "show";
  const CLASS_NAME_STATIC = "modal-static";
  const OPEN_SELECTOR$1 = ".modal.show";
  const SELECTOR_DIALOG = ".modal-dialog";
  const SELECTOR_MODAL_BODY = ".modal-body";
  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  const Default$6 = {
      backdrop: true,
      focus: true,
      keyboard: true
  };
  const DefaultType$6 = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean"
  };
  class Modal extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
          this._backdrop = this._initializeBackDrop();
          this._focustrap = this._initializeFocusTrap();
          this._isShown = false;
          this._isTransitioning = false;
          this._scrollBar = new ScrollBarHelper;
          this._addEventListeners()
      }
      static get Default() {
          return Default$6
      }
      static get DefaultType() {
          return DefaultType$6
      }
      static get NAME() {
          return NAME$7
      }
      toggle(relatedTarget) {
          return this._isShown ? this.hide() : this.show(relatedTarget)
      }
      show(relatedTarget) {
          if (this._isShown || this._isTransitioning) {
              return
          }
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
              relatedTarget: relatedTarget
          });
          if (showEvent.defaultPrevented) {
              return
          }
          this._isShown = true;
          this._isTransitioning = true;
          this._scrollBar.hide();
          document.body.classList.add(CLASS_NAME_OPEN);
          this._adjustDialog();
          this._backdrop.show(() => this._showElement(relatedTarget))
      }
      hide() {
          if (!this._isShown || this._isTransitioning) {
              return
          }
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
          if (hideEvent.defaultPrevented) {
              return
          }
          this._isShown = false;
          this._isTransitioning = true;
          this._focustrap.deactivate();
          this._element.classList.remove(CLASS_NAME_SHOW$4);
          this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())
      }
      dispose() {
          EventHandler.off(window, EVENT_KEY$4);
          EventHandler.off(this._dialog, EVENT_KEY$4);
          this._backdrop.dispose();
          this._focustrap.deactivate();
          super.dispose()
      }
      handleUpdate() {
          this._adjustDialog()
      }
      _initializeBackDrop() {
          return new Backdrop({
              isVisible: Boolean(this._config.backdrop),
              isAnimated: this._isAnimated()
          })
      }
      _initializeFocusTrap() {
          return new FocusTrap({
              trapElement: this._element
          })
      }
      _showElement(relatedTarget) {
          if (!document.body.contains(this._element)) {
              document.body.append(this._element)
          }
          this._element.style.display = "block";
          this._element.removeAttribute("aria-hidden");
          this._element.setAttribute("aria-modal", true);
          this._element.setAttribute("role", "dialog");
          this._element.scrollTop = 0;
          const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
          if (modalBody) {
              modalBody.scrollTop = 0
          }
          reflow(this._element);
          this._element.classList.add(CLASS_NAME_SHOW$4);
          const transitionComplete = () => {
              if (this._config.focus) {
                  this._focustrap.activate()
              }
              this._isTransitioning = false;
              EventHandler.trigger(this._element, EVENT_SHOWN$4, {
                  relatedTarget: relatedTarget
              })
          };
          this._queueCallback(transitionComplete, this._dialog, this._isAnimated())
      }
      _addEventListeners() {
          EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
              if (event.key !== ESCAPE_KEY$1) {
                  return
              }
              if (this._config.keyboard) {
                  this.hide();
                  return
              }
              this._triggerBackdropTransition()
          });
          EventHandler.on(window, EVENT_RESIZE$1, () => {
              if (this._isShown && !this._isTransitioning) {
                  this._adjustDialog()
              }
          });
          EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
              EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
                  if (this._element !== event.target || this._element !== event2.target) {
                      return
                  }
                  if (this._config.backdrop === "static") {
                      this._triggerBackdropTransition();
                      return
                  }
                  if (this._config.backdrop) {
                      this.hide()
                  }
              })
          })
      }
      _hideModal() {
          this._element.style.display = "none";
          this._element.setAttribute("aria-hidden", true);
          this._element.removeAttribute("aria-modal");
          this._element.removeAttribute("role");
          this._isTransitioning = false;
          this._backdrop.hide(() => {
              document.body.classList.remove(CLASS_NAME_OPEN);
              this._resetAdjustments();
              this._scrollBar.reset();
              EventHandler.trigger(this._element, EVENT_HIDDEN$4)
          })
      }
      _isAnimated() {
          return this._element.classList.contains(CLASS_NAME_FADE$3)
      }
      _triggerBackdropTransition() {
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
          if (hideEvent.defaultPrevented) {
              return
          }
          const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
          const initialOverflowY = this._element.style.overflowY;
          if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
              return
          }
          if (!isModalOverflowing) {
              this._element.style.overflowY = "hidden"
          }
          this._element.classList.add(CLASS_NAME_STATIC);
          this._queueCallback(() => {
              this._element.classList.remove(CLASS_NAME_STATIC);
              this._queueCallback(() => {
                  this._element.style.overflowY = initialOverflowY
              }, this._dialog)
          }, this._dialog);
          this._element.focus()
      }
      _adjustDialog() {
          const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
          const scrollbarWidth = this._scrollBar.getWidth();
          const isBodyOverflowing = scrollbarWidth > 0;
          if (isBodyOverflowing && !isModalOverflowing) {
              const property = isRTL() ? "paddingLeft" : "paddingRight";
              this._element.style[property] = `${scrollbarWidth}px`
          }
          if (!isBodyOverflowing && isModalOverflowing) {
              const property = isRTL() ? "paddingRight" : "paddingLeft";
              this._element.style[property] = `${scrollbarWidth}px`
          }
      }
      _resetAdjustments() {
          this._element.style.paddingLeft = "";
          this._element.style.paddingRight = ""
      }
      static jQueryInterface(config, relatedTarget) {
          return this.each(function() {
              const data = Modal.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config](relatedTarget)
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
          event.preventDefault()
      }
      EventHandler.one(target, EVENT_SHOW$4, showEvent => {
          if (showEvent.defaultPrevented) {
              return
          }
          EventHandler.one(target, EVENT_HIDDEN$4, () => {
              if (isVisible(this)) {
                  this.focus()
              }
          })
      });
      const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
      if (alreadyOpen) {
          Modal.getInstance(alreadyOpen).hide()
      }
      const data = Modal.getOrCreateInstance(target);
      data.toggle(this)
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  const NAME$6 = "offcanvas";
  const DATA_KEY$3 = "bs.offcanvas";
  const EVENT_KEY$3 = `.${DATA_KEY$3}`;
  const DATA_API_KEY$1 = ".data-api";
  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const ESCAPE_KEY = "Escape";
  const CLASS_NAME_SHOW$3 = "show";
  const CLASS_NAME_SHOWING$1 = "showing";
  const CLASS_NAME_HIDING = "hiding";
  const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  const OPEN_SELECTOR = ".offcanvas.show";
  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  const Default$5 = {
      backdrop: true,
      keyboard: true,
      scroll: false
  };
  const DefaultType$5 = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean"
  };
  class Offcanvas extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._isShown = false;
          this._backdrop = this._initializeBackDrop();
          this._focustrap = this._initializeFocusTrap();
          this._addEventListeners()
      }
      static get Default() {
          return Default$5
      }
      static get DefaultType() {
          return DefaultType$5
      }
      static get NAME() {
          return NAME$6
      }
      toggle(relatedTarget) {
          return this._isShown ? this.hide() : this.show(relatedTarget)
      }
      show(relatedTarget) {
          if (this._isShown) {
              return
          }
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
              relatedTarget: relatedTarget
          });
          if (showEvent.defaultPrevented) {
              return
          }
          this._isShown = true;
          this._backdrop.show();
          if (!this._config.scroll) {
              (new ScrollBarHelper).hide()
          }
          this._element.setAttribute("aria-modal", true);
          this._element.setAttribute("role", "dialog");
          this._element.classList.add(CLASS_NAME_SHOWING$1);
          const completeCallBack = () => {
              if (!this._config.scroll || this._config.backdrop) {
                  this._focustrap.activate()
              }
              this._element.classList.add(CLASS_NAME_SHOW$3);
              this._element.classList.remove(CLASS_NAME_SHOWING$1);
              EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                  relatedTarget: relatedTarget
              })
          };
          this._queueCallback(completeCallBack, this._element, true)
      }
      hide() {
          if (!this._isShown) {
              return
          }
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
          if (hideEvent.defaultPrevented) {
              return
          }
          this._focustrap.deactivate();
          this._element.blur();
          this._isShown = false;
          this._element.classList.add(CLASS_NAME_HIDING);
          this._backdrop.hide();
          const completeCallback = () => {
              this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
              this._element.removeAttribute("aria-modal");
              this._element.removeAttribute("role");
              if (!this._config.scroll) {
                  (new ScrollBarHelper).reset()
              }
              EventHandler.trigger(this._element, EVENT_HIDDEN$3)
          };
          this._queueCallback(completeCallback, this._element, true)
      }
      dispose() {
          this._backdrop.dispose();
          this._focustrap.deactivate();
          super.dispose()
      }
      _initializeBackDrop() {
          const clickCallback = () => {
              if (this._config.backdrop === "static") {
                  EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                  return
              }
              this.hide()
          };
          const isVisible = Boolean(this._config.backdrop);
          return new Backdrop({
              className: CLASS_NAME_BACKDROP,
              isVisible: isVisible,
              isAnimated: true,
              rootElement: this._element.parentNode,
              clickCallback: isVisible ? clickCallback : null
          })
      }
      _initializeFocusTrap() {
          return new FocusTrap({
              trapElement: this._element
          })
      }
      _addEventListeners() {
          EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
              if (event.key !== ESCAPE_KEY) {
                  return
              }
              if (this._config.keyboard) {
                  this.hide();
                  return
              }
              EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED)
          })
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Offcanvas.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config](this)
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
      const target = SelectorEngine.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
          event.preventDefault()
      }
      if (isDisabled(this)) {
          return
      }
      EventHandler.one(target, EVENT_HIDDEN$3, () => {
          if (isVisible(this)) {
              this.focus()
          }
      });
      const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
      if (alreadyOpen && alreadyOpen !== target) {
          Offcanvas.getInstance(alreadyOpen).hide()
      }
      const data = Offcanvas.getOrCreateInstance(target);
      data.toggle(this)
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
      for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
          Offcanvas.getOrCreateInstance(selector).show()
      }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
      for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
          if (getComputedStyle(element).position !== "fixed") {
              Offcanvas.getOrCreateInstance(element).hide()
          }
      }
  });
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  const DefaultAllowlist = {
      "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
  };
  const uriAttributes = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  const allowedAttribute = (attribute, allowedAttributeList) => {
      const attributeName = attribute.nodeName.toLowerCase();
      if (allowedAttributeList.includes(attributeName)) {
          if (uriAttributes.has(attributeName)) {
              return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue))
          }
          return true
      }
      return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName))
  };

  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
      if (!unsafeHtml.length) {
          return unsafeHtml
      }
      if (sanitizeFunction && typeof sanitizeFunction === "function") {
          return sanitizeFunction(unsafeHtml)
      }
      const domParser = new window.DOMParser;
      const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
      const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
      for (const element of elements) {
          const elementName = element.nodeName.toLowerCase();
          if (!Object.keys(allowList).includes(elementName)) {
              element.remove();
              continue
          }
          const attributeList = [].concat(...element.attributes);
          const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
          for (const attribute of attributeList) {
              if (!allowedAttribute(attribute, allowedAttributes)) {
                  element.removeAttribute(attribute.nodeName)
              }
          }
      }
      return createdDocument.body.innerHTML
  }
  const NAME$5 = "TemplateFactory";
  const Default$4 = {
      allowList: DefaultAllowlist,
      content: {},
      extraClass: "",
      html: false,
      sanitize: true,
      sanitizeFn: null,
      template: "<div></div>"
  };
  const DefaultType$4 = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string"
  };
  const DefaultContentType = {
      entry: "(string|element|function|null)",
      selector: "(string|element)"
  };
  class TemplateFactory extends Config {
      constructor(config) {
          super();
          this._config = this._getConfig(config)
      }
      static get Default() {
          return Default$4
      }
      static get DefaultType() {
          return DefaultType$4
      }
      static get NAME() {
          return NAME$5
      }
      getContent() {
          return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean)
      }
      hasContent() {
          return this.getContent().length > 0
      }
      changeContent(content) {
          this._checkContent(content);
          this._config.content = {
              ...this._config.content,
              ...content
          };
          return this
      }
      toHtml() {
          const templateWrapper = document.createElement("div");
          templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
          for (const [selector, text] of Object.entries(this._config.content)) {
              this._setContent(templateWrapper, text, selector)
          }
          const template = templateWrapper.children[0];
          const extraClass = this._resolvePossibleFunction(this._config.extraClass);
          if (extraClass) {
              template.classList.add(...extraClass.split(" "))
          }
          return template
      }
      _typeCheckConfig(config) {
          super._typeCheckConfig(config);
          this._checkContent(config.content)
      }
      _checkContent(arg) {
          for (const [selector, content] of Object.entries(arg)) {
              super._typeCheckConfig({
                  selector: selector,
                  entry: content
              }, DefaultContentType)
          }
      }
      _setContent(template, content, selector) {
          const templateElement = SelectorEngine.findOne(selector, template);
          if (!templateElement) {
              return
          }
          content = this._resolvePossibleFunction(content);
          if (!content) {
              templateElement.remove();
              return
          }
          if (isElement$1(content)) {
              this._putElementInTemplate(getElement(content), templateElement);
              return
          }
          if (this._config.html) {
              templateElement.innerHTML = this._maybeSanitize(content);
              return
          }
          templateElement.textContent = content
      }
      _maybeSanitize(arg) {
          return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg
      }
      _resolvePossibleFunction(arg) {
          return execute(arg, [this])
      }
      _putElementInTemplate(element, templateElement) {
          if (this._config.html) {
              templateElement.innerHTML = "";
              templateElement.append(element);
              return
          }
          templateElement.textContent = element.textContent
      }
  }
  const NAME$4 = "tooltip";
  const DISALLOWED_ATTRIBUTES = new Set(["sanitize", "allowList", "sanitizeFn"]);
  const CLASS_NAME_FADE$2 = "fade";
  const CLASS_NAME_MODAL = "modal";
  const CLASS_NAME_SHOW$2 = "show";
  const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  const EVENT_MODAL_HIDE = "hide.bs.modal";
  const TRIGGER_HOVER = "hover";
  const TRIGGER_FOCUS = "focus";
  const TRIGGER_CLICK = "click";
  const TRIGGER_MANUAL = "manual";
  const EVENT_HIDE$2 = "hide";
  const EVENT_HIDDEN$2 = "hidden";
  const EVENT_SHOW$2 = "show";
  const EVENT_SHOWN$2 = "shown";
  const EVENT_INSERTED = "inserted";
  const EVENT_CLICK$1 = "click";
  const EVENT_FOCUSIN$1 = "focusin";
  const EVENT_FOCUSOUT$1 = "focusout";
  const EVENT_MOUSEENTER = "mouseenter";
  const EVENT_MOUSELEAVE = "mouseleave";
  const AttachmentMap = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: isRTL() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: isRTL() ? "right" : "left"
  };
  const Default$3 = {
      allowList: DefaultAllowlist,
      animation: true,
      boundary: "clippingParents",
      container: false,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: false,
      offset: [0, 6],
      placement: "top",
      popperConfig: null,
      sanitize: true,
      sanitizeFn: null,
      selector: false,
      template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + "</div>",
      title: "",
      trigger: "hover focus"
  };
  const DefaultType$3 = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string"
  };
  class Tooltip extends BaseComponent {
      constructor(element, config) {
          if (typeof Popper === "undefined") {
              throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)")
          }
          super(element, config);
          this._isEnabled = true;
          this._timeout = 0;
          this._isHovered = null;
          this._activeTrigger = {};
          this._popper = null;
          this._templateFactory = null;
          this._newContent = null;
          this.tip = null;
          this._setListeners();
          if (!this._config.selector) {
              this._fixTitle()
          }
      }
      static get Default() {
          return Default$3
      }
      static get DefaultType() {
          return DefaultType$3
      }
      static get NAME() {
          return NAME$4
      }
      enable() {
          this._isEnabled = true
      }
      disable() {
          this._isEnabled = false
      }
      toggleEnabled() {
          this._isEnabled = !this._isEnabled
      }
      toggle() {
          if (!this._isEnabled) {
              return
          }
          this._activeTrigger.click = !this._activeTrigger.click;
          if (this._isShown()) {
              this._leave();
              return
          }
          this._enter()
      }
      dispose() {
          clearTimeout(this._timeout);
          EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
          if (this._element.getAttribute("data-bs-original-title")) {
              this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"))
          }
          this._disposePopper();
          super.dispose()
      }
      show() {
          if (this._element.style.display === "none") {
              throw new Error("Please use show on visible elements")
          }
          if (!(this._isWithContent() && this._isEnabled)) {
              return
          }
          const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
          const shadowRoot = findShadowRoot(this._element);
          const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
          if (showEvent.defaultPrevented || !isInTheDom) {
              return
          }
          this._disposePopper();
          const tip = this._getTipElement();
          this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
          const {
              container
          } = this._config;
          if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
              container.append(tip);
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED))
          }
          this._popper = this._createPopper(tip);
          tip.classList.add(CLASS_NAME_SHOW$2);
          if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                  EventHandler.on(element, "mouseover", noop)
              }
          }
          const complete = () => {
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
              if (this._isHovered === false) {
                  this._leave()
              }
              this._isHovered = false
          };
          this._queueCallback(complete, this.tip, this._isAnimated())
      }
      hide() {
          if (!this._isShown()) {
              return
          }
          const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
          if (hideEvent.defaultPrevented) {
              return
          }
          const tip = this._getTipElement();
          tip.classList.remove(CLASS_NAME_SHOW$2);
          if ("ontouchstart" in document.documentElement) {
              for (const element of [].concat(...document.body.children)) {
                  EventHandler.off(element, "mouseover", noop)
              }
          }
          this._activeTrigger[TRIGGER_CLICK] = false;
          this._activeTrigger[TRIGGER_FOCUS] = false;
          this._activeTrigger[TRIGGER_HOVER] = false;
          this._isHovered = null;
          const complete = () => {
              if (this._isWithActiveTrigger()) {
                  return
              }
              if (!this._isHovered) {
                  this._disposePopper()
              }
              this._element.removeAttribute("aria-describedby");
              EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2))
          };
          this._queueCallback(complete, this.tip, this._isAnimated())
      }
      update() {
          if (this._popper) {
              this._popper.update()
          }
      }
      _isWithContent() {
          return Boolean(this._getTitle())
      }
      _getTipElement() {
          if (!this.tip) {
              this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())
          }
          return this.tip
      }
      _createTipElement(content) {
          const tip = this._getTemplateFactory(content).toHtml();
          if (!tip) {
              return null
          }
          tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
          tip.classList.add(`bs-${this.constructor.NAME}-auto`);
          const tipId = getUID(this.constructor.NAME).toString();
          tip.setAttribute("id", tipId);
          if (this._isAnimated()) {
              tip.classList.add(CLASS_NAME_FADE$2)
          }
          return tip
      }
      setContent(content) {
          this._newContent = content;
          if (this._isShown()) {
              this._disposePopper();
              this.show()
          }
      }
      _getTemplateFactory(content) {
          if (this._templateFactory) {
              this._templateFactory.changeContent(content)
          } else {
              this._templateFactory = new TemplateFactory({
                  ...this._config,
                  content: content,
                  extraClass: this._resolvePossibleFunction(this._config.customClass)
              })
          }
          return this._templateFactory
      }
      _getContentForTemplate() {
          return {
              [SELECTOR_TOOLTIP_INNER]: this._getTitle()
          }
      }
      _getTitle() {
          return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
      }
      _initializeOnDelegatedTarget(event) {
          return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig())
      }
      _isAnimated() {
          return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2)
      }
      _isShown() {
          return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2)
      }
      _createPopper(tip) {
          const placement = execute(this._config.placement, [this, tip, this._element]);
          const attachment = AttachmentMap[placement.toUpperCase()];
          return createPopper(this._element, tip, this._getPopperConfig(attachment))
      }
      _getOffset() {
          const {
              offset
          } = this._config;
          if (typeof offset === "string") {
              return offset.split(",").map(value => Number.parseInt(value, 10))
          }
          if (typeof offset === "function") {
              return popperData => offset(popperData, this._element)
          }
          return offset
      }
      _resolvePossibleFunction(arg) {
          return execute(arg, [this._element])
      }
      _getPopperConfig(attachment) {
          const defaultBsPopperConfig = {
              placement: attachment,
              modifiers: [{
                  name: "flip",
                  options: {
                      fallbackPlacements: this._config.fallbackPlacements
                  }
              }, {
                  name: "offset",
                  options: {
                      offset: this._getOffset()
                  }
              }, {
                  name: "preventOverflow",
                  options: {
                      boundary: this._config.boundary
                  }
              }, {
                  name: "arrow",
                  options: {
                      element: `.${this.constructor.NAME}-arrow`
                  }
              }, {
                  name: "preSetPlacement",
                  enabled: true,
                  phase: "beforeMain",
                  fn: data => {
                      this._getTipElement().setAttribute("data-popper-placement", data.state.placement)
                  }
              }]
          };
          return {
              ...defaultBsPopperConfig,
              ...execute(this._config.popperConfig, [defaultBsPopperConfig])
          }
      }
      _setListeners() {
          const triggers = this._config.trigger.split(" ");
          for (const trigger of triggers) {
              if (trigger === "click") {
                  EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
                      const context = this._initializeOnDelegatedTarget(event);
                      context.toggle()
                  })
              } else if (trigger !== TRIGGER_MANUAL) {
                  const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
                  const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
                  EventHandler.on(this._element, eventIn, this._config.selector, event => {
                      const context = this._initializeOnDelegatedTarget(event);
                      context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                      context._enter()
                  });
                  EventHandler.on(this._element, eventOut, this._config.selector, event => {
                      const context = this._initializeOnDelegatedTarget(event);
                      context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                      context._leave()
                  })
              }
          }
          this._hideModalHandler = () => {
              if (this._element) {
                  this.hide()
              }
          };
          EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler)
      }
      _fixTitle() {
          const title = this._element.getAttribute("title");
          if (!title) {
              return
          }
          if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
              this._element.setAttribute("aria-label", title)
          }
          this._element.setAttribute("data-bs-original-title", title);
          this._element.removeAttribute("title")
      }
      _enter() {
          if (this._isShown() || this._isHovered) {
              this._isHovered = true;
              return
          }
          this._isHovered = true;
          this._setTimeout(() => {
              if (this._isHovered) {
                  this.show()
              }
          }, this._config.delay.show)
      }
      _leave() {
          if (this._isWithActiveTrigger()) {
              return
          }
          this._isHovered = false;
          this._setTimeout(() => {
              if (!this._isHovered) {
                  this.hide()
              }
          }, this._config.delay.hide)
      }
      _setTimeout(handler, timeout) {
          clearTimeout(this._timeout);
          this._timeout = setTimeout(handler, timeout)
      }
      _isWithActiveTrigger() {
          return Object.values(this._activeTrigger).includes(true)
      }
      _getConfig(config) {
          const dataAttributes = Manipulator.getDataAttributes(this._element);
          for (const dataAttribute of Object.keys(dataAttributes)) {
              if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
                  delete dataAttributes[dataAttribute]
              }
          }
          config = {
              ...dataAttributes,
              ...typeof config === "object" && config ? config : {}
          };
          config = this._mergeConfigObj(config);
          config = this._configAfterMerge(config);
          this._typeCheckConfig(config);
          return config
      }
      _configAfterMerge(config) {
          config.container = config.container === false ? document.body : getElement(config.container);
          if (typeof config.delay === "number") {
              config.delay = {
                  show: config.delay,
                  hide: config.delay
              }
          }
          if (typeof config.title === "number") {
              config.title = config.title.toString()
          }
          if (typeof config.content === "number") {
              config.content = config.content.toString()
          }
          return config
      }
      _getDelegateConfig() {
          const config = {};
          for (const [key, value] of Object.entries(this._config)) {
              if (this.constructor.Default[key] !== value) {
                  config[key] = value
              }
          }
          config.selector = false;
          config.trigger = "manual";
          return config
      }
      _disposePopper() {
          if (this._popper) {
              this._popper.destroy();
              this._popper = null
          }
          if (this.tip) {
              this.tip.remove();
              this.tip = null
          }
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Tooltip.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config]()
          })
      }
  }
  defineJQueryPlugin(Tooltip);
  const NAME$3 = "popover";
  const SELECTOR_TITLE = ".popover-header";
  const SELECTOR_CONTENT = ".popover-body";
  const Default$2 = {
      ...Tooltip.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + "</div>",
      trigger: "click"
  };
  const DefaultType$2 = {
      ...Tooltip.DefaultType,
      content: "(null|string|element|function)"
  };
  class Popover extends Tooltip {
      static get Default() {
          return Default$2
      }
      static get DefaultType() {
          return DefaultType$2
      }
      static get NAME() {
          return NAME$3
      }
      _isWithContent() {
          return this._getTitle() || this._getContent()
      }
      _getContentForTemplate() {
          return {
              [SELECTOR_TITLE]: this._getTitle(),
              [SELECTOR_CONTENT]: this._getContent()
          }
      }
      _getContent() {
          return this._resolvePossibleFunction(this._config.content)
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Popover.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (typeof data[config] === "undefined") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config]()
          })
      }
  }
  defineJQueryPlugin(Popover);
  const NAME$2 = "scrollspy";
  const DATA_KEY$2 = "bs.scrollspy";
  const EVENT_KEY$2 = `.${DATA_KEY$2}`;
  const DATA_API_KEY = ".data-api";
  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  const EVENT_CLICK = `click${EVENT_KEY$2}`;
  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  const CLASS_NAME_ACTIVE$1 = "active";
  const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  const SELECTOR_TARGET_LINKS = "[href]";
  const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  const SELECTOR_NAV_LINKS = ".nav-link";
  const SELECTOR_NAV_ITEMS = ".nav-item";
  const SELECTOR_LIST_ITEMS = ".list-group-item";
  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  const SELECTOR_DROPDOWN = ".dropdown";
  const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  const Default$1 = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: false,
      target: null,
      threshold: [.1, .5, 1]
  };
  const DefaultType$1 = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array"
  };
  class ScrollSpy extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._targetLinks = new Map;
          this._observableSections = new Map;
          this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
          this._activeTarget = null;
          this._observer = null;
          this._previousScrollData = {
              visibleEntryTop: 0,
              parentScrollTop: 0
          };
          this.refresh()
      }
      static get Default() {
          return Default$1
      }
      static get DefaultType() {
          return DefaultType$1
      }
      static get NAME() {
          return NAME$2
      }
      refresh() {
          this._initializeTargetsAndObservables();
          this._maybeEnableSmoothScroll();
          if (this._observer) {
              this._observer.disconnect()
          } else {
              this._observer = this._getNewObserver()
          }
          for (const section of this._observableSections.values()) {
              this._observer.observe(section)
          }
      }
      dispose() {
          this._observer.disconnect();
          super.dispose()
      }
      _configAfterMerge(config) {
          config.target = getElement(config.target) || document.body;
          config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
          if (typeof config.threshold === "string") {
              config.threshold = config.threshold.split(",").map(value => Number.parseFloat(value))
          }
          return config
      }
      _maybeEnableSmoothScroll() {
          if (!this._config.smoothScroll) {
              return
          }
          EventHandler.off(this._config.target, EVENT_CLICK);
          EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
              const observableSection = this._observableSections.get(event.target.hash);
              if (observableSection) {
                  event.preventDefault();
                  const root = this._rootElement || window;
                  const height = observableSection.offsetTop - this._element.offsetTop;
                  if (root.scrollTo) {
                      root.scrollTo({
                          top: height,
                          behavior: "smooth"
                      });
                      return
                  }
                  root.scrollTop = height
              }
          })
      }
      _getNewObserver() {
          const options = {
              root: this._rootElement,
              threshold: this._config.threshold,
              rootMargin: this._config.rootMargin
          };
          return new IntersectionObserver(entries => this._observerCallback(entries), options)
      }
      _observerCallback(entries) {
          const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
          const activate = entry => {
              this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
              this._process(targetElement(entry))
          };
          const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
          const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
          this._previousScrollData.parentScrollTop = parentScrollTop;
          for (const entry of entries) {
              if (!entry.isIntersecting) {
                  this._activeTarget = null;
                  this._clearActiveClass(targetElement(entry));
                  continue
              }
              const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
              if (userScrollsDown && entryIsLowerThanPrevious) {
                  activate(entry);
                  if (!parentScrollTop) {
                      return
                  }
                  continue
              }
              if (!userScrollsDown && !entryIsLowerThanPrevious) {
                  activate(entry)
              }
          }
      }
      _initializeTargetsAndObservables() {
          this._targetLinks = new Map;
          this._observableSections = new Map;
          const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
          for (const anchor of targetLinks) {
              if (!anchor.hash || isDisabled(anchor)) {
                  continue
              }
              const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
              if (isVisible(observableSection)) {
                  this._targetLinks.set(decodeURI(anchor.hash), anchor);
                  this._observableSections.set(anchor.hash, observableSection)
              }
          }
      }
      _process(target) {
          if (this._activeTarget === target) {
              return
          }
          this._clearActiveClass(this._config.target);
          this._activeTarget = target;
          target.classList.add(CLASS_NAME_ACTIVE$1);
          this._activateParents(target);
          EventHandler.trigger(this._element, EVENT_ACTIVATE, {
              relatedTarget: target
          })
      }
      _activateParents(target) {
          if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
              SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
              return
          }
          for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
              for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
                  item.classList.add(CLASS_NAME_ACTIVE$1)
              }
          }
      }
      _clearActiveClass(parent) {
          parent.classList.remove(CLASS_NAME_ACTIVE$1);
          const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
          for (const node of activeNodes) {
              node.classList.remove(CLASS_NAME_ACTIVE$1)
          }
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = ScrollSpy.getOrCreateInstance(this, config);
              if (typeof config !== "string") {
                  return
              }
              if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config]()
          })
      }
  }
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
      for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
          ScrollSpy.getOrCreateInstance(spy)
      }
  });
  defineJQueryPlugin(ScrollSpy);
  const NAME$1 = "tab";
  const DATA_KEY$1 = "bs.tab";
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  const ARROW_LEFT_KEY = "ArrowLeft";
  const ARROW_RIGHT_KEY = "ArrowRight";
  const ARROW_UP_KEY = "ArrowUp";
  const ARROW_DOWN_KEY = "ArrowDown";
  const HOME_KEY = "Home";
  const END_KEY = "End";
  const CLASS_NAME_ACTIVE = "active";
  const CLASS_NAME_FADE$1 = "fade";
  const CLASS_NAME_SHOW$1 = "show";
  const CLASS_DROPDOWN = "dropdown";
  const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  const SELECTOR_OUTER = ".nav-item, .list-group-item";
  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  class Tab extends BaseComponent {
      constructor(element) {
          super(element);
          this._parent = this._element.closest(SELECTOR_TAB_PANEL);
          if (!this._parent) {
              return
          }
          this._setInitialAttributes(this._parent, this._getChildren());
          EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event))
      }
      static get NAME() {
          return NAME$1
      }
      show() {
          const innerElem = this._element;
          if (this._elemIsActive(innerElem)) {
              return
          }
          const active = this._getActiveElem();
          const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
              relatedTarget: innerElem
          }) : null;
          const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
              relatedTarget: active
          });
          if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
              return
          }
          this._deactivate(active, innerElem);
          this._activate(innerElem, active)
      }
      _activate(element, relatedElem) {
          if (!element) {
              return
          }
          element.classList.add(CLASS_NAME_ACTIVE);
          this._activate(SelectorEngine.getElementFromSelector(element));
          const complete = () => {
              if (element.getAttribute("role") !== "tab") {
                  element.classList.add(CLASS_NAME_SHOW$1);
                  return
              }
              element.removeAttribute("tabindex");
              element.setAttribute("aria-selected", true);
              this._toggleDropDown(element, true);
              EventHandler.trigger(element, EVENT_SHOWN$1, {
                  relatedTarget: relatedElem
              })
          };
          this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1))
      }
      _deactivate(element, relatedElem) {
          if (!element) {
              return
          }
          element.classList.remove(CLASS_NAME_ACTIVE);
          element.blur();
          this._deactivate(SelectorEngine.getElementFromSelector(element));
          const complete = () => {
              if (element.getAttribute("role") !== "tab") {
                  element.classList.remove(CLASS_NAME_SHOW$1);
                  return
              }
              element.setAttribute("aria-selected", false);
              element.setAttribute("tabindex", "-1");
              this._toggleDropDown(element, false);
              EventHandler.trigger(element, EVENT_HIDDEN$1, {
                  relatedTarget: relatedElem
              })
          };
          this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1))
      }
      _keydown(event) {
          if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
              return
          }
          event.stopPropagation();
          event.preventDefault();
          const children = this._getChildren().filter(element => !isDisabled(element));
          let nextActiveElement;
          if ([HOME_KEY, END_KEY].includes(event.key)) {
              nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1]
          } else {
              const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
              nextActiveElement = getNextActiveElement(children, event.target, isNext, true)
          }
          if (nextActiveElement) {
              nextActiveElement.focus({
                  preventScroll: true
              });
              Tab.getOrCreateInstance(nextActiveElement).show()
          }
      }
      _getChildren() {
          return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent)
      }
      _getActiveElem() {
          return this._getChildren().find(child => this._elemIsActive(child)) || null
      }
      _setInitialAttributes(parent, children) {
          this._setAttributeIfNotExists(parent, "role", "tablist");
          for (const child of children) {
              this._setInitialAttributesOnChild(child)
          }
      }
      _setInitialAttributesOnChild(child) {
          child = this._getInnerElement(child);
          const isActive = this._elemIsActive(child);
          const outerElem = this._getOuterElement(child);
          child.setAttribute("aria-selected", isActive);
          if (outerElem !== child) {
              this._setAttributeIfNotExists(outerElem, "role", "presentation")
          }
          if (!isActive) {
              child.setAttribute("tabindex", "-1")
          }
          this._setAttributeIfNotExists(child, "role", "tab");
          this._setInitialAttributesOnTargetPanel(child)
      }
      _setInitialAttributesOnTargetPanel(child) {
          const target = SelectorEngine.getElementFromSelector(child);
          if (!target) {
              return
          }
          this._setAttributeIfNotExists(target, "role", "tabpanel");
          if (child.id) {
              this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`)
          }
      }
      _toggleDropDown(element, open) {
          const outerElem = this._getOuterElement(element);
          if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
              return
          }
          const toggle = (selector, className) => {
              const element = SelectorEngine.findOne(selector, outerElem);
              if (element) {
                  element.classList.toggle(className, open)
              }
          };
          toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
          toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
          outerElem.setAttribute("aria-expanded", open)
      }
      _setAttributeIfNotExists(element, attribute, value) {
          if (!element.hasAttribute(attribute)) {
              element.setAttribute(attribute, value)
          }
      }
      _elemIsActive(elem) {
          return elem.classList.contains(CLASS_NAME_ACTIVE)
      }
      _getInnerElement(elem) {
          return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem)
      }
      _getOuterElement(elem) {
          return elem.closest(SELECTOR_OUTER) || elem
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Tab.getOrCreateInstance(this);
              if (typeof config !== "string") {
                  return
              }
              if (data[config] === undefined || config.startsWith("_") || config === "constructor") {
                  throw new TypeError(`No method named "${config}"`)
              }
              data[config]()
          })
      }
  }
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
          event.preventDefault()
      }
      if (isDisabled(this)) {
          return
      }
      Tab.getOrCreateInstance(this).show()
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
      for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
          Tab.getOrCreateInstance(element)
      }
  });
  defineJQueryPlugin(Tab);
  const NAME = "toast";
  const DATA_KEY = "bs.toast";
  const EVENT_KEY = `.${DATA_KEY}`;
  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const CLASS_NAME_FADE = "fade";
  const CLASS_NAME_HIDE = "hide";
  const CLASS_NAME_SHOW = "show";
  const CLASS_NAME_SHOWING = "showing";
  const DefaultType = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
  };
  const Default = {
      animation: true,
      autohide: true,
      delay: 5e3
  };
  class Toast extends BaseComponent {
      constructor(element, config) {
          super(element, config);
          this._timeout = null;
          this._hasMouseInteraction = false;
          this._hasKeyboardInteraction = false;
          this._setListeners()
      }
      static get Default() {
          return Default
      }
      static get DefaultType() {
          return DefaultType
      }
      static get NAME() {
          return NAME
      }
      show() {
          const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
          if (showEvent.defaultPrevented) {
              return
          }
          this._clearTimeout();
          if (this._config.animation) {
              this._element.classList.add(CLASS_NAME_FADE)
          }
          const complete = () => {
              this._element.classList.remove(CLASS_NAME_SHOWING);
              EventHandler.trigger(this._element, EVENT_SHOWN);
              this._maybeScheduleHide()
          };
          this._element.classList.remove(CLASS_NAME_HIDE);
          reflow(this._element);
          this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
          this._queueCallback(complete, this._element, this._config.animation)
      }
      hide() {
          if (!this.isShown()) {
              return
          }
          const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
          if (hideEvent.defaultPrevented) {
              return
          }
          const complete = () => {
              this._element.classList.add(CLASS_NAME_HIDE);
              this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
              EventHandler.trigger(this._element, EVENT_HIDDEN)
          };
          this._element.classList.add(CLASS_NAME_SHOWING);
          this._queueCallback(complete, this._element, this._config.animation)
      }
      dispose() {
          this._clearTimeout();
          if (this.isShown()) {
              this._element.classList.remove(CLASS_NAME_SHOW)
          }
          super.dispose()
      }
      isShown() {
          return this._element.classList.contains(CLASS_NAME_SHOW)
      }
      _maybeScheduleHide() {
          if (!this._config.autohide) {
              return
          }
          if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
              return
          }
          this._timeout = setTimeout(() => {
              this.hide()
          }, this._config.delay)
      }
      _onInteraction(event, isInteracting) {
          switch (event.type) {
              case "mouseover":
              case "mouseout": {
                  this._hasMouseInteraction = isInteracting;
                  break
              }
              case "focusin":
              case "focusout": {
                  this._hasKeyboardInteraction = isInteracting;
                  break
              }
          }
          if (isInteracting) {
              this._clearTimeout();
              return
          }
          const nextElement = event.relatedTarget;
          if (this._element === nextElement || this._element.contains(nextElement)) {
              return
          }
          this._maybeScheduleHide()
      }
      _setListeners() {
          EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
          EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
          EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
          EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false))
      }
      _clearTimeout() {
          clearTimeout(this._timeout);
          this._timeout = null
      }
      static jQueryInterface(config) {
          return this.each(function() {
              const data = Toast.getOrCreateInstance(this, config);
              if (typeof config === "string") {
                  if (typeof data[config] === "undefined") {
                      throw new TypeError(`No method named "${config}"`)
                  }
                  data[config](this)
              }
          })
      }
  }
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);
  const index_umd = {
      Alert: Alert,
      Button: Button,
      Carousel: Carousel,
      Collapse: Collapse,
      Dropdown: Dropdown,
      Modal: Modal,
      Offcanvas: Offcanvas,
      Popover: Popover,
      ScrollSpy: ScrollSpy,
      Tab: Tab,
      Toast: Toast,
      Tooltip: Tooltip
  };
  return index_umd
});
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = global || self, factory(global.window = global.window || {}))
})(this, function(exports) {
  "use strict";

  function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass
  }

  function _assertThisInitialized(self) {
      if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
      }
      return self
  }
  var _config = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: {
              lineHeight: ""
          }
      },
      _defaults = {
          duration: .5,
          overwrite: false,
          delay: 0
      },
      _suppressOverwrites, _reverting, _context, _bigNum = 1e8,
      _tinyNum = 1 / _bigNum,
      _2PI = Math.PI * 2,
      _HALF_PI = _2PI / 4,
      _gsID = 0,
      _sqrt = Math.sqrt,
      _cos = Math.cos,
      _sin = Math.sin,
      _isString = function _isString(value) {
          return typeof value === "string"
      },
      _isFunction = function _isFunction(value) {
          return typeof value === "function"
      },
      _isNumber = function _isNumber(value) {
          return typeof value === "number"
      },
      _isUndefined = function _isUndefined(value) {
          return typeof value === "undefined"
      },
      _isObject = function _isObject(value) {
          return typeof value === "object"
      },
      _isNotFalse = function _isNotFalse(value) {
          return value !== false
      },
      _windowExists = function _windowExists() {
          return typeof window !== "undefined"
      },
      _isFuncOrString = function _isFuncOrString(value) {
          return _isFunction(value) || _isString(value)
      },
      _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {},
      _isArray = Array.isArray,
      _strictNumExp = /(?:-?\.?\d|\.)+/gi,
      _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
      _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
      _relExp = /[+-]=-?[.\d]+/,
      _delimitedValueExp = /[^,'"\[\]\s]+/gi,
      _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
      _globalTimeline, _win, _coreInitted, _doc, _globals = {},
      _installScope = {},
      _coreReady, _install = function _install(scope) {
          return (_installScope = _merge(scope, _globals)) && gsap
      },
      _missingPlugin = function _missingPlugin(property, value) {
          return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()")
      },
      _warn = function _warn(message, suppress) {
          return !suppress && console.warn(message)
      },
      _addGlobal = function _addGlobal(name, obj) {
          return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals
      },
      _emptyFunc = function _emptyFunc() {
          return 0
      },
      _startAtRevertConfig = {
          suppressEvents: true,
          isStart: true,
          kill: false
      },
      _revertConfigNoKill = {
          suppressEvents: true,
          kill: false
      },
      _revertConfig = {
          suppressEvents: true
      },
      _reservedProps = {},
      _lazyTweens = [],
      _lazyLookup = {},
      _lastRenderedFrame, _plugins = {},
      _effects = {},
      _nextGCFrame = 30,
      _harnessPlugins = [],
      _callbackNames = "",
      _harness = function _harness(targets) {
          var target = targets[0],
              harnessPlugin, i;
          _isObject(target) || _isFunction(target) || (targets = [targets]);
          if (!(harnessPlugin = (target._gsap || {}).harness)) {
              i = _harnessPlugins.length;
              while (i-- && !_harnessPlugins[i].targetTest(target)) {}
              harnessPlugin = _harnessPlugins[i]
          }
          i = targets.length;
          while (i--) {
              targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1)
          }
          return targets
      },
      _getCache = function _getCache(target) {
          return target._gsap || _harness(toArray(target))[0]._gsap
      },
      _getProperty = function _getProperty(target, property, v) {
          return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v
      },
      _forEachName = function _forEachName(names, func) {
          return (names = names.split(",")).forEach(func) || names
      },
      _round = function _round(value) {
          return Math.round(value * 1e5) / 1e5 || 0
      },
      _roundPrecise = function _roundPrecise(value) {
          return Math.round(value * 1e7) / 1e7 || 0
      },
      _parseRelative = function _parseRelative(start, value) {
          var operator = value.charAt(0),
              end = parseFloat(value.substr(2));
          start = parseFloat(start);
          return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end
      },
      _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
          var l = toFind.length,
              i = 0;
          for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
          return i < l
      },
      _lazyRender = function _lazyRender() {
          var l = _lazyTweens.length,
              a = _lazyTweens.slice(0),
              i, tween;
          _lazyLookup = {};
          _lazyTweens.length = 0;
          for (i = 0; i < l; i++) {
              tween = a[i];
              tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0)
          }
      },
      _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
          _lazyTweens.length && !_reverting && _lazyRender();
          animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
          _lazyTweens.length && !_reverting && _lazyRender()
      },
      _numericIfPossible = function _numericIfPossible(value) {
          var n = parseFloat(value);
          return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value
      },
      _passThrough = function _passThrough(p) {
          return p
      },
      _setDefaults = function _setDefaults(obj, defaults) {
          for (var p in defaults) {
              p in obj || (obj[p] = defaults[p])
          }
          return obj
      },
      _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
          return function(obj, defaults) {
              for (var p in defaults) {
                  p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p])
              }
          }
      },
      _merge = function _merge(base, toMerge) {
          for (var p in toMerge) {
              base[p] = toMerge[p]
          }
          return base
      },
      _mergeDeep = function _mergeDeep(base, toMerge) {
          for (var p in toMerge) {
              p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p])
          }
          return base
      },
      _copyExcluding = function _copyExcluding(obj, excluding) {
          var copy = {},
              p;
          for (p in obj) {
              p in excluding || (copy[p] = obj[p])
          }
          return copy
      },
      _inheritDefaults = function _inheritDefaults(vars) {
          var parent = vars.parent || _globalTimeline,
              func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
          if (_isNotFalse(vars.inherit)) {
              while (parent) {
                  func(vars, parent.vars.defaults);
                  parent = parent.parent || parent._dp
              }
          }
          return vars
      },
      _arraysMatch = function _arraysMatch(a1, a2) {
          var i = a1.length,
              match = i === a2.length;
          while (match && i-- && a1[i] === a2[i]) {}
          return i < 0
      },
      _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
          if (firstProp === void 0) {
              firstProp = "_first"
          }
          if (lastProp === void 0) {
              lastProp = "_last"
          }
          var prev = parent[lastProp],
              t;
          if (sortBy) {
              t = child[sortBy];
              while (prev && prev[sortBy] > t) {
                  prev = prev._prev
              }
          }
          if (prev) {
              child._next = prev._next;
              prev._next = child
          } else {
              child._next = parent[firstProp];
              parent[firstProp] = child
          }
          if (child._next) {
              child._next._prev = child
          } else {
              parent[lastProp] = child
          }
          child._prev = prev;
          child.parent = child._dp = parent;
          return child
      },
      _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
          if (firstProp === void 0) {
              firstProp = "_first"
          }
          if (lastProp === void 0) {
              lastProp = "_last"
          }
          var prev = child._prev,
              next = child._next;
          if (prev) {
              prev._next = next
          } else if (parent[firstProp] === child) {
              parent[firstProp] = next
          }
          if (next) {
              next._prev = prev
          } else if (parent[lastProp] === child) {
              parent[lastProp] = prev
          }
          child._next = child._prev = child.parent = null
      },
      _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
          child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
          child._act = 0
      },
      _uncache = function _uncache(animation, child) {
          if (animation && (!child || child._end > animation._dur || child._start < 0)) {
              var a = animation;
              while (a) {
                  a._dirty = 1;
                  a = a.parent
              }
          }
          return animation
      },
      _recacheAncestors = function _recacheAncestors(animation) {
          var parent = animation.parent;
          while (parent && parent.parent) {
              parent._dirty = 1;
              parent.totalDuration();
              parent = parent.parent
          }
          return animation
      },
      _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
          return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force))
      },
      _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
          return !animation || animation._ts && _hasNoPausedAncestors(animation.parent)
      },
      _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
          return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0
      },
      _animationCycle = function _animationCycle(tTime, cycleDuration) {
          var whole = Math.floor(tTime /= cycleDuration);
          return tTime && whole === tTime ? whole - 1 : whole
      },
      _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
          return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur)
      },
      _setEnd = function _setEnd(animation) {
          return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0))
      },
      _alignPlayhead = function _alignPlayhead(animation, totalTime) {
          var parent = animation._dp;
          if (parent && parent.smoothChildTiming && animation._ts) {
              animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
              _setEnd(animation);
              parent._dirty || _uncache(parent, animation)
          }
          return animation
      },
      _postAddChecks = function _postAddChecks(timeline, child) {
          var t;
          if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
              t = _parentToChildTotalTime(timeline.rawTime(), child);
              if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
                  child.render(t, true)
              }
          }
          if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
              if (timeline._dur < timeline.duration()) {
                  t = timeline;
                  while (t._dp) {
                      t.rawTime() >= 0 && t.totalTime(t._tTime);
                      t = t._dp
                  }
              }
              timeline._zTime = -_tinyNum
          }
      },
      _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
          child.parent && _removeFromParent(child);
          child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
          child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
          _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
          _isFromOrFromStart(child) || (timeline._recent = child);
          skipChecks || _postAddChecks(timeline, child);
          timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
          return timeline
      },
      _scrollTrigger = function _scrollTrigger(animation, trigger) {
          return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation)
      },
      _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
          _initTween(tween, time, tTime);
          if (!tween._initted) {
              return 1
          }
          if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
              _lazyTweens.push(tween);
              tween._lazy = [tTime, suppressEvents];
              return 1
          }
      },
      _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
          var parent = _ref.parent;
          return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent))
      },
      _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
          var data = _ref2.data;
          return data === "isFromStart" || data === "isStart"
      },
      _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
          var prevRatio = tween.ratio,
              ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
              repeatDelay = tween._rDelay,
              tTime = 0,
              pt, iteration, prevIteration;
          if (repeatDelay && tween._repeat) {
              tTime = _clamp(0, tween._tDur, totalTime);
              iteration = _animationCycle(tTime, repeatDelay);
              tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
              if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
                  prevRatio = 1 - ratio;
                  tween.vars.repeatRefresh && tween._initted && tween.invalidate()
              }
          }
          if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
              if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
                  return
              }
              prevIteration = tween._zTime;
              tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
              suppressEvents || (suppressEvents = totalTime && !prevIteration);
              tween.ratio = ratio;
              tween._from && (ratio = 1 - ratio);
              tween._time = 0;
              tween._tTime = tTime;
              pt = tween._pt;
              while (pt) {
                  pt.r(ratio, pt.d);
                  pt = pt._next
              }
              totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
              tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
              tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
              if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
                  ratio && _removeFromParent(tween, 1);
                  if (!suppressEvents && !_reverting) {
                      _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
                      tween._prom && tween._prom()
                  }
              }
          } else if (!tween._zTime) {
              tween._zTime = totalTime
          }
      },
      _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
          var child;
          if (time > prevTime) {
              child = animation._first;
              while (child && child._start <= time) {
                  if (child.data === "isPause" && child._start > prevTime) {
                      return child
                  }
                  child = child._next
              }
          } else {
              child = animation._last;
              while (child && child._start >= time) {
                  if (child.data === "isPause" && child._start < prevTime) {
                      return child
                  }
                  child = child._prev
              }
          }
      },
      _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
          var repeat = animation._repeat,
              dur = _roundPrecise(duration) || 0,
              totalProgress = animation._tTime / animation._tDur;
          totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
          animation._dur = dur;
          animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
          totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
          animation.parent && _setEnd(animation);
          skipUncache || _uncache(animation.parent, animation);
          return animation
      },
      _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
          return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur)
      },
      _zeroPosition = {
          _start: 0,
          endTime: _emptyFunc,
          totalDuration: _emptyFunc
      },
      _parsePosition = function _parsePosition(animation, position, percentAnimation) {
          var labels = animation.labels,
              recent = animation._recent || _zeroPosition,
              clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
              i, offset, isPercent;
          if (_isString(position) && (isNaN(position) || position in labels)) {
              offset = position.charAt(0);
              isPercent = position.substr(-1) === "%";
              i = position.indexOf("=");
              if (offset === "<" || offset === ">") {
                  i >= 0 && (position = position.replace(/=/, ""));
                  return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1)
              }
              if (i < 0) {
                  position in labels || (labels[position] = clippedDuration);
                  return labels[position]
              }
              offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
              if (isPercent && percentAnimation) {
                  offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration()
              }
              return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset
          }
          return position == null ? clippedDuration : +position
      },
      _createTweenType = function _createTweenType(type, params, timeline) {
          var isLegacy = _isNumber(params[1]),
              varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
              vars = params[varsIndex],
              irVars, parent;
          isLegacy && (vars.duration = params[1]);
          vars.parent = timeline;
          if (type) {
              irVars = vars;
              parent = timeline;
              while (parent && !("immediateRender" in irVars)) {
                  irVars = parent.vars.defaults || {};
                  parent = _isNotFalse(parent.vars.inherit) && parent.parent
              }
              vars.immediateRender = _isNotFalse(irVars.immediateRender);
              type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]
          }
          return new Tween(params[0], vars, params[varsIndex + 1])
      },
      _conditionalReturn = function _conditionalReturn(value, func) {
          return value || value === 0 ? func(value) : func
      },
      _clamp = function _clamp(min, max, value) {
          return value < min ? min : value > max ? max : value
      },
      getUnit = function getUnit(value, v) {
          return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1]
      },
      clamp = function clamp(min, max, value) {
          return _conditionalReturn(value, function(v) {
              return _clamp(min, max, v)
          })
      },
      _slice = [].slice,
      _isArrayLike = function _isArrayLike(value, nonEmpty) {
          return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win
      },
      _flatten = function _flatten(ar, leaveStrings, accumulator) {
          if (accumulator === void 0) {
              accumulator = []
          }
          return ar.forEach(function(value) {
              var _accumulator;
              return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value)
          }) || accumulator
      },
      toArray = function toArray(value, scope, leaveStrings) {
          return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : []
      },
      selector = function selector(value) {
          value = toArray(value)[0] || _warn("Invalid scope") || {};
          return function(v) {
              var el = value.current || value.nativeElement || value;
              return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value)
          }
      },
      shuffle = function shuffle(a) {
          return a.sort(function() {
              return .5 - Math.random()
          })
      },
      distribute = function distribute(v) {
          if (_isFunction(v)) {
              return v
          }
          var vars = _isObject(v) ? v : {
                  each: v
              },
              ease = _parseEase(vars.ease),
              from = vars.from || 0,
              base = parseFloat(vars.base) || 0,
              cache = {},
              isDecimal = from > 0 && from < 1,
              ratios = isNaN(from) || isDecimal,
              axis = vars.axis,
              ratioX = from,
              ratioY = from;
          if (_isString(from)) {
              ratioX = ratioY = {
                  center: .5,
                  edges: .5,
                  end: 1
              } [from] || 0
          } else if (!isDecimal && ratios) {
              ratioX = from[0];
              ratioY = from[1]
          }
          return function(i, target, a) {
              var l = (a || vars).length,
                  distances = cache[l],
                  originX, originY, x, y, d, j, max, min, wrapAt;
              if (!distances) {
                  wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
                  if (!wrapAt) {
                      max = -_bigNum;
                      while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
                      wrapAt < l && wrapAt--
                  }
                  distances = cache[l] = [];
                  originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
                  originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
                  max = 0;
                  min = _bigNum;
                  for (j = 0; j < l; j++) {
                      x = j % wrapAt - originX;
                      y = originY - (j / wrapAt | 0);
                      distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
                      d > max && (max = d);
                      d < min && (min = d)
                  }
                  from === "random" && shuffle(distances);
                  distances.max = max - min;
                  distances.min = min;
                  distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
                  distances.b = l < 0 ? base - l : base;
                  distances.u = getUnit(vars.amount || vars.each) || 0;
                  ease = ease && l < 0 ? _invertEase(ease) : ease
              }
              l = (distances[i] - distances.min) / distances.max || 0;
              return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u
          }
      },
      _roundModifier = function _roundModifier(v) {
          var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
          return function(raw) {
              var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
              return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw))
          }
      },
      snap = function snap(snapTo, value) {
          var isArray = _isArray(snapTo),
              radius, is2D;
          if (!isArray && _isObject(snapTo)) {
              radius = isArray = snapTo.radius || _bigNum;
              if (snapTo.values) {
                  snapTo = toArray(snapTo.values);
                  if (is2D = !_isNumber(snapTo[0])) {
                      radius *= radius
                  }
              } else {
                  snapTo = _roundModifier(snapTo.increment)
              }
          }
          return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
              is2D = snapTo(raw);
              return Math.abs(is2D - raw) <= radius ? is2D : raw
          } : function(raw) {
              var x = parseFloat(is2D ? raw.x : raw),
                  y = parseFloat(is2D ? raw.y : 0),
                  min = _bigNum,
                  closest = 0,
                  i = snapTo.length,
                  dx, dy;
              while (i--) {
                  if (is2D) {
                      dx = snapTo[i].x - x;
                      dy = snapTo[i].y - y;
                      dx = dx * dx + dy * dy
                  } else {
                      dx = Math.abs(snapTo[i] - x)
                  }
                  if (dx < min) {
                      min = dx;
                      closest = i
                  }
              }
              closest = !radius || min <= radius ? snapTo[closest] : raw;
              return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw)
          })
      },
      random = function random(min, max, roundingIncrement, returnFunction) {
          return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
              return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction
          })
      },
      pipe = function pipe() {
          for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
              functions[_key] = arguments[_key]
          }
          return function(value) {
              return functions.reduce(function(v, f) {
                  return f(v)
              }, value)
          }
      },
      unitize = function unitize(func, unit) {
          return function(value) {
              return func(parseFloat(value)) + (unit || getUnit(value))
          }
      },
      normalize = function normalize(min, max, value) {
          return mapRange(min, max, 0, 1, value)
      },
      _wrapArray = function _wrapArray(a, wrapper, value) {
          return _conditionalReturn(value, function(index) {
              return a[~~wrapper(index)]
          })
      },
      wrap = function wrap(min, max, value) {
          var range = max - min;
          return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {
              return (range + (value - min) % range) % range + min
          })
      },
      wrapYoyo = function wrapYoyo(min, max, value) {
          var range = max - min,
              total = range * 2;
          return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {
              value = (total + (value - min) % total) % total || 0;
              return min + (value > range ? total - value : value)
          })
      },
      _replaceRandom = function _replaceRandom(value) {
          var prev = 0,
              s = "",
              i, nums, end, isArray;
          while (~(i = value.indexOf("random(", prev))) {
              end = value.indexOf(")", i);
              isArray = value.charAt(i + 7) === "[";
              nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
              s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
              prev = end + 1
          }
          return s + value.substr(prev, value.length - prev)
      },
      mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
          var inRange = inMax - inMin,
              outRange = outMax - outMin;
          return _conditionalReturn(value, function(value) {
              return outMin + ((value - inMin) / inRange * outRange || 0)
          })
      },
      interpolate = function interpolate(start, end, progress, mutate) {
          var func = isNaN(start + end) ? 0 : function(p) {
              return (1 - p) * start + p * end
          };
          if (!func) {
              var isString = _isString(start),
                  master = {},
                  p, i, interpolators, l, il;
              progress === true && (mutate = 1) && (progress = null);
              if (isString) {
                  start = {
                      p: start
                  };
                  end = {
                      p: end
                  }
              } else if (_isArray(start) && !_isArray(end)) {
                  interpolators = [];
                  l = start.length;
                  il = l - 2;
                  for (i = 1; i < l; i++) {
                      interpolators.push(interpolate(start[i - 1], start[i]))
                  }
                  l--;
                  func = function func(p) {
                      p *= l;
                      var i = Math.min(il, ~~p);
                      return interpolators[i](p - i)
                  };
                  progress = end
              } else if (!mutate) {
                  start = _merge(_isArray(start) ? [] : {}, start)
              }
              if (!interpolators) {
                  for (p in end) {
                      _addPropTween.call(master, start, p, "get", end[p])
                  }
                  func = function func(p) {
                      return _renderPropTweens(p, master) || (isString ? start.p : start)
                  }
              }
          }
          return _conditionalReturn(progress, func)
      },
      _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
          var labels = timeline.labels,
              min = _bigNum,
              p, distance, label;
          for (p in labels) {
              distance = labels[p] - fromTime;
              if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
                  label = p;
                  min = distance
              }
          }
          return label
      },
      _callback = function _callback(animation, type, executeLazyFirst) {
          var v = animation.vars,
              callback = v[type],
              prevContext = _context,
              context = animation._ctx,
              params, scope, result;
          if (!callback) {
              return
          }
          params = v[type + "Params"];
          scope = v.callbackScope || animation;
          executeLazyFirst && _lazyTweens.length && _lazyRender();
          context && (_context = context);
          result = params ? callback.apply(scope, params) : callback.call(scope);
          _context = prevContext;
          return result
      },
      _interrupt = function _interrupt(animation) {
          _removeFromParent(animation);
          animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
          animation.progress() < 1 && _callback(animation, "onInterrupt");
          return animation
      },
      _quickTween, _registerPluginQueue = [],
      _createPlugin = function _createPlugin(config) {
          if (_windowExists() && config) {
              config = !config.name && config["default"] || config;
              var name = config.name,
                  isFunc = _isFunction(config),
                  Plugin = name && !isFunc && config.init ? function() {
                      this._props = []
                  } : config,
                  instanceDefaults = {
                      init: _emptyFunc,
                      render: _renderPropTweens,
                      add: _addPropTween,
                      kill: _killPropTweensOf,
                      modifier: _addPluginModifier,
                      rawVars: 0
                  },
                  statics = {
                      targetTest: 0,
                      get: 0,
                      getSetter: _getSetter,
                      aliases: {},
                      register: 0
                  };
              _wake();
              if (config !== Plugin) {
                  if (_plugins[name]) {
                      return
                  }
                  _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
                  _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
                  _plugins[Plugin.prop = name] = Plugin;
                  if (config.targetTest) {
                      _harnessPlugins.push(Plugin);
                      _reservedProps[name] = 1
                  }
                  name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"
              }
              _addGlobal(name, Plugin);
              config.register && config.register(gsap, Plugin, PropTween)
          } else {
              config && _registerPluginQueue.push(config)
          }
      },
      _255 = 255,
      _colorLookup = {
          aqua: [0, _255, _255],
          lime: [0, _255, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, _255],
          navy: [0, 0, 128],
          white: [_255, _255, _255],
          olive: [128, 128, 0],
          yellow: [_255, _255, 0],
          orange: [_255, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [_255, 0, 0],
          pink: [_255, 192, 203],
          cyan: [0, _255, _255],
          transparent: [_255, _255, _255, 0]
      },
      _hue = function _hue(h, m1, m2) {
          h += h < 0 ? 1 : h > 1 ? -1 : 0;
          return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0
      },
      splitColor = function splitColor(v, toHSL, forceAlpha) {
          var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
              r, g, b, h, s, l, max, min, d, wasHSL;
          if (!a) {
              if (v.substr(-1) === ",") {
                  v = v.substr(0, v.length - 1)
              }
              if (_colorLookup[v]) {
                  a = _colorLookup[v]
              } else if (v.charAt(0) === "#") {
                  if (v.length < 6) {
                      r = v.charAt(1);
                      g = v.charAt(2);
                      b = v.charAt(3);
                      v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "")
                  }
                  if (v.length === 9) {
                      a = parseInt(v.substr(1, 6), 16);
                      return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255]
                  }
                  v = parseInt(v.substr(1), 16);
                  a = [v >> 16, v >> 8 & _255, v & _255]
              } else if (v.substr(0, 3) === "hsl") {
                  a = wasHSL = v.match(_strictNumExp);
                  if (!toHSL) {
                      h = +a[0] % 360 / 360;
                      s = +a[1] / 100;
                      l = +a[2] / 100;
                      g = l <= .5 ? l * (s + 1) : l + s - l * s;
                      r = l * 2 - g;
                      a.length > 3 && (a[3] *= 1);
                      a[0] = _hue(h + 1 / 3, r, g);
                      a[1] = _hue(h, r, g);
                      a[2] = _hue(h - 1 / 3, r, g)
                  } else if (~v.indexOf("=")) {
                      a = v.match(_numExp);
                      forceAlpha && a.length < 4 && (a[3] = 1);
                      return a
                  }
              } else {
                  a = v.match(_strictNumExp) || _colorLookup.transparent
              }
              a = a.map(Number)
          }
          if (toHSL && !wasHSL) {
              r = a[0] / _255;
              g = a[1] / _255;
              b = a[2] / _255;
              max = Math.max(r, g, b);
              min = Math.min(r, g, b);
              l = (max + min) / 2;
              if (max === min) {
                  h = s = 0
              } else {
                  d = max - min;
                  s = l > .5 ? d / (2 - max - min) : d / (max + min);
                  h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                  h *= 60
              }
              a[0] = ~~(h + .5);
              a[1] = ~~(s * 100 + .5);
              a[2] = ~~(l * 100 + .5)
          }
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a
      },
      _colorOrderData = function _colorOrderData(v) {
          var values = [],
              c = [],
              i = -1;
          v.split(_colorExp).forEach(function(v) {
              var a = v.match(_numWithUnitExp) || [];
              values.push.apply(values, a);
              c.push(i += a.length + 1)
          });
          values.c = c;
          return values
      },
      _formatColors = function _formatColors(s, toHSL, orderMatchData) {
          var result = "",
              colors = (s + result).match(_colorExp),
              type = toHSL ? "hsla(" : "rgba(",
              i = 0,
              c, shell, d, l;
          if (!colors) {
              return s
          }
          colors = colors.map(function(color) {
              return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")"
          });
          if (orderMatchData) {
              d = _colorOrderData(s);
              c = orderMatchData.c;
              if (c.join(result) !== d.c.join(result)) {
                  shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
                  l = shell.length - 1;
                  for (; i < l; i++) {
                      result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift())
                  }
              }
          }
          if (!shell) {
              shell = s.split(_colorExp);
              l = shell.length - 1;
              for (; i < l; i++) {
                  result += shell[i] + colors[i]
              }
          }
          return result + shell[l]
      },
      _colorExp = function() {
          var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
              p;
          for (p in _colorLookup) {
              s += "|" + p + "\\b"
          }
          return new RegExp(s + ")", "gi")
      }(),
      _hslExp = /hsl[a]?\(/,
      _colorStringFilter = function _colorStringFilter(a) {
          var combined = a.join(" "),
              toHSL;
          _colorExp.lastIndex = 0;
          if (_colorExp.test(combined)) {
              toHSL = _hslExp.test(combined);
              a[1] = _formatColors(a[1], toHSL);
              a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
              return true
          }
      },
      _tickerActive, _ticker = function() {
          var _getTime = Date.now,
              _lagThreshold = 500,
              _adjustedLag = 33,
              _startTime = _getTime(),
              _lastUpdate = _startTime,
              _gap = 1e3 / 240,
              _nextTime = _gap,
              _listeners = [],
              _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {
                  var elapsed = _getTime() - _lastUpdate,
                      manual = v === true,
                      overlap, dispatch, time, frame;
                  elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
                  _lastUpdate += elapsed;
                  time = _lastUpdate - _startTime;
                  overlap = time - _nextTime;
                  if (overlap > 0 || manual) {
                      frame = ++_self.frame;
                      _delta = time - _self.time * 1e3;
                      _self.time = time = time / 1e3;
                      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
                      dispatch = 1
                  }
                  manual || (_id = _req(_tick));
                  if (dispatch) {
                      for (_i = 0; _i < _listeners.length; _i++) {
                          _listeners[_i](time, _delta, frame, v)
                      }
                  }
              };
          _self = {
              time: 0,
              frame: 0,
              tick: function tick() {
                  _tick(true)
              },
              deltaRatio: function deltaRatio(fps) {
                  return _delta / (1e3 / (fps || 60))
              },
              wake: function wake() {
                  if (_coreReady) {
                      if (!_coreInitted && _windowExists()) {
                          _win = _coreInitted = window;
                          _doc = _win.document || {};
                          _globals.gsap = gsap;
                          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                          _raf = _win.requestAnimationFrame;
                          _registerPluginQueue.forEach(_createPlugin)
                      }
                      _id && _self.sleep();
                      _req = _raf || function(f) {
                          return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0)
                      };
                      _tickerActive = 1;
                      _tick(2)
                  }
              },
              sleep: function sleep() {
                  (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
                  _tickerActive = 0;
                  _req = _emptyFunc
              },
              lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                  _lagThreshold = threshold || Infinity;
                  _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold)
              },
              fps: function fps(_fps) {
                  _gap = 1e3 / (_fps || 240);
                  _nextTime = _self.time * 1e3 + _gap
              },
              add: function add(callback, once, prioritize) {
                  var func = once ? function(t, d, f, v) {
                      callback(t, d, f, v);
                      _self.remove(func)
                  } : callback;
                  _self.remove(callback);
                  _listeners[prioritize ? "unshift" : "push"](func);
                  _wake();
                  return func
              },
              remove: function remove(callback, i) {
                  ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--
              },
              _listeners: _listeners
          };
          return _self
      }(),
      _wake = function _wake() {
          return !_tickerActive && _ticker.wake()
      },
      _easeMap = {},
      _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
      _quotesExp = /["']/g,
      _parseObjectInString = function _parseObjectInString(value) {
          var obj = {},
              split = value.substr(1, value.length - 3).split(":"),
              key = split[0],
              i = 1,
              l = split.length,
              index, val, parsedVal;
          for (; i < l; i++) {
              val = split[i];
              index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
              parsedVal = val.substr(0, index);
              obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
              key = val.substr(index + 1).trim()
          }
          return obj
      },
      _valueInParentheses = function _valueInParentheses(value) {
          var open = value.indexOf("(") + 1,
              close = value.indexOf(")"),
              nested = value.indexOf("(", open);
          return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close)
      },
      _configEaseFromString = function _configEaseFromString(name) {
          var split = (name + "").split("("),
              ease = _easeMap[split[0]];
          return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease
      },
      _invertEase = function _invertEase(ease) {
          return function(p) {
              return 1 - ease(1 - p)
          }
      },
      _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
          var child = timeline._first,
              ease;
          while (child) {
              if (child instanceof Timeline) {
                  _propagateYoyoEase(child, isYoyo)
              } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
                  if (child.timeline) {
                      _propagateYoyoEase(child.timeline, isYoyo)
                  } else {
                      ease = child._ease;
                      child._ease = child._yEase;
                      child._yEase = ease;
                      child._yoyo = isYoyo
                  }
              }
              child = child._next
          }
      },
      _parseEase = function _parseEase(ease, defaultEase) {
          return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase
      },
      _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
          if (easeOut === void 0) {
              easeOut = function easeOut(p) {
                  return 1 - easeIn(1 - p)
              }
          }
          if (easeInOut === void 0) {
              easeInOut = function easeInOut(p) {
                  return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2
              }
          }
          var ease = {
                  easeIn: easeIn,
                  easeOut: easeOut,
                  easeInOut: easeInOut
              },
              lowercaseName;
          _forEachName(names, function(name) {
              _easeMap[name] = _globals[name] = ease;
              _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
              for (var p in ease) {
                  _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p]
              }
          });
          return ease
      },
      _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
          return function(p) {
              return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2
          }
      },
      _configElastic = function _configElastic(type, amplitude, period) {
          var p1 = amplitude >= 1 ? amplitude : 1,
              p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
              p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
              easeOut = function easeOut(p) {
                  return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1
              },
              ease = type === "out" ? easeOut : type === "in" ? function(p) {
                  return 1 - easeOut(1 - p)
              } : _easeInOutFromOut(easeOut);
          p2 = _2PI / p2;
          ease.config = function(amplitude, period) {
              return _configElastic(type, amplitude, period)
          };
          return ease
      },
      _configBack = function _configBack(type, overshoot) {
          if (overshoot === void 0) {
              overshoot = 1.70158
          }
          var easeOut = function easeOut(p) {
                  return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0
              },
              ease = type === "out" ? easeOut : type === "in" ? function(p) {
                  return 1 - easeOut(1 - p)
              } : _easeInOutFromOut(easeOut);
          ease.config = function(overshoot) {
              return _configBack(type, overshoot)
          };
          return ease
      };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
      var power = i < 5 ? i + 1 : i;
      _insertEase(name + ",Power" + (power - 1), i ? function(p) {
          return Math.pow(p, power)
      } : function(p) {
          return p
      }, function(p) {
          return 1 - Math.pow(1 - p, power)
      }, function(p) {
          return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2
      })
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n, c) {
      var n1 = 1 / c,
          n2 = 2 * n1,
          n3 = 2.5 * n1,
          easeOut = function easeOut(p) {
              return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375
          };
      _insertEase("Bounce", function(p) {
          return 1 - easeOut(1 - p)
      }, easeOut)
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
      return p ? Math.pow(2, 10 * (p - 1)) : 0
  });
  _insertEase("Circ", function(p) {
      return -(_sqrt(1 - p * p) - 1)
  });
  _insertEase("Sine", function(p) {
      return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
          if (steps === void 0) {
              steps = 1
          }
          var p1 = 1 / steps,
              p2 = steps + (immediateStart ? 0 : 1),
              p3 = immediateStart ? 1 : 0,
              max = 1 - _tinyNum;
          return function(p) {
              return ((p2 * _clamp(0, max, p) | 0) + p3) * p1
          }
      }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
      return _callbackNames += name + "," + name + "Params,"
  });
  var GSCache = function GSCache(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter
  };
  var Animation = function() {
      function Animation(vars) {
          this.vars = vars;
          this._delay = +vars.delay || 0;
          if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
              this._rDelay = vars.repeatDelay || 0;
              this._yoyo = !!vars.yoyo || !!vars.yoyoEase
          }
          this._ts = 1;
          _setDuration(this, +vars.duration, 1, 1);
          this.data = vars.data;
          if (_context) {
              this._ctx = _context;
              _context.data.push(this)
          }
          _tickerActive || _ticker.wake()
      }
      var _proto = Animation.prototype;
      _proto.delay = function delay(value) {
          if (value || value === 0) {
              this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
              this._delay = value;
              return this
          }
          return this._delay
      };
      _proto.duration = function duration(value) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur
      };
      _proto.totalDuration = function totalDuration(value) {
          if (!arguments.length) {
              return this._tDur
          }
          this._dirty = 0;
          return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1))
      };
      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
          _wake();
          if (!arguments.length) {
              return this._tTime
          }
          var parent = this._dp;
          if (parent && parent.smoothChildTiming && this._ts) {
              _alignPlayhead(this, _totalTime);
              !parent._dp || parent.parent || _postAddChecks(parent, this);
              while (parent && parent.parent) {
                  if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                      parent.totalTime(parent._tTime, true)
                  }
                  parent = parent.parent
              }
              if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
                  _addToTimeline(this._dp, this, this._start - this._delay)
              }
          }
          if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
              this._ts || (this._pTime = _totalTime);
              _lazySafeRender(this, _totalTime, suppressEvents)
          }
          return this
      };
      _proto.time = function time(value, suppressEvents) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time
      };
      _proto.totalProgress = function totalProgress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
      };
      _proto.progress = function progress(value, suppressEvents) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
      };
      _proto.iteration = function iteration(value, suppressEvents) {
          var cycleDuration = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1
      };
      _proto.timeScale = function timeScale(value, suppressEvents) {
          if (!arguments.length) {
              return this._rts === -_tinyNum ? 0 : this._rts
          }
          if (this._rts === value) {
              return this
          }
          var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
          this._rts = +value || 0;
          this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
          this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
          _setEnd(this);
          return _recacheAncestors(this)
      };
      _proto.paused = function paused(value) {
          if (!arguments.length) {
              return this._ps
          }
          if (this._ps !== value) {
              this._ps = value;
              if (value) {
                  this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
                  this._ts = this._act = 0
              } else {
                  _wake();
                  this._ts = this._rts;
                  this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum))
              }
          }
          return this
      };
      _proto.startTime = function startTime(value) {
          if (arguments.length) {
              this._start = value;
              var parent = this.parent || this._dp;
              parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
              return this
          }
          return this._start
      };
      _proto.endTime = function endTime(includeRepeats) {
          return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
      };
      _proto.rawTime = function rawTime(wrapRepeats) {
          var parent = this.parent || this._dp;
          return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this)
      };
      _proto.revert = function revert(config) {
          if (config === void 0) {
              config = _revertConfig
          }
          var prevIsReverting = _reverting;
          _reverting = config;
          if (this._initted || this._startAt) {
              this.timeline && this.timeline.revert(config);
              this.totalTime(-.01, config.suppressEvents)
          }
          this.data !== "nested" && config.kill !== false && this.kill();
          _reverting = prevIsReverting;
          return this
      };
      _proto.globalTime = function globalTime(rawTime) {
          var animation = this,
              time = arguments.length ? rawTime : animation.rawTime();
          while (animation) {
              time = animation._start + time / (Math.abs(animation._ts) || 1);
              animation = animation._dp
          }
          return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time
      };
      _proto.repeat = function repeat(value) {
          if (arguments.length) {
              this._repeat = value === Infinity ? -2 : value;
              return _onUpdateTotalDuration(this)
          }
          return this._repeat === -2 ? Infinity : this._repeat
      };
      _proto.repeatDelay = function repeatDelay(value) {
          if (arguments.length) {
              var time = this._time;
              this._rDelay = value;
              _onUpdateTotalDuration(this);
              return time ? this.time(time) : this
          }
          return this._rDelay
      };
      _proto.yoyo = function yoyo(value) {
          if (arguments.length) {
              this._yoyo = value;
              return this
          }
          return this._yoyo
      };
      _proto.seek = function seek(position, suppressEvents) {
          return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents))
      };
      _proto.restart = function restart(includeDelay, suppressEvents) {
          return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents))
      };
      _proto.play = function play(from, suppressEvents) {
          from != null && this.seek(from, suppressEvents);
          return this.reversed(false).paused(false)
      };
      _proto.reverse = function reverse(from, suppressEvents) {
          from != null && this.seek(from || this.totalDuration(), suppressEvents);
          return this.reversed(true).paused(false)
      };
      _proto.pause = function pause(atTime, suppressEvents) {
          atTime != null && this.seek(atTime, suppressEvents);
          return this.paused(true)
      };
      _proto.resume = function resume() {
          return this.paused(false)
      };
      _proto.reversed = function reversed(value) {
          if (arguments.length) {
              !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
              return this
          }
          return this._rts < 0
      };
      _proto.invalidate = function invalidate() {
          this._initted = this._act = 0;
          this._zTime = -_tinyNum;
          return this
      };
      _proto.isActive = function isActive() {
          var parent = this.parent || this._dp,
              start = this._start,
              rawTime;
          return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum)
      };
      _proto.eventCallback = function eventCallback(type, callback, params) {
          var vars = this.vars;
          if (arguments.length > 1) {
              if (!callback) {
                  delete vars[type]
              } else {
                  vars[type] = callback;
                  params && (vars[type + "Params"] = params);
                  type === "onUpdate" && (this._onUpdate = callback)
              }
              return this
          }
          return vars[type]
      };
      _proto.then = function then(onFulfilled) {
          var self = this;
          return new Promise(function(resolve) {
              var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
                  _resolve = function _resolve() {
                      var _then = self.then;
                      self.then = null;
                      _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
                      resolve(f);
                      self.then = _then
                  };
              if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
                  _resolve()
              } else {
                  self._prom = _resolve
              }
          })
      };
      _proto.kill = function kill() {
          _interrupt(this)
      };
      return Animation
  }();
  _setDefaults(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
  });
  var Timeline = function(_Animation) {
      _inheritsLoose(Timeline, _Animation);

      function Timeline(vars, position) {
          var _this;
          if (vars === void 0) {
              vars = {}
          }
          _this = _Animation.call(this, vars) || this;
          _this.labels = {};
          _this.smoothChildTiming = !!vars.smoothChildTiming;
          _this.autoRemoveChildren = !!vars.autoRemoveChildren;
          _this._sort = _isNotFalse(vars.sortChildren);
          _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
          vars.reversed && _this.reverse();
          vars.paused && _this.paused(true);
          vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
          return _this
      }
      var _proto2 = Timeline.prototype;
      _proto2.to = function to(targets, vars, position) {
          _createTweenType(0, arguments, this);
          return this
      };
      _proto2.from = function from(targets, vars, position) {
          _createTweenType(1, arguments, this);
          return this
      };
      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
          _createTweenType(2, arguments, this);
          return this
      };
      _proto2.set = function set(targets, vars, position) {
          vars.duration = 0;
          vars.parent = this;
          _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
          vars.immediateRender = !!vars.immediateRender;
          new Tween(targets, vars, _parsePosition(this, position), 1);
          return this
      };
      _proto2.call = function call(callback, params, position) {
          return _addToTimeline(this, Tween.delayedCall(0, callback, params), position)
      };
      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.duration = duration;
          vars.stagger = vars.stagger || stagger;
          vars.onComplete = onCompleteAll;
          vars.onCompleteParams = onCompleteAllParams;
          vars.parent = this;
          new Tween(targets, vars, _parsePosition(this, position));
          return this
      };
      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
          vars.runBackwards = 1;
          _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
          return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams)
      };
      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
          toVars.startAt = fromVars;
          _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
          return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams)
      };
      _proto2.render = function render(totalTime, suppressEvents, force) {
          var prevTime = this._time,
              tDur = this._dirty ? this.totalDuration() : this._tDur,
              dur = this._dur,
              tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
              crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
              time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
          this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
          if (tTime !== this._tTime || force || crossingStart) {
              if (prevTime !== this._time && dur) {
                  tTime += this._time - prevTime;
                  totalTime += this._time - prevTime
              }
              time = tTime;
              prevStart = this._start;
              timeScale = this._ts;
              prevPaused = !timeScale;
              if (crossingStart) {
                  dur || (prevTime = this._zTime);
                  (totalTime || !suppressEvents) && (this._zTime = totalTime)
              }
              if (this._repeat) {
                  yoyo = this._yoyo;
                  cycleDuration = dur + this._rDelay;
                  if (this._repeat < -1 && totalTime < 0) {
                      return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force)
                  }
                  time = _roundPrecise(tTime % cycleDuration);
                  if (tTime === tDur) {
                      iteration = this._repeat;
                      time = dur
                  } else {
                      iteration = ~~(tTime / cycleDuration);
                      if (iteration && iteration === tTime / cycleDuration) {
                          time = dur;
                          iteration--
                      }
                      time > dur && (time = dur)
                  }
                  prevIteration = _animationCycle(this._tTime, cycleDuration);
                  !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
                  if (yoyo && iteration & 1) {
                      time = dur - time;
                      isYoyo = 1
                  }
                  if (iteration !== prevIteration && !this._lock) {
                      var rewinding = yoyo && prevIteration & 1,
                          doesWrap = rewinding === (yoyo && iteration & 1);
                      iteration < prevIteration && (rewinding = !rewinding);
                      prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
                      this._lock = 1;
                      this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                      this._tTime = tTime;
                      !suppressEvents && this.parent && _callback(this, "onRepeat");
                      this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                      if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                          return this
                      }
                      dur = this._dur;
                      tDur = this._tDur;
                      if (doesWrap) {
                          this._lock = 2;
                          prevTime = rewinding ? dur : -1e-4;
                          this.render(prevTime, true);
                          this.vars.repeatRefresh && !isYoyo && this.invalidate()
                      }
                      this._lock = 0;
                      if (!this._ts && !prevPaused) {
                          return this
                      }
                      _propagateYoyoEase(this, isYoyo)
                  }
              }
              if (this._hasPause && !this._forcing && this._lock < 2) {
                  pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
                  if (pauseTween) {
                      tTime -= time - (time = pauseTween._start)
                  }
              }
              this._tTime = tTime;
              this._time = time;
              this._act = !timeScale;
              if (!this._initted) {
                  this._onUpdate = this.vars.onUpdate;
                  this._initted = 1;
                  this._zTime = totalTime;
                  prevTime = 0
              }
              if (!prevTime && time && !suppressEvents && !iteration) {
                  _callback(this, "onStart");
                  if (this._tTime !== tTime) {
                      return this
                  }
              }
              if (time >= prevTime && totalTime >= 0) {
                  child = this._first;
                  while (child) {
                      next = child._next;
                      if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                          if (child.parent !== this) {
                              return this.render(totalTime, suppressEvents, force)
                          }
                          child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                          if (time !== this._time || !this._ts && !prevPaused) {
                              pauseTween = 0;
                              next && (tTime += this._zTime = -_tinyNum);
                              break
                          }
                      }
                      child = next
                  }
              } else {
                  child = this._last;
                  var adjustedTime = totalTime < 0 ? totalTime : time;
                  while (child) {
                      next = child._prev;
                      if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                          if (child.parent !== this) {
                              return this.render(totalTime, suppressEvents, force)
                          }
                          child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                          if (time !== this._time || !this._ts && !prevPaused) {
                              pauseTween = 0;
                              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                              break
                          }
                      }
                      child = next
                  }
              }
              if (pauseTween && !suppressEvents) {
                  this.pause();
                  pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
                  if (this._ts) {
                      this._start = prevStart;
                      _setEnd(this);
                      return this.render(totalTime, suppressEvents, force)
                  }
              }
              this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
              if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime)
                  if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts))
                      if (!this._lock) {
                          (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                          if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                              _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom()
                          }
                      }
          }
          return this
      };
      _proto2.add = function add(child, position) {
          var _this2 = this;
          _isNumber(position) || (position = _parsePosition(this, position, child));
          if (!(child instanceof Animation)) {
              if (_isArray(child)) {
                  child.forEach(function(obj) {
                      return _this2.add(obj, position)
                  });
                  return this
              }
              if (_isString(child)) {
                  return this.addLabel(child, position)
              }
              if (_isFunction(child)) {
                  child = Tween.delayedCall(0, child)
              } else {
                  return this
              }
          }
          return this !== child ? _addToTimeline(this, child, position) : this
      };
      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
          if (nested === void 0) {
              nested = true
          }
          if (tweens === void 0) {
              tweens = true
          }
          if (timelines === void 0) {
              timelines = true
          }
          if (ignoreBeforeTime === void 0) {
              ignoreBeforeTime = -_bigNum
          }
          var a = [],
              child = this._first;
          while (child) {
              if (child._start >= ignoreBeforeTime) {
                  if (child instanceof Tween) {
                      tweens && a.push(child)
                  } else {
                      timelines && a.push(child);
                      nested && a.push.apply(a, child.getChildren(true, tweens, timelines))
                  }
              }
              child = child._next
          }
          return a
      };
      _proto2.getById = function getById(id) {
          var animations = this.getChildren(1, 1, 1),
              i = animations.length;
          while (i--) {
              if (animations[i].vars.id === id) {
                  return animations[i]
              }
          }
      };
      _proto2.remove = function remove(child) {
          if (_isString(child)) {
              return this.removeLabel(child)
          }
          if (_isFunction(child)) {
              return this.killTweensOf(child)
          }
          _removeLinkedListItem(this, child);
          if (child === this._recent) {
              this._recent = this._last
          }
          return _uncache(this)
      };
      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
          if (!arguments.length) {
              return this._tTime
          }
          this._forcing = 1;
          if (!this._dp && this._ts) {
              this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts))
          }
          _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
          this._forcing = 0;
          return this
      };
      _proto2.addLabel = function addLabel(label, position) {
          this.labels[label] = _parsePosition(this, position);
          return this
      };
      _proto2.removeLabel = function removeLabel(label) {
          delete this.labels[label];
          return this
      };
      _proto2.addPause = function addPause(position, callback, params) {
          var t = Tween.delayedCall(0, callback || _emptyFunc, params);
          t.data = "isPause";
          this._hasPause = 1;
          return _addToTimeline(this, t, _parsePosition(this, position))
      };
      _proto2.removePause = function removePause(position) {
          var child = this._first;
          position = _parsePosition(this, position);
          while (child) {
              if (child._start === position && child.data === "isPause") {
                  _removeFromParent(child)
              }
              child = child._next
          }
      };
      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          var tweens = this.getTweensOf(targets, onlyActive),
              i = tweens.length;
          while (i--) {
              _overwritingTween !== tweens[i] && tweens[i].kill(targets, props)
          }
          return this
      };
      _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
          var a = [],
              parsedTargets = toArray(targets),
              child = this._first,
              isGlobalTime = _isNumber(onlyActive),
              children;
          while (child) {
              if (child instanceof Tween) {
                  if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                      a.push(child)
                  }
              } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
                  a.push.apply(a, children)
              }
              child = child._next
          }
          return a
      };
      _proto2.tweenTo = function tweenTo(position, vars) {
          vars = vars || {};
          var tl = this,
              endTime = _parsePosition(tl, position),
              _vars = vars,
              startAt = _vars.startAt,
              _onStart = _vars.onStart,
              onStartParams = _vars.onStartParams,
              immediateRender = _vars.immediateRender,
              initted, tween = Tween.to(tl, _setDefaults({
                  ease: vars.ease || "none",
                  lazy: false,
                  immediateRender: false,
                  time: endTime,
                  overwrite: "auto",
                  duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
                  onStart: function onStart() {
                      tl.pause();
                      if (!initted) {
                          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                          initted = 1
                      }
                      _onStart && _onStart.apply(tween, onStartParams || [])
                  }
              }, vars));
          return immediateRender ? tween.render(0) : tween
      };
      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
          return this.tweenTo(toPosition, _setDefaults({
              startAt: {
                  time: _parsePosition(this, fromPosition)
              }
          }, vars))
      };
      _proto2.recent = function recent() {
          return this._recent
      };
      _proto2.nextLabel = function nextLabel(afterTime) {
          if (afterTime === void 0) {
              afterTime = this._time
          }
          return _getLabelInDirection(this, _parsePosition(this, afterTime))
      };
      _proto2.previousLabel = function previousLabel(beforeTime) {
          if (beforeTime === void 0) {
              beforeTime = this._time
          }
          return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1)
      };
      _proto2.currentLabel = function currentLabel(value) {
          return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum)
      };
      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
          if (ignoreBeforeTime === void 0) {
              ignoreBeforeTime = 0
          }
          var child = this._first,
              labels = this.labels,
              p;
          while (child) {
              if (child._start >= ignoreBeforeTime) {
                  child._start += amount;
                  child._end += amount
              }
              child = child._next
          }
          if (adjustLabels) {
              for (p in labels) {
                  if (labels[p] >= ignoreBeforeTime) {
                      labels[p] += amount
                  }
              }
          }
          return _uncache(this)
      };
      _proto2.invalidate = function invalidate(soft) {
          var child = this._first;
          this._lock = 0;
          while (child) {
              child.invalidate(soft);
              child = child._next
          }
          return _Animation.prototype.invalidate.call(this, soft)
      };
      _proto2.clear = function clear(includeLabels) {
          if (includeLabels === void 0) {
              includeLabels = true
          }
          var child = this._first,
              next;
          while (child) {
              next = child._next;
              this.remove(child);
              child = next
          }
          this._dp && (this._time = this._tTime = this._pTime = 0);
          includeLabels && (this.labels = {});
          return _uncache(this)
      };
      _proto2.totalDuration = function totalDuration(value) {
          var max = 0,
              self = this,
              child = self._last,
              prevStart = _bigNum,
              prev, start, parent;
          if (arguments.length) {
              return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value))
          }
          if (self._dirty) {
              parent = self.parent;
              while (child) {
                  prev = child._prev;
                  child._dirty && child.totalDuration();
                  start = child._start;
                  if (start > prevStart && self._sort && child._ts && !self._lock) {
                      self._lock = 1;
                      _addToTimeline(self, child, start - child._delay, 1)._lock = 0
                  } else {
                      prevStart = start
                  }
                  if (start < 0 && child._ts) {
                      max -= start;
                      if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                          self._start += start / self._ts;
                          self._time -= start;
                          self._tTime -= start
                      }
                      self.shiftChildren(-start, false, -Infinity);
                      prevStart = 0
                  }
                  child._end > max && child._ts && (max = child._end);
                  child = prev
              }
              _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
              self._dirty = 0
          }
          return self._tDur
      };
      Timeline.updateRoot = function updateRoot(time) {
          if (_globalTimeline._ts) {
              _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
              _lastRenderedFrame = _ticker.frame
          }
          if (_ticker.frame >= _nextGCFrame) {
              _nextGCFrame += _config.autoSleep || 120;
              var child = _globalTimeline._first;
              if (!child || !child._ts)
                  if (_config.autoSleep && _ticker._listeners.length < 2) {
                      while (child && !child._ts) {
                          child = child._next
                      }
                      child || _ticker.sleep()
                  }
          }
      };
      return Timeline
  }(Animation);
  _setDefaults(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
          var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
              index = 0,
              matchIndex = 0,
              result, startNums, color, endNum, chunk, startNum, hasRandom, a;
          pt.b = start;
          pt.e = end;
          start += "";
          end += "";
          if (hasRandom = ~end.indexOf("random(")) {
              end = _replaceRandom(end)
          }
          if (stringFilter) {
              a = [start, end];
              stringFilter(a, target, prop);
              start = a[0];
              end = a[1]
          }
          startNums = start.match(_complexStringNumExp) || [];
          while (result = _complexStringNumExp.exec(end)) {
              endNum = result[0];
              chunk = end.substring(index, result.index);
              if (color) {
                  color = (color + 1) % 5
              } else if (chunk.substr(-5) === "rgba(") {
                  color = 1
              }
              if (endNum !== startNums[matchIndex++]) {
                  startNum = parseFloat(startNums[matchIndex - 1]) || 0;
                  pt._pt = {
                      _next: pt._pt,
                      p: chunk || matchIndex === 1 ? chunk : ",",
                      s: startNum,
                      c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                      m: color && color < 4 ? Math.round : 0
                  };
                  index = _complexStringNumExp.lastIndex
              }
          }
          pt.c = index < end.length ? end.substring(index, end.length) : "";
          pt.fp = funcParam;
          if (_relExp.test(end) || hasRandom) {
              pt.e = 0
          }
          this._pt = pt;
          return pt
      },
      _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
          _isFunction(end) && (end = end(index || 0, target, targets));
          var currentValue = target[prop],
              parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
              setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
              pt;
          if (_isString(end)) {
              if (~end.indexOf("random(")) {
                  end = _replaceRandom(end)
              }
              if (end.charAt(1) === "=") {
                  pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
                  if (pt || pt === 0) {
                      end = pt
                  }
              }
          }
          if (!optional || parsedStart !== end || _forceAllPropTweens) {
              if (!isNaN(parsedStart * end) && end !== "") {
                  pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
                  funcParam && (pt.fp = funcParam);
                  modifier && pt.modifier(modifier, this, target);
                  return this._pt = pt
              }!currentValue && !(prop in target) && _missingPlugin(prop, end);
              return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam)
          }
      },
      _processVars = function _processVars(vars, index, target, targets, tween) {
          _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
          if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
              return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars
          }
          var copy = {},
              p;
          for (p in vars) {
              copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets)
          }
          return copy
      },
      _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
          var plugin, pt, ptLookup, i;
          if (_plugins[property] && (plugin = new _plugins[property]).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
              tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
              if (tween !== _quickTween) {
                  ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
                  i = plugin._props.length;
                  while (i--) {
                      ptLookup[plugin._props[i]] = pt
                  }
              }
          }
          return plugin
      },
      _overwritingTween, _forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {
          var vars = tween.vars,
              ease = vars.ease,
              startAt = vars.startAt,
              immediateRender = vars.immediateRender,
              lazy = vars.lazy,
              onUpdate = vars.onUpdate,
              runBackwards = vars.runBackwards,
              yoyoEase = vars.yoyoEase,
              keyframes = vars.keyframes,
              autoRevert = vars.autoRevert,
              dur = tween._dur,
              prevStartAt = tween._startAt,
              targets = tween._targets,
              parent = tween.parent,
              fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
              autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
              tl = tween.timeline,
              cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
          tl && (!keyframes || !ease) && (ease = "none");
          tween._ease = _parseEase(ease, _defaults.ease);
          tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
          if (yoyoEase && tween._yoyo && !tween._repeat) {
              yoyoEase = tween._yEase;
              tween._yEase = tween._ease;
              tween._ease = yoyoEase
          }
          tween._from = !tl && !!vars.runBackwards;
          if (!tl || keyframes && !vars.stagger) {
              harness = targets[0] ? _getCache(targets[0]).harness : 0;
              harnessVars = harness && vars[harness.prop];
              cleanVars = _copyExcluding(vars, _reservedProps);
              if (prevStartAt) {
                  prevStartAt._zTime < 0 && prevStartAt.progress(1);
                  time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
                  prevStartAt._lazy = 0
              }
              if (startAt) {
                  _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                      data: "isStart",
                      overwrite: false,
                      parent: parent,
                      immediateRender: true,
                      lazy: !prevStartAt && _isNotFalse(lazy),
                      startAt: null,
                      delay: 0,
                      onUpdate: onUpdate && function() {
                          return _callback(tween, "onUpdate")
                      },
                      stagger: 0
                  }, startAt)));
                  tween._startAt._dp = 0;
                  tween._startAt._sat = tween;
                  time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
                  if (immediateRender) {
                      if (dur && time <= 0 && tTime <= 0) {
                          time && (tween._zTime = time);
                          return
                      }
                  }
              } else if (runBackwards && dur) {
                  if (!prevStartAt) {
                      time && (immediateRender = false);
                      p = _setDefaults({
                          overwrite: false,
                          data: "isFromStart",
                          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                          immediateRender: immediateRender,
                          stagger: 0,
                          parent: parent
                      }, cleanVars);
                      harnessVars && (p[harness.prop] = harnessVars);
                      _removeFromParent(tween._startAt = Tween.set(targets, p));
                      tween._startAt._dp = 0;
                      tween._startAt._sat = tween;
                      time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
                      tween._zTime = time;
                      if (!immediateRender) {
                          _initTween(tween._startAt, _tinyNum, _tinyNum)
                      } else if (!time) {
                          return
                      }
                  }
              }
              tween._pt = tween._ptCache = 0;
              lazy = dur && _isNotFalse(lazy) || lazy && !dur;
              for (i = 0; i < targets.length; i++) {
                  target = targets[i];
                  gsData = target._gsap || _harness(targets)[i]._gsap;
                  tween._ptLookup[i] = ptLookup = {};
                  _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
                  index = fullTargets === targets ? i : fullTargets.indexOf(target);
                  if (harness && (plugin = new harness).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
                      tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
                      plugin._props.forEach(function(name) {
                          ptLookup[name] = pt
                      });
                      plugin.priority && (hasPriority = 1)
                  }
                  if (!harness || harnessVars) {
                      for (p in cleanVars) {
                          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                              plugin.priority && (hasPriority = 1)
                          } else {
                              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter)
                          }
                      }
                  }
                  tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
                  if (autoOverwrite && tween._pt) {
                      _overwritingTween = tween;
                      _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
                      overwritten = !tween.parent;
                      _overwritingTween = 0
                  }
                  tween._pt && lazy && (_lazyLookup[gsData.id] = 1)
              }
              hasPriority && _sortPropTweensByPriority(tween);
              tween._onInit && tween._onInit(tween)
          }
          tween._onUpdate = onUpdate;
          tween._initted = (!tween._op || tween._pt) && !overwritten;
          keyframes && time <= 0 && tl.render(_bigNum, true, true)
      },
      _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
          var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
              pt, rootPT, lookup, i;
          if (!ptCache) {
              ptCache = tween._ptCache[property] = [];
              lookup = tween._ptLookup;
              i = tween._targets.length;
              while (i--) {
                  pt = lookup[i][property];
                  if (pt && pt.d && pt.d._pt) {
                      pt = pt.d._pt;
                      while (pt && pt.p !== property && pt.fp !== property) {
                          pt = pt._next
                      }
                  }
                  if (!pt) {
                      _forceAllPropTweens = 1;
                      tween.vars[property] = "+=0";
                      _initTween(tween, time);
                      _forceAllPropTweens = 0;
                      return skipRecursion ? _warn(property + " not eligible for reset") : 1
                  }
                  ptCache.push(pt)
              }
          }
          i = ptCache.length;
          while (i--) {
              rootPT = ptCache[i];
              pt = rootPT._pt || rootPT;
              pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
              pt.c = value - pt.s;
              rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
              rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b))
          }
      },
      _addAliasesToVars = function _addAliasesToVars(targets, vars) {
          var harness = targets[0] ? _getCache(targets[0]).harness : 0,
              propertyAliases = harness && harness.aliases,
              copy, p, i, aliases;
          if (!propertyAliases) {
              return vars
          }
          copy = _merge({}, vars);
          for (p in propertyAliases) {
              if (p in copy) {
                  aliases = propertyAliases[p].split(",");
                  i = aliases.length;
                  while (i--) {
                      copy[aliases[i]] = copy[p]
                  }
              }
          }
          return copy
      },
      _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
          var ease = obj.ease || easeEach || "power1.inOut",
              p, a;
          if (_isArray(obj)) {
              a = allProps[prop] || (allProps[prop] = []);
              obj.forEach(function(value, i) {
                  return a.push({
                      t: i / (obj.length - 1) * 100,
                      v: value,
                      e: ease
                  })
              })
          } else {
              for (p in obj) {
                  a = allProps[p] || (allProps[p] = []);
                  p === "ease" || a.push({
                      t: parseFloat(prop),
                      v: obj[p],
                      e: ease
                  })
              }
          }
      },
      _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
          return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value
      },
      _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
      _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
      return _staggerPropsToSkip[name] = 1
  });
  var Tween = function(_Animation2) {
      _inheritsLoose(Tween, _Animation2);

      function Tween(targets, vars, position, skipInherit) {
          var _this3;
          if (typeof vars === "number") {
              position.duration = vars;
              vars = position;
              position = null
          }
          _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
          var _this3$vars = _this3.vars,
              duration = _this3$vars.duration,
              delay = _this3$vars.delay,
              immediateRender = _this3$vars.immediateRender,
              stagger = _this3$vars.stagger,
              overwrite = _this3$vars.overwrite,
              keyframes = _this3$vars.keyframes,
              defaults = _this3$vars.defaults,
              scrollTrigger = _this3$vars.scrollTrigger,
              yoyoEase = _this3$vars.yoyoEase,
              parent = vars.parent || _globalTimeline,
              parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
              tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
          _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
          _this3._ptLookup = [];
          _this3._overwrite = overwrite;
          if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
              vars = _this3.vars;
              tl = _this3.timeline = new Timeline({
                  data: "nested",
                  defaults: defaults || {},
                  targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
              });
              tl.kill();
              tl.parent = tl._dp = _assertThisInitialized(_this3);
              tl._start = 0;
              if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                  l = parsedTargets.length;
                  staggerFunc = stagger && distribute(stagger);
                  if (_isObject(stagger)) {
                      for (p in stagger) {
                          if (~_staggerTweenProps.indexOf(p)) {
                              staggerVarsToMerge || (staggerVarsToMerge = {});
                              staggerVarsToMerge[p] = stagger[p]
                          }
                      }
                  }
                  for (i = 0; i < l; i++) {
                      copy = _copyExcluding(vars, _staggerPropsToSkip);
                      copy.stagger = 0;
                      yoyoEase && (copy.yoyoEase = yoyoEase);
                      staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                      curTarget = parsedTargets[i];
                      copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                      copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                      if (!stagger && l === 1 && copy.delay) {
                          _this3._delay = delay = copy.delay;
                          _this3._start += delay;
                          copy.delay = 0
                      }
                      tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
                      tl._ease = _easeMap.none
                  }
                  tl.duration() ? duration = delay = 0 : _this3.timeline = 0
              } else if (keyframes) {
                  _inheritDefaults(_setDefaults(tl.vars.defaults, {
                      ease: "none"
                  }));
                  tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                  var time = 0,
                      a, kf, v;
                  if (_isArray(keyframes)) {
                      keyframes.forEach(function(frame) {
                          return tl.to(parsedTargets, frame, ">")
                      });
                      tl.duration()
                  } else {
                      copy = {};
                      for (p in keyframes) {
                          p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach)
                      }
                      for (p in copy) {
                          a = copy[p].sort(function(a, b) {
                              return a.t - b.t
                          });
                          time = 0;
                          for (i = 0; i < a.length; i++) {
                              kf = a[i];
                              v = {
                                  ease: kf.e,
                                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                              };
                              v[p] = kf.v;
                              tl.to(parsedTargets, v, time);
                              time += v.duration
                          }
                      }
                      tl.duration() < duration && tl.to({}, {
                          duration: duration - tl.duration()
                      })
                  }
              }
              duration || _this3.duration(duration = tl.duration())
          } else {
              _this3.timeline = 0
          }
          if (overwrite === true && !_suppressOverwrites) {
              _overwritingTween = _assertThisInitialized(_this3);
              _globalTimeline.killTweensOf(parsedTargets);
              _overwritingTween = 0
          }
          _addToTimeline(parent, _assertThisInitialized(_this3), position);
          vars.reversed && _this3.reverse();
          vars.paused && _this3.paused(true);
          if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
              _this3._tTime = -_tinyNum;
              _this3.render(Math.max(0, -delay) || 0)
          }
          scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
          return _this3
      }
      var _proto3 = Tween.prototype;
      _proto3.render = function render(totalTime, suppressEvents, force) {
          var prevTime = this._time,
              tDur = this._tDur,
              dur = this._dur,
              isNegative = totalTime < 0,
              tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
              time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
          if (!dur) {
              _renderZeroDurationTween(this, totalTime, suppressEvents, force)
          } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
              time = tTime;
              timeline = this.timeline;
              if (this._repeat) {
                  cycleDuration = dur + this._rDelay;
                  if (this._repeat < -1 && isNegative) {
                      return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force)
                  }
                  time = _roundPrecise(tTime % cycleDuration);
                  if (tTime === tDur) {
                      iteration = this._repeat;
                      time = dur
                  } else {
                      iteration = ~~(tTime / cycleDuration);
                      if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
                          time = dur;
                          iteration--
                      }
                      time > dur && (time = dur)
                  }
                  isYoyo = this._yoyo && iteration & 1;
                  if (isYoyo) {
                      yoyoEase = this._yEase;
                      time = dur - time
                  }
                  prevIteration = _animationCycle(this._tTime, cycleDuration);
                  if (time === prevTime && !force && this._initted && iteration === prevIteration) {
                      this._tTime = tTime;
                      return this
                  }
                  if (iteration !== prevIteration) {
                      timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
                      if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== dur && this._initted) {
                          this._lock = force = 1;
                          this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0
                      }
                  }
              }
              if (!this._initted) {
                  if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
                      this._tTime = 0;
                      return this
                  }
                  if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
                      return this
                  }
                  if (dur !== this._dur) {
                      return this.render(totalTime, suppressEvents, force)
                  }
              }
              this._tTime = tTime;
              this._time = time;
              if (!this._act && this._ts) {
                  this._act = 1;
                  this._lazy = 0
              }
              this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
              if (this._from) {
                  this.ratio = ratio = 1 - ratio
              }
              if (time && !prevTime && !suppressEvents && !iteration) {
                  _callback(this, "onStart");
                  if (this._tTime !== tTime) {
                      return this
                  }
              }
              pt = this._pt;
              while (pt) {
                  pt.r(ratio, pt.d);
                  pt = pt._next
              }
              timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
              if (this._onUpdate && !suppressEvents) {
                  isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
                  _callback(this, "onUpdate")
              }
              this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
              if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
                  isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
                  (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                  if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
                      _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                      this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom()
                  }
              }
          }
          return this
      };
      _proto3.targets = function targets() {
          return this._targets
      };
      _proto3.invalidate = function invalidate(soft) {
          (!soft || !this.vars.runBackwards) && (this._startAt = 0);
          this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
          this._ptLookup = [];
          this.timeline && this.timeline.invalidate(soft);
          return _Animation2.prototype.invalidate.call(this, soft)
      };
      _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
          _tickerActive || _ticker.wake();
          this._ts || this.play();
          var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
              ratio;
          this._initted || _initTween(this, time);
          ratio = this._ease(time / this._dur);
          if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
              return this.resetTo(property, value, start, startIsRelative, 1)
          }
          _alignPlayhead(this, 0);
          this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
          return this.render(0)
      };
      _proto3.kill = function kill(targets, vars) {
          if (vars === void 0) {
              vars = "all"
          }
          if (!targets && (!vars || vars === "all")) {
              this._lazy = this._pt = 0;
              return this.parent ? _interrupt(this) : this
          }
          if (this.timeline) {
              var tDur = this.timeline.totalDuration();
              this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
              this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
              return this
          }
          var parsedTargets = this._targets,
              killingTargets = targets ? toArray(targets) : parsedTargets,
              propTweenLookup = this._ptLookup,
              firstPT = this._pt,
              overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
          if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
              vars === "all" && (this._pt = 0);
              return _interrupt(this)
          }
          overwrittenProps = this._op = this._op || [];
          if (vars !== "all") {
              if (_isString(vars)) {
                  p = {};
                  _forEachName(vars, function(name) {
                      return p[name] = 1
                  });
                  vars = p
              }
              vars = _addAliasesToVars(parsedTargets, vars)
          }
          i = parsedTargets.length;
          while (i--) {
              if (~killingTargets.indexOf(parsedTargets[i])) {
                  curLookup = propTweenLookup[i];
                  if (vars === "all") {
                      overwrittenProps[i] = vars;
                      props = curLookup;
                      curOverwriteProps = {}
                  } else {
                      curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                      props = vars
                  }
                  for (p in props) {
                      pt = curLookup && curLookup[p];
                      if (pt) {
                          if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                              _removeLinkedListItem(this, pt, "_pt")
                          }
                          delete curLookup[p]
                      }
                      if (curOverwriteProps !== "all") {
                          curOverwriteProps[p] = 1
                      }
                  }
              }
          }
          this._initted && !this._pt && firstPT && _interrupt(this);
          return this
      };
      Tween.to = function to(targets, vars) {
          return new Tween(targets, vars, arguments[2])
      };
      Tween.from = function from(targets, vars) {
          return _createTweenType(1, arguments)
      };
      Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
          return new Tween(callback, 0, {
              immediateRender: false,
              lazy: false,
              overwrite: false,
              delay: delay,
              onComplete: callback,
              onReverseComplete: callback,
              onCompleteParams: params,
              onReverseCompleteParams: params,
              callbackScope: scope
          })
      };
      Tween.fromTo = function fromTo(targets, fromVars, toVars) {
          return _createTweenType(2, arguments)
      };
      Tween.set = function set(targets, vars) {
          vars.duration = 0;
          vars.repeatDelay || (vars.repeat = 0);
          return new Tween(targets, vars)
      };
      Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
          return _globalTimeline.killTweensOf(targets, props, onlyActive)
      };
      return Tween
  }(Animation);
  _setDefaults(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
      Tween[name] = function() {
          var tl = new Timeline,
              params = _slice.call(arguments, 0);
          params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
          return tl[name].apply(tl, params)
      }
  });
  var _setterPlain = function _setterPlain(target, property, value) {
          return target[property] = value
      },
      _setterFunc = function _setterFunc(target, property, value) {
          return target[property](value)
      },
      _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
          return target[property](data.fp, value)
      },
      _setterAttribute = function _setterAttribute(target, property, value) {
          return target.setAttribute(property, value)
      },
      _getSetter = function _getSetter(target, property) {
          return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain
      },
      _renderPlain = function _renderPlain(ratio, data) {
          return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data)
      },
      _renderBoolean = function _renderBoolean(ratio, data) {
          return data.set(data.t, data.p, !!(data.s + data.c * ratio), data)
      },
      _renderComplexString = function _renderComplexString(ratio, data) {
          var pt = data._pt,
              s = "";
          if (!ratio && data.b) {
              s = data.b
          } else if (ratio === 1 && data.e) {
              s = data.e
          } else {
              while (pt) {
                  s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
                  pt = pt._next
              }
              s += data.c
          }
          data.set(data.t, data.p, s, data)
      },
      _renderPropTweens = function _renderPropTweens(ratio, data) {
          var pt = data._pt;
          while (pt) {
              pt.r(ratio, pt.d);
              pt = pt._next
          }
      },
      _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
          var pt = this._pt,
              next;
          while (pt) {
              next = pt._next;
              pt.p === property && pt.modifier(modifier, tween, target);
              pt = next
          }
      },
      _killPropTweensOf = function _killPropTweensOf(property) {
          var pt = this._pt,
              hasNonDependentRemaining, next;
          while (pt) {
              next = pt._next;
              if (pt.p === property && !pt.op || pt.op === property) {
                  _removeLinkedListItem(this, pt, "_pt")
              } else if (!pt.dep) {
                  hasNonDependentRemaining = 1
              }
              pt = next
          }
          return !hasNonDependentRemaining
      },
      _setterWithModifier = function _setterWithModifier(target, property, value, data) {
          data.mSet(target, property, data.m.call(data.tween, value, data.mt), data)
      },
      _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
          var pt = parent._pt,
              next, pt2, first, last;
          while (pt) {
              next = pt._next;
              pt2 = first;
              while (pt2 && pt2.pr > pt.pr) {
                  pt2 = pt2._next
              }
              if (pt._prev = pt2 ? pt2._prev : last) {
                  pt._prev._next = pt
              } else {
                  first = pt
              }
              if (pt._next = pt2) {
                  pt2._prev = pt
              } else {
                  last = pt
              }
              pt = next
          }
          parent._pt = first
      };
  var PropTween = function() {
      function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
          this.t = target;
          this.s = start;
          this.c = change;
          this.p = prop;
          this.r = renderer || _renderPlain;
          this.d = data || this;
          this.set = setter || _setterPlain;
          this.pr = priority || 0;
          this._next = next;
          if (next) {
              next._prev = this
          }
      }
      var _proto4 = PropTween.prototype;
      _proto4.modifier = function modifier(func, tween, target) {
          this.mSet = this.mSet || this.set;
          this.set = _setterWithModifier;
          this.m = func;
          this.mt = target;
          this.tween = tween
      };
      return PropTween
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
      return _reservedProps[name] = 1
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [],
      _listeners = {},
      _emptyArray = [],
      _lastMediaTime = 0,
      _contextID = 0,
      _dispatch = function _dispatch(type) {
          return (_listeners[type] || _emptyArray).map(function(f) {
              return f()
          })
      },
      _onMediaChange = function _onMediaChange() {
          var time = Date.now(),
              matches = [];
          if (time - _lastMediaTime > 2) {
              _dispatch("matchMediaInit");
              _media.forEach(function(c) {
                  var queries = c.queries,
                      conditions = c.conditions,
                      match, p, anyMatch, toggled;
                  for (p in queries) {
                      match = _win.matchMedia(queries[p]).matches;
                      match && (anyMatch = 1);
                      if (match !== conditions[p]) {
                          conditions[p] = match;
                          toggled = 1
                      }
                  }
                  if (toggled) {
                      c.revert();
                      anyMatch && matches.push(c)
                  }
              });
              _dispatch("matchMediaRevert");
              matches.forEach(function(c) {
                  return c.onMatch(c, function(func) {
                      return c.add(null, func)
                  })
              });
              _lastMediaTime = time;
              _dispatch("matchMedia")
          }
      };
  var Context = function() {
      function Context(func, scope) {
          this.selector = scope && selector(scope);
          this.data = [];
          this._r = [];
          this.isReverted = false;
          this.id = _contextID++;
          func && this.add(func)
      }
      var _proto5 = Context.prototype;
      _proto5.add = function add(name, func, scope) {
          if (_isFunction(name)) {
              scope = func;
              func = name;
              name = _isFunction
          }
          var self = this,
              f = function f() {
                  var prev = _context,
                      prevSelector = self.selector,
                      result;
                  prev && prev !== self && prev.data.push(self);
                  scope && (self.selector = selector(scope));
                  _context = self;
                  result = func.apply(self, arguments);
                  _isFunction(result) && self._r.push(result);
                  _context = prev;
                  self.selector = prevSelector;
                  self.isReverted = false;
                  return result
              };
          self.last = f;
          return name === _isFunction ? f(self, function(func) {
              return self.add(null, func)
          }) : name ? self[name] = f : f
      };
      _proto5.ignore = function ignore(func) {
          var prev = _context;
          _context = null;
          func(this);
          _context = prev
      };
      _proto5.getTweens = function getTweens() {
          var a = [];
          this.data.forEach(function(e) {
              return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e)
          });
          return a
      };
      _proto5.clear = function clear() {
          this._r.length = this.data.length = 0
      };
      _proto5.kill = function kill(revert, matchMedia) {
          var _this4 = this;
          if (revert) {
              (function() {
                  var tweens = _this4.getTweens(),
                      i = _this4.data.length,
                      t;
                  while (i--) {
                      t = _this4.data[i];
                      if (t.data === "isFlip") {
                          t.revert();
                          t.getChildren(true, true, false).forEach(function(tween) {
                              return tweens.splice(tweens.indexOf(tween), 1)
                          })
                      }
                  }
                  tweens.map(function(t) {
                      return {
                          g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
                          t: t
                      }
                  }).sort(function(a, b) {
                      return b.g - a.g || -Infinity
                  }).forEach(function(o) {
                      return o.t.revert(revert)
                  });
                  i = _this4.data.length;
                  while (i--) {
                      t = _this4.data[i];
                      if (t instanceof Timeline) {
                          if (t.data !== "nested") {
                              t.scrollTrigger && t.scrollTrigger.revert();
                              t.kill()
                          }
                      } else {
                          !(t instanceof Tween) && t.revert && t.revert(revert)
                      }
                  }
                  _this4._r.forEach(function(f) {
                      return f(revert, _this4)
                  });
                  _this4.isReverted = true
              })()
          } else {
              this.data.forEach(function(e) {
                  return e.kill && e.kill()
              })
          }
          this.clear();
          if (matchMedia) {
              var i = _media.length;
              while (i--) {
                  _media[i].id === this.id && _media.splice(i, 1)
              }
          }
      };
      _proto5.revert = function revert(config) {
          this.kill(config || {})
      };
      return Context
  }();
  var MatchMedia = function() {
      function MatchMedia(scope) {
          this.contexts = [];
          this.scope = scope
      }
      var _proto6 = MatchMedia.prototype;
      _proto6.add = function add(conditions, func, scope) {
          _isObject(conditions) || (conditions = {
              matches: conditions
          });
          var context = new Context(0, scope || this.scope),
              cond = context.conditions = {},
              mq, p, active;
          _context && !context.selector && (context.selector = _context.selector);
          this.contexts.push(context);
          func = context.add("onMatch", func);
          context.queries = conditions;
          for (p in conditions) {
              if (p === "all") {
                  active = 1
              } else {
                  mq = _win.matchMedia(conditions[p]);
                  if (mq) {
                      _media.indexOf(context) < 0 && _media.push(context);
                      (cond[p] = mq.matches) && (active = 1);
                      mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange)
                  }
              }
          }
          active && func(context, function(f) {
              return context.add(null, f)
          });
          return this
      };
      _proto6.revert = function revert(config) {
          this.kill(config || {})
      };
      _proto6.kill = function kill(revert) {
          this.contexts.forEach(function(c) {
              return c.kill(revert, true)
          })
      };
      return MatchMedia
  }();
  var _gsap = {
      registerPlugin: function registerPlugin() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2]
          }
          args.forEach(function(config) {
              return _createPlugin(config)
          })
      },
      timeline: function timeline(vars) {
          return new Timeline(vars)
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
          return _globalTimeline.getTweensOf(targets, onlyActive)
      },
      getProperty: function getProperty(target, property, unit, uncache) {
          _isString(target) && (target = toArray(target)[0]);
          var getter = _getCache(target || {}).get,
              format = unit ? _passThrough : _numericIfPossible;
          unit === "native" && (unit = "");
          return !target ? target : !property ? function(property, unit, uncache) {
              return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache))
          } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache))
      },
      quickSetter: function quickSetter(target, property, unit) {
          target = toArray(target);
          if (target.length > 1) {
              var setters = target.map(function(t) {
                      return gsap.quickSetter(t, property, unit)
                  }),
                  l = setters.length;
              return function(value) {
                  var i = l;
                  while (i--) {
                      setters[i](value)
                  }
              }
          }
          target = target[0] || {};
          var Plugin = _plugins[property],
              cache = _getCache(target),
              p = cache.harness && (cache.harness.aliases || {})[property] || property,
              setter = Plugin ? function(value) {
                  var p = new Plugin;
                  _quickTween._pt = 0;
                  p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
                  p.render(1, p);
                  _quickTween._pt && _renderPropTweens(1, _quickTween)
              } : cache.set(target, p);
          return Plugin ? setter : function(value) {
              return setter(target, p, unit ? value + unit : value, cache, 1)
          }
      },
      quickTo: function quickTo(target, property, vars) {
          var _merge2;
          var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
              func = function func(value, start, startIsRelative) {
                  return tween.resetTo(property, value, start, startIsRelative)
              };
          func.tween = tween;
          return func
      },
      isTweening: function isTweening(targets) {
          return _globalTimeline.getTweensOf(targets, true).length > 0
      },
      defaults: function defaults(value) {
          value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
          return _mergeDeep(_defaults, value || {})
      },
      config: function config(value) {
          return _mergeDeep(_config, value || {})
      },
      registerEffect: function registerEffect(_ref3) {
          var name = _ref3.name,
              effect = _ref3.effect,
              plugins = _ref3.plugins,
              defaults = _ref3.defaults,
              extendTimeline = _ref3.extendTimeline;
          (plugins || "").split(",").forEach(function(pluginName) {
              return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.")
          });
          _effects[name] = function(targets, vars, tl) {
              return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl)
          };
          if (extendTimeline) {
              Timeline.prototype[name] = function(targets, vars, position) {
                  return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position)
              }
          }
      },
      registerEase: function registerEase(name, ease) {
          _easeMap[name] = _parseEase(ease)
      },
      parseEase: function parseEase(ease, defaultEase) {
          return arguments.length ? _parseEase(ease, defaultEase) : _easeMap
      },
      getById: function getById(id) {
          return _globalTimeline.getById(id)
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
          if (vars === void 0) {
              vars = {}
          }
          var tl = new Timeline(vars),
              child, next;
          tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
          _globalTimeline.remove(tl);
          tl._dp = 0;
          tl._time = tl._tTime = _globalTimeline._time;
          child = _globalTimeline._first;
          while (child) {
              next = child._next;
              if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
                  _addToTimeline(tl, child, child._start - child._delay)
              }
              child = next
          }
          _addToTimeline(_globalTimeline, tl, 0);
          return tl
      },
      context: function context(func, scope) {
          return func ? new Context(func, scope) : _context
      },
      matchMedia: function matchMedia(scope) {
          return new MatchMedia(scope)
      },
      matchMediaRefresh: function matchMediaRefresh() {
          return _media.forEach(function(c) {
              var cond = c.conditions,
                  found, p;
              for (p in cond) {
                  if (cond[p]) {
                      cond[p] = false;
                      found = 1
                  }
              }
              found && c.revert()
          }) || _onMediaChange()
      },
      addEventListener: function addEventListener(type, callback) {
          var a = _listeners[type] || (_listeners[type] = []);
          ~a.indexOf(callback) || a.push(callback)
      },
      removeEventListener: function removeEventListener(type, callback) {
          var a = _listeners[type],
              i = a && a.indexOf(callback);
          i >= 0 && a.splice(i, 1)
      },
      utils: {
          wrap: wrap,
          wrapYoyo: wrapYoyo,
          distribute: distribute,
          random: random,
          snap: snap,
          normalize: normalize,
          getUnit: getUnit,
          clamp: clamp,
          splitColor: splitColor,
          toArray: toArray,
          selector: selector,
          mapRange: mapRange,
          pipe: pipe,
          unitize: unitize,
          interpolate: interpolate,
          shuffle: shuffle
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
          PropTween: PropTween,
          globals: _addGlobal,
          Tween: Tween,
          Timeline: Timeline,
          Animation: Animation,
          getCache: _getCache,
          _removeLinkedListItem: _removeLinkedListItem,
          reverting: function reverting() {
              return _reverting
          },
          context: function context(toAdd) {
              if (toAdd && _context) {
                  _context.data.push(toAdd);
                  toAdd._ctx = _context
              }
              return _context
          },
          suppressOverwrites: function suppressOverwrites(value) {
              return _suppressOverwrites = value
          }
      }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
      return _gsap[name] = Tween[name]
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
      duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
          var pt = plugin._pt;
          while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
              pt = pt._next
          }
          return pt
      },
      _addModifiers = function _addModifiers(tween, modifiers) {
          var targets = tween._targets,
              p, i, pt;
          for (p in modifiers) {
              i = targets.length;
              while (i--) {
                  pt = tween._ptLookup[i][p];
                  if (pt && (pt = pt.d)) {
                      if (pt._pt) {
                          pt = _getPluginPropTween(pt, p)
                      }
                      pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p)
                  }
              }
          }
      },
      _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
          return {
              name: name,
              rawVars: 1,
              init: function init(target, vars, tween) {
                  tween._onInit = function(tween) {
                      var temp, p;
                      if (_isString(vars)) {
                          temp = {};
                          _forEachName(vars, function(name) {
                              return temp[name] = 1
                          });
                          vars = temp
                      }
                      if (modifier) {
                          temp = {};
                          for (p in vars) {
                              temp[p] = modifier(vars[p])
                          }
                          vars = temp
                      }
                      _addModifiers(tween, vars)
                  }
              }
          }
      };
  var gsap = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index, targets) {
          var p, pt, v;
          this.tween = tween;
          for (p in vars) {
              v = target.getAttribute(p) || "";
              pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
              pt.op = p;
              pt.b = v;
              this._props.push(p)
          }
      },
      render: function render(ratio, data) {
          var pt = data._pt;
          while (pt) {
              _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
              pt = pt._next
          }
      }
  }, {
      name: "endArray",
      init: function init(target, value) {
          var i = value.length;
          while (i--) {
              this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1)
          }
      }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.12.4";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0,
      Power1 = _easeMap.Power1,
      Power2 = _easeMap.Power2,
      Power3 = _easeMap.Power3,
      Power4 = _easeMap.Power4,
      Linear = _easeMap.Linear,
      Quad = _easeMap.Quad,
      Cubic = _easeMap.Cubic,
      Quart = _easeMap.Quart,
      Quint = _easeMap.Quint,
      Strong = _easeMap.Strong,
      Elastic = _easeMap.Elastic,
      Back = _easeMap.Back,
      SteppedEase = _easeMap.SteppedEase,
      Bounce = _easeMap.Bounce,
      Sine = _easeMap.Sine,
      Expo = _easeMap.Expo,
      Circ = _easeMap.Circ;
  var _win$1, _doc$1, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting$1, _windowExists$1 = function _windowExists() {
          return typeof window !== "undefined"
      },
      _transformProps = {},
      _RAD2DEG = 180 / Math.PI,
      _DEG2RAD = Math.PI / 180,
      _atan2 = Math.atan2,
      _bigNum$1 = 1e8,
      _capsExp = /([A-Z])/g,
      _horizontalExp = /(left|right|width|margin|padding|x)/i,
      _complexExp = /[\s,\(]\S/,
      _propertyAliases = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity"
      },
      _renderCSSProp = function _renderCSSProp(ratio, data) {
          return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data)
      },
      _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
          return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data)
      },
      _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
          return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data)
      },
      _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
          var value = data.s + data.c * ratio;
          data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data)
      },
      _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
          return data.set(data.t, data.p, ratio ? data.e : data.b, data)
      },
      _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
          return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data)
      },
      _setterCSSStyle = function _setterCSSStyle(target, property, value) {
          return target.style[property] = value
      },
      _setterCSSProp = function _setterCSSProp(target, property, value) {
          return target.style.setProperty(property, value)
      },
      _setterTransform = function _setterTransform(target, property, value) {
          return target._gsap[property] = value
      },
      _setterScale = function _setterScale(target, property, value) {
          return target._gsap.scaleX = target._gsap.scaleY = value
      },
      _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
          var cache = target._gsap;
          cache.scaleX = cache.scaleY = value;
          cache.renderTransform(ratio, cache)
      },
      _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
          var cache = target._gsap;
          cache[property] = value;
          cache.renderTransform(ratio, cache)
      },
      _transformProp = "transform",
      _transformOriginProp = _transformProp + "Origin",
      _saveStyle = function _saveStyle(property, isNotCSS) {
          var _this = this;
          var target = this.target,
              style = target.style,
              cache = target._gsap;
          if (property in _transformProps && style) {
              this.tfm = this.tfm || {};
              if (property !== "transform") {
                  property = _propertyAliases[property] || property;
                  ~property.indexOf(",") ? property.split(",").forEach(function(a) {
                      return _this.tfm[a] = _get(target, a)
                  }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
                  property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin)
              } else {
                  return _propertyAliases.transform.split(",").forEach(function(p) {
                      return _saveStyle.call(_this, p, isNotCSS)
                  })
              }
              if (this.props.indexOf(_transformProp) >= 0) {
                  return
              }
              if (cache.svg) {
                  this.svgo = target.getAttribute("data-svg-origin");
                  this.props.push(_transformOriginProp, isNotCSS, "")
              }
              property = _transformProp
          }(style || isNotCSS) && this.props.push(property, isNotCSS, style[property])
      },
      _removeIndependentTransforms = function _removeIndependentTransforms(style) {
          if (style.translate) {
              style.removeProperty("translate");
              style.removeProperty("scale");
              style.removeProperty("rotate")
          }
      },
      _revertStyle = function _revertStyle() {
          var props = this.props,
              target = this.target,
              style = target.style,
              cache = target._gsap,
              i, p;
          for (i = 0; i < props.length; i += 3) {
              props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase())
          }
          if (this.tfm) {
              for (p in this.tfm) {
                  cache[p] = this.tfm[p]
              }
              if (cache.svg) {
                  cache.renderTransform();
                  target.setAttribute("data-svg-origin", this.svgo || "")
              }
              i = _reverting$1();
              if ((!i || !i.isStart) && !style[_transformProp]) {
                  _removeIndependentTransforms(style);
                  if (cache.zOrigin && style[_transformOriginProp]) {
                      style[_transformOriginProp] += " " + cache.zOrigin + "px";
                      cache.zOrigin = 0;
                      cache.renderTransform()
                  }
                  cache.uncache = 1
              }
          }
      },
      _getStyleSaver = function _getStyleSaver(target, properties) {
          var saver = {
              target: target,
              props: [],
              revert: _revertStyle,
              save: _saveStyle
          };
          target._gsap || gsap.core.getCache(target);
          properties && properties.split(",").forEach(function(p) {
              return saver.save(p)
          });
          return saver
      },
      _supports3D, _createElement = function _createElement(type, ns) {
          var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc$1.createElement(type);
          return e && e.style ? e : _doc$1.createElement(type)
      },
      _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
          var cs = getComputedStyle(target);
          return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""
      },
      _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
      _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
          var e = element || _tempDiv,
              s = e.style,
              i = 5;
          if (property in s && !preferPrefix) {
              return property
          }
          property = property.charAt(0).toUpperCase() + property.substr(1);
          while (i-- && !(_prefixes[i] + property in s)) {}
          return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property
      },
      _initCore = function _initCore() {
          if (_windowExists$1() && window.document) {
              _win$1 = window;
              _doc$1 = _win$1.document;
              _docElement = _doc$1.documentElement;
              _tempDiv = _createElement("div") || {
                  style: {}
              };
              _tempDivStyler = _createElement("div");
              _transformProp = _checkPropPrefix(_transformProp);
              _transformOriginProp = _transformProp + "Origin";
              _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
              _supports3D = !!_checkPropPrefix("perspective");
              _reverting$1 = gsap.core.reverting;
              _pluginInitted = 1
          }
      },
      _getBBoxHack = function _getBBoxHack(swapIfPossible) {
          var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
              oldParent = this.parentNode,
              oldSibling = this.nextSibling,
              oldCSS = this.style.cssText,
              bbox;
          _docElement.appendChild(svg);
          svg.appendChild(this);
          this.style.display = "block";
          if (swapIfPossible) {
              try {
                  bbox = this.getBBox();
                  this._gsapBBox = this.getBBox;
                  this.getBBox = _getBBoxHack
              } catch (e) {}
          } else if (this._gsapBBox) {
              bbox = this._gsapBBox()
          }
          if (oldParent) {
              if (oldSibling) {
                  oldParent.insertBefore(this, oldSibling)
              } else {
                  oldParent.appendChild(this)
              }
          }
          _docElement.removeChild(svg);
          this.style.cssText = oldCSS;
          return bbox
      },
      _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
          var i = attributesArray.length;
          while (i--) {
              if (target.hasAttribute(attributesArray[i])) {
                  return target.getAttribute(attributesArray[i])
              }
          }
      },
      _getBBox = function _getBBox(target) {
          var bounds;
          try {
              bounds = target.getBBox()
          } catch (error) {
              bounds = _getBBoxHack.call(target, true)
          }
          bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
          return bounds && !bounds.width && !bounds.x && !bounds.y ? {
              x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
              y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0
          } : bounds
      },
      _isSVG = function _isSVG(e) {
          return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e))
      },
      _removeProperty = function _removeProperty(target, property) {
          if (property) {
              var style = target.style,
                  first2Chars;
              if (property in _transformProps && property !== _transformOriginProp) {
                  property = _transformProp
              }
              if (style.removeProperty) {
                  first2Chars = property.substr(0, 2);
                  if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
                      property = "-" + property
                  }
                  style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase())
              } else {
                  style.removeAttribute(property)
              }
          }
      },
      _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
          var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
          plugin._pt = pt;
          pt.b = beginning;
          pt.e = end;
          plugin._props.push(property);
          return pt
      },
      _nonConvertibleUnits = {
          deg: 1,
          rad: 1,
          turn: 1
      },
      _nonStandardLayouts = {
          grid: 1,
          flex: 1
      },
      _convertToUnit = function _convertToUnit(target, property, value, unit) {
          var curValue = parseFloat(value) || 0,
              curUnit = (value + "").trim().substr((curValue + "").length) || "px",
              style = _tempDiv.style,
              horizontal = _horizontalExp.test(property),
              isRootSVG = target.tagName.toLowerCase() === "svg",
              measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
              amount = 100,
              toPixels = unit === "px",
              toPercent = unit === "%",
              px, parent, cache, isSVG;
          if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
              return curValue
          }
          curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
          isSVG = target.getCTM && _isSVG(target);
          if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
              px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
              return _round(toPercent ? curValue / px * amount : curValue / 100 * px)
          }
          style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
          parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
          if (isSVG) {
              parent = (target.ownerSVGElement || {}).parentNode
          }
          if (!parent || parent === _doc$1 || !parent.appendChild) {
              parent = _doc$1.body
          }
          cache = parent._gsap;
          if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
              return _round(curValue / cache.width * amount)
          } else {
              if (toPercent && (property === "height" || property === "width")) {
                  var v = target.style[property];
                  target.style[property] = amount + unit;
                  px = target[measureProperty];
                  v ? target.style[property] = v : _removeProperty(target, property)
              } else {
                  (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
                  parent === target && (style.position = "static");
                  parent.appendChild(_tempDiv);
                  px = _tempDiv[measureProperty];
                  parent.removeChild(_tempDiv);
                  style.position = "absolute"
              }
              if (horizontal && toPercent) {
                  cache = _getCache(parent);
                  cache.time = _ticker.time;
                  cache.width = parent[measureProperty]
              }
          }
          return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0)
      },
      _get = function _get(target, property, unit, uncache) {
          var value;
          _pluginInitted || _initCore();
          if (property in _propertyAliases && property !== "transform") {
              property = _propertyAliases[property];
              if (~property.indexOf(",")) {
                  property = property.split(",")[0]
              }
          }
          if (_transformProps[property] && property !== "transform") {
              value = _parseTransform(target, uncache);
              value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px"
          } else {
              value = target.style[property];
              if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
                  value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0)
              }
          }
          return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value
      },
      _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
          if (!start || start === "none") {
              var p = _checkPropPrefix(prop, target, 1),
                  s = p && _getComputedProperty(target, p, 1);
              if (s && s !== start) {
                  prop = p;
                  start = s
              } else if (prop === "borderColor") {
                  start = _getComputedProperty(target, "borderTopColor")
              }
          }
          var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
              index = 0,
              matchIndex = 0,
              a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
          pt.b = start;
          pt.e = end;
          start += "";
          end += "";
          if (end === "auto") {
              startValue = target.style[prop];
              target.style[prop] = end;
              end = _getComputedProperty(target, prop) || end;
              startValue ? target.style[prop] = startValue : _removeProperty(target, prop)
          }
          a = [start, end];
          _colorStringFilter(a);
          start = a[0];
          end = a[1];
          startValues = start.match(_numWithUnitExp) || [];
          endValues = end.match(_numWithUnitExp) || [];
          if (endValues.length) {
              while (result = _numWithUnitExp.exec(end)) {
                  endValue = result[0];
                  chunk = end.substring(index, result.index);
                  if (color) {
                      color = (color + 1) % 5
                  } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
                      color = 1
                  }
                  if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                      startNum = parseFloat(startValue) || 0;
                      startUnit = startValue.substr((startNum + "").length);
                      endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
                      endNum = parseFloat(endValue);
                      endUnit = endValue.substr((endNum + "").length);
                      index = _numWithUnitExp.lastIndex - endUnit.length;
                      if (!endUnit) {
                          endUnit = endUnit || _config.units[prop] || startUnit;
                          if (index === end.length) {
                              end += endUnit;
                              pt.e += endUnit
                          }
                      }
                      if (startUnit !== endUnit) {
                          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0
                      }
                      pt._pt = {
                          _next: pt._pt,
                          p: chunk || matchIndex === 1 ? chunk : ",",
                          s: startNum,
                          c: endNum - startNum,
                          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                      }
                  }
              }
              pt.c = index < end.length ? end.substring(index, end.length) : ""
          } else {
              pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue
          }
          _relExp.test(end) && (pt.e = 0);
          this._pt = pt;
          return pt
      },
      _keywordToPercent = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%"
      },
      _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
          var split = value.split(" "),
              x = split[0],
              y = split[1] || "50%";
          if (x === "top" || x === "bottom" || y === "left" || y === "right") {
              value = x;
              x = y;
              y = value
          }
          split[0] = _keywordToPercent[x] || x;
          split[1] = _keywordToPercent[y] || y;
          return split.join(" ")
      },
      _renderClearProps = function _renderClearProps(ratio, data) {
          if (data.tween && data.tween._time === data.tween._dur) {
              var target = data.t,
                  style = target.style,
                  props = data.u,
                  cache = target._gsap,
                  prop, clearTransforms, i;
              if (props === "all" || props === true) {
                  style.cssText = "";
                  clearTransforms = 1
              } else {
                  props = props.split(",");
                  i = props.length;
                  while (--i > -1) {
                      prop = props[i];
                      if (_transformProps[prop]) {
                          clearTransforms = 1;
                          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp
                      }
                      _removeProperty(target, prop)
                  }
              }
              if (clearTransforms) {
                  _removeProperty(target, _transformProp);
                  if (cache) {
                      cache.svg && target.removeAttribute("transform");
                      _parseTransform(target, 1);
                      cache.uncache = 1;
                      _removeIndependentTransforms(style)
                  }
              }
          }
      },
      _specialProps = {
          clearProps: function clearProps(plugin, target, property, endValue, tween) {
              if (tween.data !== "isFromStart") {
                  var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                  pt.u = endValue;
                  pt.pr = -10;
                  pt.tween = tween;
                  plugin._props.push(property);
                  return 1
              }
          }
      },
      _identity2DMatrix = [1, 0, 0, 1, 0, 0],
      _rotationalProperties = {},
      _isNullTransform = function _isNullTransform(value) {
          return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value
      },
      _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
          var matrixString = _getComputedProperty(target, _transformProp);
          return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round)
      },
      _getMatrix = function _getMatrix(target, force2D) {
          var cache = target._gsap || _getCache(target),
              style = target.style,
              matrix = _getComputedTransformMatrixAsArray(target),
              parent, nextSibling, temp, addedToDOM;
          if (cache.svg && target.getAttribute("transform")) {
              temp = target.transform.baseVal.consolidate().matrix;
              matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
              return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix
          } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
              temp = style.display;
              style.display = "block";
              parent = target.parentNode;
              if (!parent || !target.offsetParent) {
                  addedToDOM = 1;
                  nextSibling = target.nextElementSibling;
                  _docElement.appendChild(target)
              }
              matrix = _getComputedTransformMatrixAsArray(target);
              temp ? style.display = temp : _removeProperty(target, "display");
              if (addedToDOM) {
                  nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target)
              }
          }
          return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix
      },
      _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
          var cache = target._gsap,
              matrix = matrixArray || _getMatrix(target, true),
              xOriginOld = cache.xOrigin || 0,
              yOriginOld = cache.yOrigin || 0,
              xOffsetOld = cache.xOffset || 0,
              yOffsetOld = cache.yOffset || 0,
              a = matrix[0],
              b = matrix[1],
              c = matrix[2],
              d = matrix[3],
              tx = matrix[4],
              ty = matrix[5],
              originSplit = origin.split(" "),
              xOrigin = parseFloat(originSplit[0]) || 0,
              yOrigin = parseFloat(originSplit[1]) || 0,
              bounds, determinant, x, y;
          if (!originIsAbsolute) {
              bounds = _getBBox(target);
              xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
              yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin)
          } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
              x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
              y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
              xOrigin = x;
              yOrigin = y
          }
          if (smooth || smooth !== false && cache.smooth) {
              tx = xOrigin - xOriginOld;
              ty = yOrigin - yOriginOld;
              cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
              cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty
          } else {
              cache.xOffset = cache.yOffset = 0
          }
          cache.xOrigin = xOrigin;
          cache.yOrigin = yOrigin;
          cache.smooth = !!smooth;
          cache.origin = origin;
          cache.originIsAbsolute = !!originIsAbsolute;
          target.style[_transformOriginProp] = "0px 0px";
          if (pluginToAddPropTweensTo) {
              _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
              _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
              _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
              _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset)
          }
          target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin)
      },
      _parseTransform = function _parseTransform(target, uncache) {
          var cache = target._gsap || new GSCache(target);
          if ("x" in cache && !uncache && !cache.uncache) {
              return cache
          }
          var style = target.style,
              invertedScaleX = cache.scaleX < 0,
              px = "px",
              deg = "deg",
              cs = getComputedStyle(target),
              origin = _getComputedProperty(target, _transformOriginProp) || "0",
              x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
          x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
          scaleX = scaleY = 1;
          cache.svg = !!(target.getCTM && _isSVG(target));
          if (cs.translate) {
              if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
                  style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "")
              }
              style.scale = style.rotate = style.translate = "none"
          }
          matrix = _getMatrix(target, cache.svg);
          if (cache.svg) {
              if (cache.uncache) {
                  t2 = target.getBBox();
                  origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
                  t1 = ""
              } else {
                  t1 = !uncache && target.getAttribute("data-svg-origin")
              }
              _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix)
          }
          xOrigin = cache.xOrigin || 0;
          yOrigin = cache.yOrigin || 0;
          if (matrix !== _identity2DMatrix) {
              a = matrix[0];
              b = matrix[1];
              c = matrix[2];
              d = matrix[3];
              x = a12 = matrix[4];
              y = a22 = matrix[5];
              if (matrix.length === 6) {
                  scaleX = Math.sqrt(a * a + b * b);
                  scaleY = Math.sqrt(d * d + c * c);
                  rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
                  skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                  skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
                  if (cache.svg) {
                      x -= xOrigin - (xOrigin * a + yOrigin * c);
                      y -= yOrigin - (xOrigin * b + yOrigin * d)
                  }
              } else {
                  a32 = matrix[6];
                  a42 = matrix[7];
                  a13 = matrix[8];
                  a23 = matrix[9];
                  a33 = matrix[10];
                  a43 = matrix[11];
                  x = matrix[12];
                  y = matrix[13];
                  z = matrix[14];
                  angle = _atan2(a32, a33);
                  rotationX = angle * _RAD2DEG;
                  if (angle) {
                      cos = Math.cos(-angle);
                      sin = Math.sin(-angle);
                      t1 = a12 * cos + a13 * sin;
                      t2 = a22 * cos + a23 * sin;
                      t3 = a32 * cos + a33 * sin;
                      a13 = a12 * -sin + a13 * cos;
                      a23 = a22 * -sin + a23 * cos;
                      a33 = a32 * -sin + a33 * cos;
                      a43 = a42 * -sin + a43 * cos;
                      a12 = t1;
                      a22 = t2;
                      a32 = t3
                  }
                  angle = _atan2(-c, a33);
                  rotationY = angle * _RAD2DEG;
                  if (angle) {
                      cos = Math.cos(-angle);
                      sin = Math.sin(-angle);
                      t1 = a * cos - a13 * sin;
                      t2 = b * cos - a23 * sin;
                      t3 = c * cos - a33 * sin;
                      a43 = d * sin + a43 * cos;
                      a = t1;
                      b = t2;
                      c = t3
                  }
                  angle = _atan2(b, a);
                  rotation = angle * _RAD2DEG;
                  if (angle) {
                      cos = Math.cos(angle);
                      sin = Math.sin(angle);
                      t1 = a * cos + b * sin;
                      t2 = a12 * cos + a22 * sin;
                      b = b * cos - a * sin;
                      a22 = a22 * cos - a12 * sin;
                      a = t1;
                      a12 = t2
                  }
                  if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                      rotationX = rotation = 0;
                      rotationY = 180 - rotationY
                  }
                  scaleX = _round(Math.sqrt(a * a + b * b + c * c));
                  scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
                  angle = _atan2(a12, a22);
                  skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
                  perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0
              }
              if (cache.svg) {
                  t1 = target.getAttribute("transform");
                  cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                  t1 && target.setAttribute("transform", t1)
              }
          }
          if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
              if (invertedScaleX) {
                  scaleX *= -1;
                  skewX += rotation <= 0 ? 180 : -180;
                  rotation += rotation <= 0 ? 180 : -180
              } else {
                  scaleY *= -1;
                  skewX += skewX <= 0 ? 180 : -180
              }
          }
          uncache = uncache || cache.uncache;
          cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
          cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
          cache.z = z + px;
          cache.scaleX = _round(scaleX);
          cache.scaleY = _round(scaleY);
          cache.rotation = _round(rotation) + deg;
          cache.rotationX = _round(rotationX) + deg;
          cache.rotationY = _round(rotationY) + deg;
          cache.skewX = skewX + deg;
          cache.skewY = skewY + deg;
          cache.transformPerspective = perspective + px;
          if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
              style[_transformOriginProp] = _firstTwoOnly(origin)
          }
          cache.xOffset = cache.yOffset = 0;
          cache.force3D = _config.force3D;
          cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
          cache.uncache = 0;
          return cache
      },
      _firstTwoOnly = function _firstTwoOnly(value) {
          return (value = value.split(" "))[0] + " " + value[1]
      },
      _addPxTranslate = function _addPxTranslate(target, start, value) {
          var unit = getUnit(start);
          return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit
      },
      _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
          cache.z = "0px";
          cache.rotationY = cache.rotationX = "0deg";
          cache.force3D = 0;
          _renderCSSTransforms(ratio, cache)
      },
      _zeroDeg = "0deg",
      _zeroPx = "0px",
      _endParenthesis = ") ",
      _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
          var _ref = cache || this,
              xPercent = _ref.xPercent,
              yPercent = _ref.yPercent,
              x = _ref.x,
              y = _ref.y,
              z = _ref.z,
              rotation = _ref.rotation,
              rotationY = _ref.rotationY,
              rotationX = _ref.rotationX,
              skewX = _ref.skewX,
              skewY = _ref.skewY,
              scaleX = _ref.scaleX,
              scaleY = _ref.scaleY,
              transformPerspective = _ref.transformPerspective,
              force3D = _ref.force3D,
              target = _ref.target,
              zOrigin = _ref.zOrigin,
              transforms = "",
              use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
          if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
              var angle = parseFloat(rotationY) * _DEG2RAD,
                  a13 = Math.sin(angle),
                  a33 = Math.cos(angle),
                  cos;
              angle = parseFloat(rotationX) * _DEG2RAD;
              cos = Math.cos(angle);
              x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
              y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
              z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin)
          }
          if (transformPerspective !== _zeroPx) {
              transforms += "perspective(" + transformPerspective + _endParenthesis
          }
          if (xPercent || yPercent) {
              transforms += "translate(" + xPercent + "%, " + yPercent + "%) "
          }
          if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
              transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis
          }
          if (rotation !== _zeroDeg) {
              transforms += "rotate(" + rotation + _endParenthesis
          }
          if (rotationY !== _zeroDeg) {
              transforms += "rotateY(" + rotationY + _endParenthesis
          }
          if (rotationX !== _zeroDeg) {
              transforms += "rotateX(" + rotationX + _endParenthesis
          }
          if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
              transforms += "skew(" + skewX + ", " + skewY + _endParenthesis
          }
          if (scaleX !== 1 || scaleY !== 1) {
              transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis
          }
          target.style[_transformProp] = transforms || "translate(0, 0)"
      },
      _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
          var _ref2 = cache || this,
              xPercent = _ref2.xPercent,
              yPercent = _ref2.yPercent,
              x = _ref2.x,
              y = _ref2.y,
              rotation = _ref2.rotation,
              skewX = _ref2.skewX,
              skewY = _ref2.skewY,
              scaleX = _ref2.scaleX,
              scaleY = _ref2.scaleY,
              target = _ref2.target,
              xOrigin = _ref2.xOrigin,
              yOrigin = _ref2.yOrigin,
              xOffset = _ref2.xOffset,
              yOffset = _ref2.yOffset,
              forceCSS = _ref2.forceCSS,
              tx = parseFloat(x),
              ty = parseFloat(y),
              a11, a21, a12, a22, temp;
          rotation = parseFloat(rotation);
          skewX = parseFloat(skewX);
          skewY = parseFloat(skewY);
          if (skewY) {
              skewY = parseFloat(skewY);
              skewX += skewY;
              rotation += skewY
          }
          if (rotation || skewX) {
              rotation *= _DEG2RAD;
              skewX *= _DEG2RAD;
              a11 = Math.cos(rotation) * scaleX;
              a21 = Math.sin(rotation) * scaleX;
              a12 = Math.sin(rotation - skewX) * -scaleY;
              a22 = Math.cos(rotation - skewX) * scaleY;
              if (skewX) {
                  skewY *= _DEG2RAD;
                  temp = Math.tan(skewX - skewY);
                  temp = Math.sqrt(1 + temp * temp);
                  a12 *= temp;
                  a22 *= temp;
                  if (skewY) {
                      temp = Math.tan(skewY);
                      temp = Math.sqrt(1 + temp * temp);
                      a11 *= temp;
                      a21 *= temp
                  }
              }
              a11 = _round(a11);
              a21 = _round(a21);
              a12 = _round(a12);
              a22 = _round(a22)
          } else {
              a11 = scaleX;
              a22 = scaleY;
              a21 = a12 = 0
          }
          if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
              tx = _convertToUnit(target, "x", x, "px");
              ty = _convertToUnit(target, "y", y, "px")
          }
          if (xOrigin || yOrigin || xOffset || yOffset) {
              tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
              ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset)
          }
          if (xPercent || yPercent) {
              temp = target.getBBox();
              tx = _round(tx + xPercent / 100 * temp.width);
              ty = _round(ty + yPercent / 100 * temp.height)
          }
          temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
          target.setAttribute("transform", temp);
          forceCSS && (target.style[_transformProp] = temp)
      },
      _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
          var cap = 360,
              isString = _isString(endValue),
              endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
              change = endNum - startNum,
              finalValue = startNum + change + "deg",
              direction, pt;
          if (isString) {
              direction = endValue.split("_")[1];
              if (direction === "short") {
                  change %= cap;
                  if (change !== change % (cap / 2)) {
                      change += change < 0 ? cap : -cap
                  }
              }
              if (direction === "cw" && change < 0) {
                  change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap
              } else if (direction === "ccw" && change > 0) {
                  change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap
              }
          }
          plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
          pt.e = finalValue;
          pt.u = "deg";
          plugin._props.push(property);
          return pt
      },
      _assign = function _assign(target, source) {
          for (var p in source) {
              target[p] = source[p]
          }
          return target
      },
      _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
          var startCache = _assign({}, target._gsap),
              exclude = "perspective,force3D,transformOrigin,svgOrigin",
              style = target.style,
              endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
          if (startCache.svg) {
              startValue = target.getAttribute("transform");
              target.setAttribute("transform", "");
              style[_transformProp] = transforms;
              endCache = _parseTransform(target, 1);
              _removeProperty(target, _transformProp);
              target.setAttribute("transform", startValue)
          } else {
              startValue = getComputedStyle(target)[_transformProp];
              style[_transformProp] = transforms;
              endCache = _parseTransform(target, 1);
              style[_transformProp] = startValue
          }
          for (p in _transformProps) {
              startValue = startCache[p];
              endValue = endCache[p];
              if (startValue !== endValue && exclude.indexOf(p) < 0) {
                  startUnit = getUnit(startValue);
                  endUnit = getUnit(endValue);
                  startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                  endNum = parseFloat(endValue);
                  plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                  plugin._pt.u = endUnit || 0;
                  plugin._props.push(p)
              }
          }
          _assign(endCache, startCache)
      };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
      var t = "Top",
          r = "Right",
          b = "Bottom",
          l = "Left",
          props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
              return index < 2 ? name + side : "border" + side + name
          });
      _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
          var a, vars;
          if (arguments.length < 4) {
              a = props.map(function(prop) {
                  return _get(plugin, prop, property)
              });
              vars = a.join(" ");
              return vars.split(a[0]).length === 5 ? a[0] : vars
          }
          a = (endValue + "").split(" ");
          vars = {};
          props.forEach(function(prop, i) {
              return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0]
          });
          plugin.init(target, vars, tween)
      }
  });
  var CSSPlugin = {
      name: "css",
      register: _initCore,
      targetTest: function targetTest(target) {
          return target.style && target.nodeType
      },
      init: function init(target, vars, tween, index, targets) {
          var props = this._props,
              style = target.style,
              startAt = tween.vars.startAt,
              startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
          _pluginInitted || _initCore();
          this.styles = this.styles || _getStyleSaver(target);
          inlineProps = this.styles.props;
          this.tween = tween;
          for (p in vars) {
              if (p === "autoRound") {
                  continue
              }
              endValue = vars[p];
              if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
                  continue
              }
              type = typeof endValue;
              specialProp = _specialProps[p];
              if (type === "function") {
                  endValue = endValue.call(tween, index, target, targets);
                  type = typeof endValue
              }
              if (type === "string" && ~endValue.indexOf("random(")) {
                  endValue = _replaceRandom(endValue)
              }
              if (specialProp) {
                  specialProp(this, target, p, endValue, tween) && (hasPriority = 1)
              } else if (p.substr(0, 2) === "--") {
                  startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                  endValue += "";
                  _colorExp.lastIndex = 0;
                  if (!_colorExp.test(startValue)) {
                      startUnit = getUnit(startValue);
                      endUnit = getUnit(endValue)
                  }
                  endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                  this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                  props.push(p);
                  inlineProps.push(p, 0, style[p])
              } else if (type !== "undefined") {
                  if (startAt && p in startAt) {
                      startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                      _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
                      getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
                      (startValue + "").charAt(1) === "=" && (startValue = _get(target, p))
                  } else {
                      startValue = _get(target, p)
                  }
                  startNum = parseFloat(startValue);
                  relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                  relative && (endValue = endValue.substr(2));
                  endNum = parseFloat(endValue);
                  if (p in _propertyAliases) {
                      if (p === "autoAlpha") {
                          if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                              startNum = 0
                          }
                          inlineProps.push("visibility", 0, style.visibility);
                          _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum)
                      }
                      if (p !== "scale" && p !== "transform") {
                          p = _propertyAliases[p];
                          ~p.indexOf(",") && (p = p.split(",")[0])
                      }
                  }
                  isTransformRelated = p in _transformProps;
                  if (isTransformRelated) {
                      this.styles.save(p);
                      if (!transformPropTween) {
                          cache = target._gsap;
                          cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                          smooth = vars.smoothOrigin !== false && cache.smooth;
                          transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                          transformPropTween.dep = 1
                      }
                      if (p === "scale") {
                          this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                          this._pt.u = 0;
                          props.push("scaleY", p);
                          p += "X"
                      } else if (p === "transformOrigin") {
                          inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                          endValue = _convertKeywordsToPercentages(endValue);
                          if (cache.svg) {
                              _applySVGOrigin(target, endValue, 0, smooth, 0, this)
                          } else {
                              endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue))
                          }
                          continue
                      } else if (p === "svgOrigin") {
                          _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                          continue
                      } else if (p in _rotationalProperties) {
                          _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                          continue
                      } else if (p === "smoothOrigin") {
                          _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                          continue
                      } else if (p === "force3D") {
                          cache[p] = endValue;
                          continue
                      } else if (p === "transform") {
                          _addRawTransformPTs(this, endValue, target);
                          continue
                      }
                  } else if (!(p in style)) {
                      p = _checkPropPrefix(p) || p
                  }
                  if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                      startUnit = (startValue + "").substr((startNum + "").length);
                      endNum || (endNum = 0);
                      endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
                      startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                      this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                      this._pt.u = endUnit || 0;
                      if (startUnit !== endUnit && endUnit !== "%") {
                          this._pt.b = startValue;
                          this._pt.r = _renderCSSPropWithBeginning
                      }
                  } else if (!(p in style)) {
                      if (p in target) {
                          this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets)
                      } else if (p !== "parseTransform") {
                          _missingPlugin(p, endValue);
                          continue
                      }
                  } else {
                      _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue)
                  }
                  isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
                  props.push(p)
              }
          }
          hasPriority && _sortPropTweensByPriority(this)
      },
      render: function render(ratio, data) {
          if (data.tween._time || !_reverting$1()) {
              var pt = data._pt;
              while (pt) {
                  pt.r(ratio, pt.d);
                  pt = pt._next
              }
          } else {
              data.styles.revert()
          }
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
          var p = _propertyAliases[property];
          p && p.indexOf(",") < 0 && (property = p);
          return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property)
      },
      core: {
          _removeProperty: _removeProperty,
          _getMatrix: _getMatrix
      }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
          _transformProps[name] = 1
      });
      _forEachName(rotation, function(name) {
          _config.units[name] = "deg";
          _rotationalProperties[name] = 1
      });
      _propertyAliases[all[13]] = positionAndScale + "," + rotation;
      _forEachName(aliases, function(name) {
          var split = name.split(":");
          _propertyAliases[split[1]] = all[split[0]]
      })
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
      _config.units[name] = "px"
  });
  gsap.registerPlugin(CSSPlugin);
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
      TweenMaxWithCSS = gsapWithCSS.core.Tween;
  exports.Back = Back;
  exports.Bounce = Bounce;
  exports.CSSPlugin = CSSPlugin;
  exports.Circ = Circ;
  exports.Cubic = Cubic;
  exports.Elastic = Elastic;
  exports.Expo = Expo;
  exports.Linear = Linear;
  exports.Power0 = Power0;
  exports.Power1 = Power1;
  exports.Power2 = Power2;
  exports.Power3 = Power3;
  exports.Power4 = Power4;
  exports.Quad = Quad;
  exports.Quart = Quart;
  exports.Quint = Quint;
  exports.Sine = Sine;
  exports.SteppedEase = SteppedEase;
  exports.Strong = Strong;
  exports.TimelineLite = Timeline;
  exports.TimelineMax = Timeline;
  exports.TweenLite = Tween;
  exports.TweenMax = TweenMaxWithCSS;
  exports["default"] = gsapWithCSS;
  exports.gsap = gsapWithCSS;
  if (typeof window === "undefined" || window !== exports) {
      Object.defineProperty(exports, "__esModule", {
          value: true
      })
  } else {
      delete window["default"]
  }
});
(function(global, factory) {
  if (typeof module == "object" && module.exports) {
      module.exports = factory()
  } else {
      global.EvEmitter = factory()
  }
})(typeof window != "undefined" ? window : this, function() {
  function EvEmitter() {}
  let proto = EvEmitter.prototype;
  proto.on = function(eventName, listener) {
      if (!eventName || !listener) return this;
      let events = this._events = this._events || {};
      let listeners = events[eventName] = events[eventName] || [];
      if (!listeners.includes(listener)) {
          listeners.push(listener)
      }
      return this
  };
  proto.once = function(eventName, listener) {
      if (!eventName || !listener) return this;
      this.on(eventName, listener);
      let onceEvents = this._onceEvents = this._onceEvents || {};
      let onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
      onceListeners[listener] = true;
      return this
  };
  proto.off = function(eventName, listener) {
      let listeners = this._events && this._events[eventName];
      if (!listeners || !listeners.length) return this;
      let index = listeners.indexOf(listener);
      if (index != -1) {
          listeners.splice(index, 1)
      }
      return this
  };
  proto.emitEvent = function(eventName, args) {
      let listeners = this._events && this._events[eventName];
      if (!listeners || !listeners.length) return this;
      listeners = listeners.slice(0);
      args = args || [];
      let onceListeners = this._onceEvents && this._onceEvents[eventName];
      for (let listener of listeners) {
          let isOnce = onceListeners && onceListeners[listener];
          if (isOnce) {
              this.off(eventName, listener);
              delete onceListeners[listener]
          }
          listener.apply(this, args)
      }
      return this
  };
  proto.allOff = function() {
      delete this._events;
      delete this._onceEvents;
      return this
  };
  return EvEmitter
});
(function(window, factory) {
  if (typeof module == "object" && module.exports) {
      module.exports = factory(window, require("ev-emitter"))
  } else {
      window.imagesLoaded = factory(window, window.EvEmitter)
  }
})(typeof window !== "undefined" ? window : this, function factory(window, EvEmitter) {
  let $ = window.jQuery;
  let console = window.console;

  function makeArray(obj) {
      if (Array.isArray(obj)) return obj;
      let isArrayLike = typeof obj == "object" && typeof obj.length == "number";
      if (isArrayLike) return [...obj];
      return [obj]
  }

  function ImagesLoaded(elem, options, onAlways) {
      if (!(this instanceof ImagesLoaded)) {
          return new ImagesLoaded(elem, options, onAlways)
      }
      let queryElem = elem;
      if (typeof elem == "string") {
          queryElem = document.querySelectorAll(elem)
      }
      if (!queryElem) {
          console.error(`Bad element for imagesLoaded ${queryElem||elem}`);
          return
      }
      this.elements = makeArray(queryElem);
      this.options = {};
      if (typeof options == "function") {
          onAlways = options
      } else {
          Object.assign(this.options, options)
      }
      if (onAlways) this.on("always", onAlways);
      this.getImages();
      if ($) this.jqDeferred = new $.Deferred;
      setTimeout(this.check.bind(this))
  }
  ImagesLoaded.prototype = Object.create(EvEmitter.prototype);
  ImagesLoaded.prototype.getImages = function() {
      this.images = [];
      this.elements.forEach(this.addElementImages, this)
  };
  const elementNodeTypes = [1, 9, 11];
  ImagesLoaded.prototype.addElementImages = function(elem) {
      if (elem.nodeName === "IMG") {
          this.addImage(elem)
      }
      if (this.options.background === true) {
          this.addElementBackgroundImages(elem)
      }
      let {
          nodeType
      } = elem;
      if (!nodeType || !elementNodeTypes.includes(nodeType)) return;
      let childImgs = elem.querySelectorAll("img");
      for (let img of childImgs) {
          this.addImage(img)
      }
      if (typeof this.options.background == "string") {
          let children = elem.querySelectorAll(this.options.background);
          for (let child of children) {
              this.addElementBackgroundImages(child)
          }
      }
  };
  const reURL = /url\((['"])?(.*?)\1\)/gi;
  ImagesLoaded.prototype.addElementBackgroundImages = function(elem) {
      let style = getComputedStyle(elem);
      if (!style) return;
      let matches = reURL.exec(style.backgroundImage);
      while (matches !== null) {
          let url = matches && matches[2];
          if (url) {
              this.addBackground(url, elem)
          }
          matches = reURL.exec(style.backgroundImage)
      }
  };
  ImagesLoaded.prototype.addImage = function(img) {
      let loadingImage = new LoadingImage(img);
      this.images.push(loadingImage)
  };
  ImagesLoaded.prototype.addBackground = function(url, elem) {
      let background = new Background(url, elem);
      this.images.push(background)
  };
  ImagesLoaded.prototype.check = function() {
      this.progressedCount = 0;
      this.hasAnyBroken = false;
      if (!this.images.length) {
          this.complete();
          return
      }
      let onProgress = (image, elem, message) => {
          setTimeout(() => {
              this.progress(image, elem, message)
          })
      };
      this.images.forEach(function(loadingImage) {
          loadingImage.once("progress", onProgress);
          loadingImage.check()
      })
  };
  ImagesLoaded.prototype.progress = function(image, elem, message) {
      this.progressedCount++;
      this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
      this.emitEvent("progress", [this, image, elem]);
      if (this.jqDeferred && this.jqDeferred.notify) {
          this.jqDeferred.notify(this, image)
      }
      if (this.progressedCount === this.images.length) {
          this.complete()
      }
      if (this.options.debug && console) {
          console.log(`progress: ${message}`, image, elem)
      }
  };
  ImagesLoaded.prototype.complete = function() {
      let eventName = this.hasAnyBroken ? "fail" : "done";
      this.isComplete = true;
      this.emitEvent(eventName, [this]);
      this.emitEvent("always", [this]);
      if (this.jqDeferred) {
          let jqMethod = this.hasAnyBroken ? "reject" : "resolve";
          this.jqDeferred[jqMethod](this)
      }
  };

  function LoadingImage(img) {
      this.img = img
  }
  LoadingImage.prototype = Object.create(EvEmitter.prototype);
  LoadingImage.prototype.check = function() {
      let isComplete = this.getIsImageComplete();
      if (isComplete) {
          this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
          return
      }
      this.proxyImage = new Image;
      if (this.img.crossOrigin) {
          this.proxyImage.crossOrigin = this.img.crossOrigin
      }
      this.proxyImage.addEventListener("load", this);
      this.proxyImage.addEventListener("error", this);
      this.img.addEventListener("load", this);
      this.img.addEventListener("error", this);
      this.proxyImage.src = this.img.currentSrc || this.img.src
  };
  LoadingImage.prototype.getIsImageComplete = function() {
      return this.img.complete && this.img.naturalWidth
  };
  LoadingImage.prototype.confirm = function(isLoaded, message) {
      this.isLoaded = isLoaded;
      let {
          parentNode
      } = this.img;
      let elem = parentNode.nodeName === "PICTURE" ? parentNode : this.img;
      this.emitEvent("progress", [this, elem, message])
  };
  LoadingImage.prototype.handleEvent = function(event) {
      let method = "on" + event.type;
      if (this[method]) {
          this[method](event)
      }
  };
  LoadingImage.prototype.onload = function() {
      this.confirm(true, "onload");
      this.unbindEvents()
  };
  LoadingImage.prototype.onerror = function() {
      this.confirm(false, "onerror");
      this.unbindEvents()
  };
  LoadingImage.prototype.unbindEvents = function() {
      this.proxyImage.removeEventListener("load", this);
      this.proxyImage.removeEventListener("error", this);
      this.img.removeEventListener("load", this);
      this.img.removeEventListener("error", this)
  };

  function Background(url, element) {
      this.url = url;
      this.element = element;
      this.img = new Image
  }
  Background.prototype = Object.create(LoadingImage.prototype);
  Background.prototype.check = function() {
      this.img.addEventListener("load", this);
      this.img.addEventListener("error", this);
      this.img.src = this.url;
      let isComplete = this.getIsImageComplete();
      if (isComplete) {
          this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
          this.unbindEvents()
      }
  };
  Background.prototype.unbindEvents = function() {
      this.img.removeEventListener("load", this);
      this.img.removeEventListener("error", this)
  };
  Background.prototype.confirm = function(isLoaded, message) {
      this.isLoaded = isLoaded;
      this.emitEvent("progress", [this, this.element, message])
  };
  ImagesLoaded.makeJQueryPlugin = function(jQuery) {
      jQuery = jQuery || window.jQuery;
      if (!jQuery) return;
      $ = jQuery;
      $.fn.imagesLoaded = function(options, onAlways) {
          let instance = new ImagesLoaded(this, options, onAlways);
          return instance.jqDeferred.promise($(this))
      }
  };
  ImagesLoaded.makeJQueryPlugin();
  return ImagesLoaded
});
$(function() {
  "use strict";
  const container = document.getElementById("stickyImgContainer");
  if (typeof container != "undefined" && container != null) {
      const sliders = document.querySelector(".slides").querySelectorAll(".slide");
      const slidesData = Array.from(sliders).map(item => {
          return {
              image: "",
              title: "title1",
              meta: ""
          }
      });
      const createEleWithClass = (tag, className) => {
          const ele = document.createElement(tag);
          ele.className = className;
          return ele
      };
      class Slides {
          constructor(data) {
              this.data = document.querySelectorAll(".slide");
              this.container = document.querySelector(".slides");
              this.currentIdx = 0;
              this.slides = document.querySelectorAll(".slide")
          }
          mount(container) {
              container.appendChild(this.container);
              let activeIndex = 0;
              for (let i = 0; i < this.slides.length; i++) {
                  if (activeIndex === i) {
                      this.slides[i].classList.remove("next");
                      this.slides[i].classList.remove("prev");
                      this.slides[i].classList.add("show-meta");
                      document.querySelector(".bg-overlay").style.backgroundImage = `url("${this.slides[i].dataset.bg}")`
                  } else {
                      if (activeIndex > i) {
                          this.slides[i].classList.remove("next");
                          this.slides[i].classList.add("prev")
                      } else {
                          this.slides[i].classList.add("next");
                          this.slides[i].classList.remove("prev")
                      }
                  }
              }
          }
          onActiveIndexChange(activeIndex) {
              this.currentIdx = activeIndex;
              for (let i = 0; i < this.slides.length; i++) {
                  if (activeIndex === i) {
                      this.slides[i].classList.remove("next");
                      this.slides[i].classList.remove("prev");
                      document.querySelector(".bg-overlay").style.backgroundImage = `url("${this.slides[i].dataset.bg}")`
                  } else {
                      if (activeIndex > i) {
                          this.slides[i].classList.remove("next");
                          this.slides[i].classList.add("prev")
                      } else {
                          this.slides[i].classList.add("next");
                          this.slides[i].classList.remove("prev")
                      }
                  }
              }
          }
          onMove(indexFloat) {
              this.container.style.transform = `translateY(${indexFloat*100/this.slides.length}%)`
          }
          appear() {
              this.container.classList.add("scrolling");
              container.classList.add("scrolling");
              this.slides[this.currentIdx].classList.remove("show-meta")
          }
          disperse(activeIndex) {
              this.currentIdx = activeIndex;
              this.slides[this.currentIdx].classList.add("show-meta");
              this.container.classList.remove("scrolling");
              container.classList.remove("scrolling");
              for (let index = 0; index < this.data.length; index++) {
                  if (index > activeIndex) {
                      this.slides[index].classList.add("next");
                      this.slides[index].classList.remove("prev")
                  } else if (index < activeIndex) {
                      this.slides[index].classList.remove("next");
                      this.slides[index].classList.add("prev")
                  } else {
                      this.slides[index].classList.remove("next");
                      this.slides[index].classList.remove("prev")
                  }
              }
          }
      }
      class Grab {
          constructor({
              indexSize,
              onIndexChange,
              onGrabStart,
              onGrabMove,
              onGrabEnd
          }) {
              this.onGrabEnd = onGrabEnd;
              this.onGrabStart = onGrabStart;
              this.onGrabMove = onGrabMove;
              this.scroll = {
                  start: 0,
                  current: 0,
                  initial: 0
              };
              this.listen("mousedown", this.onMouseDown.bind(this));
              this.listen("mousemove", this.onMouseMove.bind(this));
              this.listen("mouseup", this.onMouseUp.bind(this));
              this.listen("touchstart", this.onMouseDown.bind(this), true);
              this.listen("touchmove", this.onMouseMove.bind(this), true);
              this.listen(["touchend", "touchcancel"], this.onMouseUp.bind(this), true)
          }
          listen(events, grabListener, isTouch) {
              const _this = this;
              let mouseListener = function(ev) {
                  if (ev.type === "mouseout" && ev.relatedTarget != null) return;
                  grabListener({
                      y: ev.clientY
                  })
              };
              let touchListener = function(ev) {
                  grabListener({
                      y: ev.targetTouches[0] ? ev.targetTouches[0].clientY : null
                  })
              };
              let listener = mouseListener;
              if (isTouch) {
                  listener = touchListener
              }
              if (Array.isArray(events)) {
                  for (let i = 0; i < events.length; i++) {
                      window.addEventListener(events[i], listener, false)
                  }
              } else {
                  window.addEventListener(events, function(event) {
                      if (event.target.closest(".stickyImageContainer") === container) {
                          listener(event)
                      } else {
                          _this.onMouseUp()
                      }
                  }, false)
              }
          }
          onMouseDown(position) {
              this.scroll.inital = this.scroll.current;
              this.scroll.start = position.y;
              this.scroll.current = position.y;
              this.scroll.delta = this.scroll.current - this.scroll.start;
              this.onGrabStart({
                  delta: this.scroll.delta,
                  direction: Math.abs(this.scroll.delta),
                  current: this.scroll.current,
                  start: this.scroll.start
              })
          }
          onMouseMove(position) {
              if (this.scroll.start) {
                  this.scroll.current = position.y;
                  this.scroll.delta = this.scroll.current - this.scroll.start;
                  this.onGrabMove({
                      delta: this.scroll.delta,
                      direction: Math.abs(this.scroll.delta),
                      current: this.scroll.current,
                      start: this.scroll.start
                  })
              }
          }
          onMouseUp() {
              if (this.scroll.start) {
                  this.onGrabEnd({
                      delta: this.scroll.delta,
                      direction: Math.abs(this.scroll.delta),
                      current: this.scroll.current,
                      start: this.scroll.start
                  });
                  this.scroll.start = null;
                  this.scroll.current = null;
                  this.scroll.delta = null
              }
          }
      }
      const reach = function({
          from,
          to,
          restDelta = .01
      }) {
          let current = Object.assign({}, from);
          let keys = Object.keys(from);
          let raf = {
              current: null
          };
          let _update = function(update, complete) {
              if (keys.length === 0) {
                  cancelAnimationFrame(raf.current);
                  raf.current = null;
                  complete(current);
                  return
              }
              let cacheKeys = keys.slice();
              for (var i = keys.length, val, key; i >= 0; i--) {
                  key = keys[i];
                  val = current[key] + (to[key] - current[key]) * .1;
                  if (Math.abs(to[key] - val) < restDelta) {
                      current[key] = to[key];
                      keys.splice(i, 1);
                      i--
                  } else {
                      current[key] = val
                  }
              }
              update(current);
              raf.current = requestAnimationFrame(_update)
          };
          return {
              start: function({
                  update,
                  complete
              }) {
                  _update = _update.bind(null, update, complete);
                  raf.current = requestAnimationFrame(_update);
                  return {
                      stop: function() {
                          cancelAnimationFrame(raf.current);
                          raf.current = null
                      }
                  }
              }
          }
      };

      function Showcase(data, options = {}) {
          this.data = data;
          this.progress = 0;
          this.direction = 1;
          this.waveIntensity = 0;
          this.options = options;
          this.index = {
              target: 0,
              current: 0,
              initial: 0,
              scrollSize: window.innerHeight / 6,
              active: 0
          };
          this.follower = {
              x: 0,
              y: 0
          };
          this.followerSpring = null;
          this.slidesSpring = null;
          this.grab = new Grab({
              onGrabStart: this.onGrabStart.bind(this),
              onGrabMove: this.onGrabMove.bind(this),
              onGrabEnd: this.onGrabEnd.bind(this)
          })
      }

      function clamp(num, min, max) {
          return Math.max(min, Math.min(num, max))
      }
      Showcase.prototype.onGrabMove = function(scroll) {
          this.index.target = clamp(this.index.initial + scroll.delta / this.index.scrollSize, -this.data.length + .51, .49);
          const index = clamp(Math.round(-this.index.target), 0, this.data.length - 1);
          if (this.index.active !== index) {
              this.index.active = index;
              if (this.options.onActiveIndexChange) {
                  this.options.onActiveIndexChange(this.index.active)
              }
          }
          if (this.slidesPop) {
              this.slidesPop.stop()
          }
          this.slidesPop = reach({
              from: {
                  index: this.index.current
              },
              to: {
                  index: this.index.target
              },
              restDelta: .001
          }).start({
              update: val => {
                  if (this.options.onIndexChange) {
                      this.options.onIndexChange(val.index)
                  }
                  this.index.current = val.index
              },
              complete: val => {
                  if (this.options.onIndexChange) {
                      this.options.onIndexChange(val.index)
                  }
                  this.index.current = val.index
              }
          })
      };
      Showcase.prototype.onGrabStart = function() {
          if (this.options.onZoomOutStart) {
              this.options.onZoomOutStart({
                  activeIndex: this.index.active
              })
          }
          this.index.initial = this.index.current
      };
      Showcase.prototype.snapCurrentToActiveIndex = function() {
          if (this.slidesPop) {
              this.slidesPop.stop()
          }
          this.slidesPop = reach({
              from: {
                  index: this.index.current
              },
              to: {
                  index: Math.round(this.index.target)
              },
              restDelta: .001
          }).start({
              complete: () => {},
              update: val => {
                  if (this.options.onIndexChange) {
                      this.options.onIndexChange(val.index)
                  }
                  this.index.current = val.index
              }
          })
      };
      Showcase.prototype.onGrabEnd = function() {
          if (this.options.onFullscreenStart) {
              this.options.onFullscreenStart({
                  activeIndex: this.index.active
              });
              this.snapCurrentToActiveIndex()
          }
      };
      Showcase.prototype.onResize = function() {};
      const slides = new Slides;
      const showcase = new Showcase(slidesData, {
          onActiveIndexChange: activeIndex => {
              slides.onActiveIndexChange(activeIndex)
          },
          onIndexChange: index => {
              slides.onMove(index)
          },
          onZoomOutStart: ({
              activeIndex
          }) => {
              slides.appear()
          },
          onZoomOutFinish: ({
              activeIndex
          }) => {},
          onFullscreenStart: ({
              activeIndex
          }) => {
              slides.disperse(activeIndex)
          },
          onFullscreenFinish: ({
              activeIndex
          }) => {}
      });
      slides.mount(container)
  }
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("jquery-bridget/jquery-bridget", ["jquery"], function(jQuery) {
          return factory(window, jQuery)
      })
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(window, require("jquery"))
  } else {
      window.jQueryBridget = factory(window, window.jQuery)
  }
})(window, function factory(window, jQuery) {
  "use strict";
  var arraySlice = Array.prototype.slice;
  var console = window.console;
  var logError = typeof console == "undefined" ? function() {} : function(message) {
      console.error(message)
  };

  function jQueryBridget(namespace, PluginClass, $) {
      $ = $ || jQuery || window.jQuery;
      if (!$) {
          return
      }
      if (!PluginClass.prototype.option) {
          PluginClass.prototype.option = function(opts) {
              if (!$.isPlainObject(opts)) {
                  return
              }
              this.options = $.extend(true, this.options, opts)
          }
      }
      $.fn[namespace] = function(arg0) {
          if (typeof arg0 == "string") {
              var args = arraySlice.call(arguments, 1);
              return methodCall(this, arg0, args)
          }
          plainCall(this, arg0);
          return this
      };

      function methodCall($elems, methodName, args) {
          var returnValue;
          var pluginMethodStr = "$()." + namespace + '("' + methodName + '")';
          $elems.each(function(i, elem) {
              var instance = $.data(elem, namespace);
              if (!instance) {
                  logError(namespace + " not initialized. Cannot call methods, i.e. " + pluginMethodStr);
                  return
              }
              var method = instance[methodName];
              if (!method || methodName.charAt(0) == "_") {
                  logError(pluginMethodStr + " is not a valid method");
                  return
              }
              var value = method.apply(instance, args);
              returnValue = returnValue === undefined ? value : returnValue
          });
          return returnValue !== undefined ? returnValue : $elems
      }

      function plainCall($elems, options) {
          $elems.each(function(i, elem) {
              var instance = $.data(elem, namespace);
              if (instance) {
                  instance.option(options);
                  instance._init()
              } else {
                  instance = new PluginClass(elem, options);
                  $.data(elem, namespace, instance)
              }
          })
      }
      updateJQuery($)
  }

  function updateJQuery($) {
      if (!$ || $ && $.bridget) {
          return
      }
      $.bridget = jQueryBridget
  }
  updateJQuery(jQuery || window.jQuery);
  return jQueryBridget
});
(function(global, factory) {
  if (typeof define == "function" && define.amd) {
      define("ev-emitter/ev-emitter", factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory()
  } else {
      global.EvEmitter = factory()
  }
})(typeof window != "undefined" ? window : this, function() {
  function EvEmitter() {}
  var proto = EvEmitter.prototype;
  proto.on = function(eventName, listener) {
      if (!eventName || !listener) {
          return
      }
      var events = this._events = this._events || {};
      var listeners = events[eventName] = events[eventName] || [];
      if (listeners.indexOf(listener) == -1) {
          listeners.push(listener)
      }
      return this
  };
  proto.once = function(eventName, listener) {
      if (!eventName || !listener) {
          return
      }
      this.on(eventName, listener);
      var onceEvents = this._onceEvents = this._onceEvents || {};
      var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
      onceListeners[listener] = true;
      return this
  };
  proto.off = function(eventName, listener) {
      var listeners = this._events && this._events[eventName];
      if (!listeners || !listeners.length) {
          return
      }
      var index = listeners.indexOf(listener);
      if (index != -1) {
          listeners.splice(index, 1)
      }
      return this
  };
  proto.emitEvent = function(eventName, args) {
      var listeners = this._events && this._events[eventName];
      if (!listeners || !listeners.length) {
          return
      }
      listeners = listeners.slice(0);
      args = args || [];
      var onceListeners = this._onceEvents && this._onceEvents[eventName];
      for (var i = 0; i < listeners.length; i++) {
          var listener = listeners[i];
          var isOnce = onceListeners && onceListeners[listener];
          if (isOnce) {
              this.off(eventName, listener);
              delete onceListeners[listener]
          }
          listener.apply(this, args)
      }
      return this
  };
  proto.allOff = function() {
      delete this._events;
      delete this._onceEvents
  };
  return EvEmitter
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("get-size/get-size", factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory()
  } else {
      window.getSize = factory()
  }
})(window, function factory() {
  "use strict";

  function getStyleSize(value) {
      var num = parseFloat(value);
      var isValid = value.indexOf("%") == -1 && !isNaN(num);
      return isValid && num
  }

  function noop() {}
  var logError = typeof console == "undefined" ? noop : function(message) {
      console.error(message)
  };
  var measurements = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"];
  var measurementsLength = measurements.length;

  function getZeroSize() {
      var size = {
          width: 0,
          height: 0,
          innerWidth: 0,
          innerHeight: 0,
          outerWidth: 0,
          outerHeight: 0
      };
      for (var i = 0; i < measurementsLength; i++) {
          var measurement = measurements[i];
          size[measurement] = 0
      }
      return size
  }

  function getStyle(elem) {
      var style = getComputedStyle(elem);
      if (!style) {
          logError("Style returned " + style + ". Are you running this code in a hidden iframe on Firefox? " + "See https://bit.ly/getsizebug1")
      }
      return style
  }
  var isSetup = false;
  var isBoxSizeOuter;

  function setup() {
      if (isSetup) {
          return
      }
      isSetup = true;
      var div = document.createElement("div");
      div.style.width = "200px";
      div.style.padding = "1px 2px 3px 4px";
      div.style.borderStyle = "solid";
      div.style.borderWidth = "1px 2px 3px 4px";
      div.style.boxSizing = "border-box";
      var body = document.body || document.documentElement;
      body.appendChild(div);
      var style = getStyle(div);
      isBoxSizeOuter = Math.round(getStyleSize(style.width)) == 200;
      getSize.isBoxSizeOuter = isBoxSizeOuter;
      body.removeChild(div)
  }

  function getSize(elem) {
      setup();
      if (typeof elem == "string") {
          elem = document.querySelector(elem)
      }
      if (!elem || typeof elem != "object" || !elem.nodeType) {
          return
      }
      var style = getStyle(elem);
      if (style.display == "none") {
          return getZeroSize()
      }
      var size = {};
      size.width = elem.offsetWidth;
      size.height = elem.offsetHeight;
      var isBorderBox = size.isBorderBox = style.boxSizing == "border-box";
      for (var i = 0; i < measurementsLength; i++) {
          var measurement = measurements[i];
          var value = style[measurement];
          var num = parseFloat(value);
          size[measurement] = !isNaN(num) ? num : 0
      }
      var paddingWidth = size.paddingLeft + size.paddingRight;
      var paddingHeight = size.paddingTop + size.paddingBottom;
      var marginWidth = size.marginLeft + size.marginRight;
      var marginHeight = size.marginTop + size.marginBottom;
      var borderWidth = size.borderLeftWidth + size.borderRightWidth;
      var borderHeight = size.borderTopWidth + size.borderBottomWidth;
      var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;
      var styleWidth = getStyleSize(style.width);
      if (styleWidth !== false) {
          size.width = styleWidth + (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth)
      }
      var styleHeight = getStyleSize(style.height);
      if (styleHeight !== false) {
          size.height = styleHeight + (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight)
      }
      size.innerWidth = size.width - (paddingWidth + borderWidth);
      size.innerHeight = size.height - (paddingHeight + borderHeight);
      size.outerWidth = size.width + marginWidth;
      size.outerHeight = size.height + marginHeight;
      return size
  }
  return getSize
});
(function(window, factory) {
  "use strict";
  if (typeof define == "function" && define.amd) {
      define("desandro-matches-selector/matches-selector", factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory()
  } else {
      window.matchesSelector = factory()
  }
})(window, function factory() {
  "use strict";
  var matchesMethod = function() {
      var ElemProto = window.Element.prototype;
      if (ElemProto.matches) {
          return "matches"
      }
      if (ElemProto.matchesSelector) {
          return "matchesSelector"
      }
      var prefixes = ["webkit", "moz", "ms", "o"];
      for (var i = 0; i < prefixes.length; i++) {
          var prefix = prefixes[i];
          var method = prefix + "MatchesSelector";
          if (ElemProto[method]) {
              return method
          }
      }
  }();
  return function matchesSelector(elem, selector) {
      return elem[matchesMethod](selector)
  }
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function(matchesSelector) {
          return factory(window, matchesSelector)
      })
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(window, require("desandro-matches-selector"))
  } else {
      window.fizzyUIUtils = factory(window, window.matchesSelector)
  }
})(window, function factory(window, matchesSelector) {
  var utils = {};
  utils.extend = function(a, b) {
      for (var prop in b) {
          a[prop] = b[prop]
      }
      return a
  };
  utils.modulo = function(num, div) {
      return (num % div + div) % div
  };
  var arraySlice = Array.prototype.slice;
  utils.makeArray = function(obj) {
      if (Array.isArray(obj)) {
          return obj
      }
      if (obj === null || obj === undefined) {
          return []
      }
      var isArrayLike = typeof obj == "object" && typeof obj.length == "number";
      if (isArrayLike) {
          return arraySlice.call(obj)
      }
      return [obj]
  };
  utils.removeFrom = function(ary, obj) {
      var index = ary.indexOf(obj);
      if (index != -1) {
          ary.splice(index, 1)
      }
  };
  utils.getParent = function(elem, selector) {
      while (elem.parentNode && elem != document.body) {
          elem = elem.parentNode;
          if (matchesSelector(elem, selector)) {
              return elem
          }
      }
  };
  utils.getQueryElement = function(elem) {
      if (typeof elem == "string") {
          return document.querySelector(elem)
      }
      return elem
  };
  utils.handleEvent = function(event) {
      var method = "on" + event.type;
      if (this[method]) {
          this[method](event)
      }
  };
  utils.filterFindElements = function(elems, selector) {
      elems = utils.makeArray(elems);
      var ffElems = [];
      elems.forEach(function(elem) {
          if (!(elem instanceof HTMLElement)) {
              return
          }
          if (!selector) {
              ffElems.push(elem);
              return
          }
          if (matchesSelector(elem, selector)) {
              ffElems.push(elem)
          }
          var childElems = elem.querySelectorAll(selector);
          for (var i = 0; i < childElems.length; i++) {
              ffElems.push(childElems[i])
          }
      });
      return ffElems
  };
  utils.debounceMethod = function(_class, methodName, threshold) {
      threshold = threshold || 100;
      var method = _class.prototype[methodName];
      var timeoutName = methodName + "Timeout";
      _class.prototype[methodName] = function() {
          var timeout = this[timeoutName];
          clearTimeout(timeout);
          var args = arguments;
          var _this = this;
          this[timeoutName] = setTimeout(function() {
              method.apply(_this, args);
              delete _this[timeoutName]
          }, threshold)
      }
  };
  utils.docReady = function(callback) {
      var readyState = document.readyState;
      if (readyState == "complete" || readyState == "interactive") {
          setTimeout(callback)
      } else {
          document.addEventListener("DOMContentLoaded", callback)
      }
  };
  utils.toDashed = function(str) {
      return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
          return $1 + "-" + $2
      }).toLowerCase()
  };
  var console = window.console;
  utils.htmlInit = function(WidgetClass, namespace) {
      utils.docReady(function() {
          var dashedNamespace = utils.toDashed(namespace);
          var dataAttr = "data-" + dashedNamespace;
          var dataAttrElems = document.querySelectorAll("[" + dataAttr + "]");
          var jsDashElems = document.querySelectorAll(".js-" + dashedNamespace);
          var elems = utils.makeArray(dataAttrElems).concat(utils.makeArray(jsDashElems));
          var dataOptionsAttr = dataAttr + "-options";
          var jQuery = window.jQuery;
          elems.forEach(function(elem) {
              var attr = elem.getAttribute(dataAttr) || elem.getAttribute(dataOptionsAttr);
              var options;
              try {
                  options = attr && JSON.parse(attr)
              } catch (error) {
                  if (console) {
                      console.error("Error parsing " + dataAttr + " on " + elem.className + ": " + error)
                  }
                  return
              }
              var instance = new WidgetClass(elem, options);
              if (jQuery) {
                  jQuery.data(elem, namespace, instance)
              }
          })
      })
  };
  return utils
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("ev-emitter"), require("get-size"))
  } else {
      window.Outlayer = {};
      window.Outlayer.Item = factory(window.EvEmitter, window.getSize)
  }
})(window, function factory(EvEmitter, getSize) {
  "use strict";

  function isEmptyObj(obj) {
      for (var prop in obj) {
          return false
      }
      prop = null;
      return true
  }
  var docElemStyle = document.documentElement.style;
  var transitionProperty = typeof docElemStyle.transition == "string" ? "transition" : "WebkitTransition";
  var transformProperty = typeof docElemStyle.transform == "string" ? "transform" : "WebkitTransform";
  var transitionEndEvent = {
      WebkitTransition: "webkitTransitionEnd",
      transition: "transitionend"
  } [transitionProperty];
  var vendorProperties = {
      transform: transformProperty,
      transition: transitionProperty,
      transitionDuration: transitionProperty + "Duration",
      transitionProperty: transitionProperty + "Property",
      transitionDelay: transitionProperty + "Delay"
  };

  function Item(element, layout) {
      if (!element) {
          return
      }
      this.element = element;
      this.layout = layout;
      this.position = {
          x: 0,
          y: 0
      };
      this._create()
  }
  var proto = Item.prototype = Object.create(EvEmitter.prototype);
  proto.constructor = Item;
  proto._create = function() {
      this._transn = {
          ingProperties: {},
          clean: {},
          onEnd: {}
      };
      this.css({
          position: "absolute"
      })
  };
  proto.handleEvent = function(event) {
      var method = "on" + event.type;
      if (this[method]) {
          this[method](event)
      }
  };
  proto.getSize = function() {
      this.size = getSize(this.element)
  };
  proto.css = function(style) {
      var elemStyle = this.element.style;
      for (var prop in style) {
          var supportedProp = vendorProperties[prop] || prop;
          elemStyle[supportedProp] = style[prop]
      }
  };
  proto.getPosition = function() {
      var style = getComputedStyle(this.element);
      var isOriginLeft = this.layout._getOption("originLeft");
      var isOriginTop = this.layout._getOption("originTop");
      var xValue = style[isOriginLeft ? "left" : "right"];
      var yValue = style[isOriginTop ? "top" : "bottom"];
      var x = parseFloat(xValue);
      var y = parseFloat(yValue);
      var layoutSize = this.layout.size;
      if (xValue.indexOf("%") != -1) {
          x = x / 100 * layoutSize.width
      }
      if (yValue.indexOf("%") != -1) {
          y = y / 100 * layoutSize.height
      }
      x = isNaN(x) ? 0 : x;
      y = isNaN(y) ? 0 : y;
      x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
      y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;
      this.position.x = x;
      this.position.y = y
  };
  proto.layoutPosition = function() {
      var layoutSize = this.layout.size;
      var style = {};
      var isOriginLeft = this.layout._getOption("originLeft");
      var isOriginTop = this.layout._getOption("originTop");
      var xPadding = isOriginLeft ? "paddingLeft" : "paddingRight";
      var xProperty = isOriginLeft ? "left" : "right";
      var xResetProperty = isOriginLeft ? "right" : "left";
      var x = this.position.x + layoutSize[xPadding];
      style[xProperty] = this.getXValue(x);
      style[xResetProperty] = "";
      var yPadding = isOriginTop ? "paddingTop" : "paddingBottom";
      var yProperty = isOriginTop ? "top" : "bottom";
      var yResetProperty = isOriginTop ? "bottom" : "top";
      var y = this.position.y + layoutSize[yPadding];
      style[yProperty] = this.getYValue(y);
      style[yResetProperty] = "";
      this.css(style);
      this.emitEvent("layout", [this])
  };
  proto.getXValue = function(x) {
      var isHorizontal = this.layout._getOption("horizontal");
      return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + "%" : x + "px"
  };
  proto.getYValue = function(y) {
      var isHorizontal = this.layout._getOption("horizontal");
      return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + "%" : y + "px"
  };
  proto._transitionTo = function(x, y) {
      this.getPosition();
      var curX = this.position.x;
      var curY = this.position.y;
      var didNotMove = x == this.position.x && y == this.position.y;
      this.setPosition(x, y);
      if (didNotMove && !this.isTransitioning) {
          this.layoutPosition();
          return
      }
      var transX = x - curX;
      var transY = y - curY;
      var transitionStyle = {};
      transitionStyle.transform = this.getTranslate(transX, transY);
      this.transition({
          to: transitionStyle,
          onTransitionEnd: {
              transform: this.layoutPosition
          },
          isCleaning: true
      })
  };
  proto.getTranslate = function(x, y) {
      var isOriginLeft = this.layout._getOption("originLeft");
      var isOriginTop = this.layout._getOption("originTop");
      x = isOriginLeft ? x : -x;
      y = isOriginTop ? y : -y;
      return "translate3d(" + x + "px, " + y + "px, 0)"
  };
  proto.goTo = function(x, y) {
      this.setPosition(x, y);
      this.layoutPosition()
  };
  proto.moveTo = proto._transitionTo;
  proto.setPosition = function(x, y) {
      this.position.x = parseFloat(x);
      this.position.y = parseFloat(y)
  };
  proto._nonTransition = function(args) {
      this.css(args.to);
      if (args.isCleaning) {
          this._removeStyles(args.to)
      }
      for (var prop in args.onTransitionEnd) {
          args.onTransitionEnd[prop].call(this)
      }
  };
  proto.transition = function(args) {
      if (!parseFloat(this.layout.options.transitionDuration)) {
          this._nonTransition(args);
          return
      }
      var _transition = this._transn;
      for (var prop in args.onTransitionEnd) {
          _transition.onEnd[prop] = args.onTransitionEnd[prop]
      }
      for (prop in args.to) {
          _transition.ingProperties[prop] = true;
          if (args.isCleaning) {
              _transition.clean[prop] = true
          }
      }
      if (args.from) {
          this.css(args.from);
          var h = this.element.offsetHeight;
          h = null
      }
      this.enableTransition(args.to);
      this.css(args.to);
      this.isTransitioning = true
  };

  function toDashedAll(str) {
      return str.replace(/([A-Z])/g, function($1) {
          return "-" + $1.toLowerCase()
      })
  }
  var transitionProps = "opacity," + toDashedAll(transformProperty);
  proto.enableTransition = function() {
      if (this.isTransitioning) {
          return
      }
      var duration = this.layout.options.transitionDuration;
      duration = typeof duration == "number" ? duration + "ms" : duration;
      this.css({
          transitionProperty: transitionProps,
          transitionDuration: duration,
          transitionDelay: this.staggerDelay || 0
      });
      this.element.addEventListener(transitionEndEvent, this, false)
  };
  proto.onwebkitTransitionEnd = function(event) {
      this.ontransitionend(event)
  };
  proto.onotransitionend = function(event) {
      this.ontransitionend(event)
  };
  var dashedVendorProperties = {
      "-webkit-transform": "transform"
  };
  proto.ontransitionend = function(event) {
      if (event.target !== this.element) {
          return
      }
      var _transition = this._transn;
      var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;
      delete _transition.ingProperties[propertyName];
      if (isEmptyObj(_transition.ingProperties)) {
          this.disableTransition()
      }
      if (propertyName in _transition.clean) {
          this.element.style[event.propertyName] = "";
          delete _transition.clean[propertyName]
      }
      if (propertyName in _transition.onEnd) {
          var onTransitionEnd = _transition.onEnd[propertyName];
          onTransitionEnd.call(this);
          delete _transition.onEnd[propertyName]
      }
      this.emitEvent("transitionEnd", [this])
  };
  proto.disableTransition = function() {
      this.removeTransitionStyles();
      this.element.removeEventListener(transitionEndEvent, this, false);
      this.isTransitioning = false
  };
  proto._removeStyles = function(style) {
      var cleanStyle = {};
      for (var prop in style) {
          cleanStyle[prop] = ""
      }
      this.css(cleanStyle)
  };
  var cleanTransitionStyle = {
      transitionProperty: "",
      transitionDuration: "",
      transitionDelay: ""
  };
  proto.removeTransitionStyles = function() {
      this.css(cleanTransitionStyle)
  };
  proto.stagger = function(delay) {
      delay = isNaN(delay) ? 0 : delay;
      this.staggerDelay = delay + "ms"
  };
  proto.removeElem = function() {
      this.element.parentNode.removeChild(this.element);
      this.css({
          display: ""
      });
      this.emitEvent("remove", [this])
  };
  proto.remove = function() {
      if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {
          this.removeElem();
          return
      }
      this.once("transitionEnd", function() {
          this.removeElem()
      });
      this.hide()
  };
  proto.reveal = function() {
      delete this.isHidden;
      this.css({
          display: ""
      });
      var options = this.layout.options;
      var onTransitionEnd = {};
      var transitionEndProperty = this.getHideRevealTransitionEndProperty("visibleStyle");
      onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;
      this.transition({
          from: options.hiddenStyle,
          to: options.visibleStyle,
          isCleaning: true,
          onTransitionEnd: onTransitionEnd
      })
  };
  proto.onRevealTransitionEnd = function() {
      if (!this.isHidden) {
          this.emitEvent("reveal")
      }
  };
  proto.getHideRevealTransitionEndProperty = function(styleProperty) {
      var optionStyle = this.layout.options[styleProperty];
      if (optionStyle.opacity) {
          return "opacity"
      }
      for (var prop in optionStyle) {
          return prop
      }
  };
  proto.hide = function() {
      this.isHidden = true;
      this.css({
          display: ""
      });
      var options = this.layout.options;
      var onTransitionEnd = {};
      var transitionEndProperty = this.getHideRevealTransitionEndProperty("hiddenStyle");
      onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;
      this.transition({
          from: options.visibleStyle,
          to: options.hiddenStyle,
          isCleaning: true,
          onTransitionEnd: onTransitionEnd
      })
  };
  proto.onHideTransitionEnd = function() {
      if (this.isHidden) {
          this.css({
              display: "none"
          });
          this.emitEvent("hide")
      }
  };
  proto.destroy = function() {
      this.css({
          position: "",
          left: "",
          right: "",
          top: "",
          bottom: "",
          transition: "",
          transform: ""
      })
  };
  return Item
});
(function(window, factory) {
  "use strict";
  if (typeof define == "function" && define.amd) {
      define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], function(EvEmitter, getSize, utils, Item) {
          return factory(window, EvEmitter, getSize, utils, Item)
      })
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(window, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item"))
  } else {
      window.Outlayer = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, window.Outlayer.Item)
  }
})(window, function factory(window, EvEmitter, getSize, utils, Item) {
  "use strict";
  var console = window.console;
  var jQuery = window.jQuery;
  var noop = function() {};
  var GUID = 0;
  var instances = {};

  function Outlayer(element, options) {
      var queryElement = utils.getQueryElement(element);
      if (!queryElement) {
          if (console) {
              console.error("Bad element for " + this.constructor.namespace + ": " + (queryElement || element))
          }
          return
      }
      this.element = queryElement;
      if (jQuery) {
          this.$element = jQuery(this.element)
      }
      this.options = utils.extend({}, this.constructor.defaults);
      this.option(options);
      var id = ++GUID;
      this.element.outlayerGUID = id;
      instances[id] = this;
      this._create();
      var isInitLayout = this._getOption("initLayout");
      if (isInitLayout) {
          this.layout()
      }
  }
  Outlayer.namespace = "outlayer";
  Outlayer.Item = Item;
  Outlayer.defaults = {
      containerStyle: {
          position: "relative"
      },
      initLayout: true,
      originLeft: true,
      originTop: true,
      resize: true,
      resizeContainer: true,
      transitionDuration: "0.4s",
      hiddenStyle: {
          opacity: 0,
          transform: "scale(0.001)"
      },
      visibleStyle: {
          opacity: 1,
          transform: "scale(1)"
      }
  };
  var proto = Outlayer.prototype;
  utils.extend(proto, EvEmitter.prototype);
  proto.option = function(opts) {
      utils.extend(this.options, opts)
  };
  proto._getOption = function(option) {
      var oldOption = this.constructor.compatOptions[option];
      return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option]
  };
  Outlayer.compatOptions = {
      initLayout: "isInitLayout",
      horizontal: "isHorizontal",
      layoutInstant: "isLayoutInstant",
      originLeft: "isOriginLeft",
      originTop: "isOriginTop",
      resize: "isResizeBound",
      resizeContainer: "isResizingContainer"
  };
  proto._create = function() {
      this.reloadItems();
      this.stamps = [];
      this.stamp(this.options.stamp);
      utils.extend(this.element.style, this.options.containerStyle);
      var canBindResize = this._getOption("resize");
      if (canBindResize) {
          this.bindResize()
      }
  };
  proto.reloadItems = function() {
      this.items = this._itemize(this.element.children)
  };
  proto._itemize = function(elems) {
      var itemElems = this._filterFindItemElements(elems);
      var Item = this.constructor.Item;
      var items = [];
      for (var i = 0; i < itemElems.length; i++) {
          var elem = itemElems[i];
          var item = new Item(elem, this);
          items.push(item)
      }
      return items
  };
  proto._filterFindItemElements = function(elems) {
      return utils.filterFindElements(elems, this.options.itemSelector)
  };
  proto.getItemElements = function() {
      return this.items.map(function(item) {
          return item.element
      })
  };
  proto.layout = function() {
      this._resetLayout();
      this._manageStamps();
      var layoutInstant = this._getOption("layoutInstant");
      var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;
      this.layoutItems(this.items, isInstant);
      this._isLayoutInited = true
  };
  proto._init = proto.layout;
  proto._resetLayout = function() {
      this.getSize()
  };
  proto.getSize = function() {
      this.size = getSize(this.element)
  };
  proto._getMeasurement = function(measurement, size) {
      var option = this.options[measurement];
      var elem;
      if (!option) {
          this[measurement] = 0
      } else {
          if (typeof option == "string") {
              elem = this.element.querySelector(option)
          } else if (option instanceof HTMLElement) {
              elem = option
          }
          this[measurement] = elem ? getSize(elem)[size] : option
      }
  };
  proto.layoutItems = function(items, isInstant) {
      items = this._getItemsForLayout(items);
      this._layoutItems(items, isInstant);
      this._postLayout()
  };
  proto._getItemsForLayout = function(items) {
      return items.filter(function(item) {
          return !item.isIgnored
      })
  };
  proto._layoutItems = function(items, isInstant) {
      this._emitCompleteOnItems("layout", items);
      if (!items || !items.length) {
          return
      }
      var queue = [];
      items.forEach(function(item) {
          var position = this._getItemLayoutPosition(item);
          position.item = item;
          position.isInstant = isInstant || item.isLayoutInstant;
          queue.push(position)
      }, this);
      this._processLayoutQueue(queue)
  };
  proto._getItemLayoutPosition = function() {
      return {
          x: 0,
          y: 0
      }
  };
  proto._processLayoutQueue = function(queue) {
      this.updateStagger();
      queue.forEach(function(obj, i) {
          this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i)
      }, this)
  };
  proto.updateStagger = function() {
      var stagger = this.options.stagger;
      if (stagger === null || stagger === undefined) {
          this.stagger = 0;
          return
      }
      this.stagger = getMilliseconds(stagger);
      return this.stagger
  };
  proto._positionItem = function(item, x, y, isInstant, i) {
      if (isInstant) {
          item.goTo(x, y)
      } else {
          item.stagger(i * this.stagger);
          item.moveTo(x, y)
      }
  };
  proto._postLayout = function() {
      this.resizeContainer()
  };
  proto.resizeContainer = function() {
      var isResizingContainer = this._getOption("resizeContainer");
      if (!isResizingContainer) {
          return
      }
      var size = this._getContainerSize();
      if (size) {
          this._setContainerMeasure(size.width, true);
          this._setContainerMeasure(size.height, false)
      }
  };
  proto._getContainerSize = noop;
  proto._setContainerMeasure = function(measure, isWidth) {
      if (measure === undefined) {
          return
      }
      var elemSize = this.size;
      if (elemSize.isBorderBox) {
          measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth
      }
      measure = Math.max(measure, 0);
      this.element.style[isWidth ? "width" : "height"] = measure + "px"
  };
  proto._emitCompleteOnItems = function(eventName, items) {
      var _this = this;

      function onComplete() {
          _this.dispatchEvent(eventName + "Complete", null, [items])
      }
      var count = items.length;
      if (!items || !count) {
          onComplete();
          return
      }
      var doneCount = 0;

      function tick() {
          doneCount++;
          if (doneCount == count) {
              onComplete()
          }
      }
      items.forEach(function(item) {
          item.once(eventName, tick)
      })
  };
  proto.dispatchEvent = function(type, event, args) {
      var emitArgs = event ? [event].concat(args) : args;
      this.emitEvent(type, emitArgs);
      if (jQuery) {
          this.$element = this.$element || jQuery(this.element);
          if (event) {
              var $event = jQuery.Event(event);
              $event.type = type;
              this.$element.trigger($event, args)
          } else {
              this.$element.trigger(type, args)
          }
      }
  };
  proto.ignore = function(elem) {
      var item = this.getItem(elem);
      if (item) {
          item.isIgnored = true
      }
  };
  proto.unignore = function(elem) {
      var item = this.getItem(elem);
      if (item) {
          delete item.isIgnored
      }
  };
  proto.stamp = function(elems) {
      elems = this._find(elems);
      if (!elems) {
          return
      }
      this.stamps = this.stamps.concat(elems);
      elems.forEach(this.ignore, this)
  };
  proto.unstamp = function(elems) {
      elems = this._find(elems);
      if (!elems) {
          return
      }
      elems.forEach(function(elem) {
          utils.removeFrom(this.stamps, elem);
          this.unignore(elem)
      }, this)
  };
  proto._find = function(elems) {
      if (!elems) {
          return
      }
      if (typeof elems == "string") {
          elems = this.element.querySelectorAll(elems)
      }
      elems = utils.makeArray(elems);
      return elems
  };
  proto._manageStamps = function() {
      if (!this.stamps || !this.stamps.length) {
          return
      }
      this._getBoundingRect();
      this.stamps.forEach(this._manageStamp, this)
  };
  proto._getBoundingRect = function() {
      var boundingRect = this.element.getBoundingClientRect();
      var size = this.size;
      this._boundingRect = {
          left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
          top: boundingRect.top + size.paddingTop + size.borderTopWidth,
          right: boundingRect.right - (size.paddingRight + size.borderRightWidth),
          bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)
      }
  };
  proto._manageStamp = noop;
  proto._getElementOffset = function(elem) {
      var boundingRect = elem.getBoundingClientRect();
      var thisRect = this._boundingRect;
      var size = getSize(elem);
      var offset = {
          left: boundingRect.left - thisRect.left - size.marginLeft,
          top: boundingRect.top - thisRect.top - size.marginTop,
          right: thisRect.right - boundingRect.right - size.marginRight,
          bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
      };
      return offset
  };
  proto.handleEvent = utils.handleEvent;
  proto.bindResize = function() {
      window.addEventListener("resize", this);
      this.isResizeBound = true
  };
  proto.unbindResize = function() {
      window.removeEventListener("resize", this);
      this.isResizeBound = false
  };
  proto.onresize = function() {
      this.resize()
  };
  utils.debounceMethod(Outlayer, "onresize", 100);
  proto.resize = function() {
      if (!this.isResizeBound || !this.needsResizeLayout()) {
          return
      }
      this.layout()
  };
  proto.needsResizeLayout = function() {
      var size = getSize(this.element);
      var hasSizes = this.size && size;
      return hasSizes && size.innerWidth !== this.size.innerWidth
  };
  proto.addItems = function(elems) {
      var items = this._itemize(elems);
      if (items.length) {
          this.items = this.items.concat(items)
      }
      return items
  };
  proto.appended = function(elems) {
      var items = this.addItems(elems);
      if (!items.length) {
          return
      }
      this.layoutItems(items, true);
      this.reveal(items)
  };
  proto.prepended = function(elems) {
      var items = this._itemize(elems);
      if (!items.length) {
          return
      }
      var previousItems = this.items.slice(0);
      this.items = items.concat(previousItems);
      this._resetLayout();
      this._manageStamps();
      this.layoutItems(items, true);
      this.reveal(items);
      this.layoutItems(previousItems)
  };
  proto.reveal = function(items) {
      this._emitCompleteOnItems("reveal", items);
      if (!items || !items.length) {
          return
      }
      var stagger = this.updateStagger();
      items.forEach(function(item, i) {
          item.stagger(i * stagger);
          item.reveal()
      })
  };
  proto.hide = function(items) {
      this._emitCompleteOnItems("hide", items);
      if (!items || !items.length) {
          return
      }
      var stagger = this.updateStagger();
      items.forEach(function(item, i) {
          item.stagger(i * stagger);
          item.hide()
      })
  };
  proto.revealItemElements = function(elems) {
      var items = this.getItems(elems);
      this.reveal(items)
  };
  proto.hideItemElements = function(elems) {
      var items = this.getItems(elems);
      this.hide(items)
  };
  proto.getItem = function(elem) {
      for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          if (item.element == elem) {
              return item
          }
      }
  };
  proto.getItems = function(elems) {
      elems = utils.makeArray(elems);
      var items = [];
      elems.forEach(function(elem) {
          var item = this.getItem(elem);
          if (item) {
              items.push(item)
          }
      }, this);
      return items
  };
  proto.remove = function(elems) {
      var removeItems = this.getItems(elems);
      this._emitCompleteOnItems("remove", removeItems);
      if (!removeItems || !removeItems.length) {
          return
      }
      removeItems.forEach(function(item) {
          item.remove();
          utils.removeFrom(this.items, item)
      }, this)
  };
  proto.destroy = function() {
      var style = this.element.style;
      style.height = "";
      style.position = "";
      style.width = "";
      this.items.forEach(function(item) {
          item.destroy()
      });
      this.unbindResize();
      var id = this.element.outlayerGUID;
      delete instances[id];
      delete this.element.outlayerGUID;
      if (jQuery) {
          jQuery.removeData(this.element, this.constructor.namespace)
      }
  };
  Outlayer.data = function(elem) {
      elem = utils.getQueryElement(elem);
      var id = elem && elem.outlayerGUID;
      return id && instances[id]
  };
  Outlayer.create = function(namespace, options) {
      var Layout = subclass(Outlayer);
      Layout.defaults = utils.extend({}, Outlayer.defaults);
      utils.extend(Layout.defaults, options);
      Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);
      Layout.namespace = namespace;
      Layout.data = Outlayer.data;
      Layout.Item = subclass(Item);
      utils.htmlInit(Layout, namespace);
      if (jQuery && jQuery.bridget) {
          jQuery.bridget(namespace, Layout)
      }
      return Layout
  };

  function subclass(Parent) {
      function SubClass() {
          Parent.apply(this, arguments)
      }
      SubClass.prototype = Object.create(Parent.prototype);
      SubClass.prototype.constructor = SubClass;
      return SubClass
  }
  var msUnits = {
      ms: 1,
      s: 1e3
  };

  function getMilliseconds(time) {
      if (typeof time == "number") {
          return time
      }
      var matches = time.match(/(^\d*\.?\d*)(\w*)/);
      var num = matches && matches[1];
      var unit = matches && matches[2];
      if (!num.length) {
          return 0
      }
      num = parseFloat(num);
      var mult = msUnits[unit] || 1;
      return num * mult
  }
  Outlayer.Item = Item;
  return Outlayer
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("isotope-layout/js/item", ["outlayer/outlayer"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("outlayer"))
  } else {
      window.Isotope = window.Isotope || {};
      window.Isotope.Item = factory(window.Outlayer)
  }
})(window, function factory(Outlayer) {
  "use strict";

  function Item() {
      Outlayer.Item.apply(this, arguments)
  }
  var proto = Item.prototype = Object.create(Outlayer.Item.prototype);
  var _create = proto._create;
  proto._create = function() {
      this.id = this.layout.itemGUID++;
      _create.call(this);
      this.sortData = {}
  };
  proto.updateSortData = function() {
      if (this.isIgnored) {
          return
      }
      this.sortData.id = this.id;
      this.sortData["original-order"] = this.id;
      this.sortData.random = Math.random();
      var getSortData = this.layout.options.getSortData;
      var sorters = this.layout._sorters;
      for (var key in getSortData) {
          var sorter = sorters[key];
          this.sortData[key] = sorter(this.element, this)
      }
  };
  var _destroy = proto.destroy;
  proto.destroy = function() {
      _destroy.apply(this, arguments);
      this.css({
          display: ""
      })
  };
  return Item
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("get-size"), require("outlayer"))
  } else {
      window.Isotope = window.Isotope || {};
      window.Isotope.LayoutMode = factory(window.getSize, window.Outlayer)
  }
})(window, function factory(getSize, Outlayer) {
  "use strict";

  function LayoutMode(isotope) {
      this.isotope = isotope;
      if (isotope) {
          this.options = isotope.options[this.namespace];
          this.element = isotope.element;
          this.items = isotope.filteredItems;
          this.size = isotope.size
      }
  }
  var proto = LayoutMode.prototype;
  var facadeMethods = ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"];
  facadeMethods.forEach(function(methodName) {
      proto[methodName] = function() {
          return Outlayer.prototype[methodName].apply(this.isotope, arguments)
      }
  });
  proto.needsVerticalResizeLayout = function() {
      var size = getSize(this.isotope.element);
      var hasSizes = this.isotope.size && size;
      return hasSizes && size.innerHeight != this.isotope.size.innerHeight
  };
  proto._getMeasurement = function() {
      this.isotope._getMeasurement.apply(this, arguments)
  };
  proto.getColumnWidth = function() {
      this.getSegmentSize("column", "Width")
  };
  proto.getRowHeight = function() {
      this.getSegmentSize("row", "Height")
  };
  proto.getSegmentSize = function(segment, size) {
      var segmentName = segment + size;
      var outerSize = "outer" + size;
      this._getMeasurement(segmentName, outerSize);
      if (this[segmentName]) {
          return
      }
      var firstItemSize = this.getFirstItemSize();
      this[segmentName] = firstItemSize && firstItemSize[outerSize] || this.isotope.size["inner" + size]
  };
  proto.getFirstItemSize = function() {
      var firstItem = this.isotope.filteredItems[0];
      return firstItem && firstItem.element && getSize(firstItem.element)
  };
  proto.layout = function() {
      this.isotope.layout.apply(this.isotope, arguments)
  };
  proto.getSize = function() {
      this.isotope.getSize();
      this.size = this.isotope.size
  };
  LayoutMode.modes = {};
  LayoutMode.create = function(namespace, options) {
      function Mode() {
          LayoutMode.apply(this, arguments)
      }
      Mode.prototype = Object.create(proto);
      Mode.prototype.constructor = Mode;
      if (options) {
          Mode.options = options
      }
      Mode.prototype.namespace = namespace;
      LayoutMode.modes[namespace] = Mode;
      return Mode
  };
  return LayoutMode
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("outlayer"), require("get-size"))
  } else {
      window.Masonry = factory(window.Outlayer, window.getSize)
  }
})(window, function factory(Outlayer, getSize) {
  var Masonry = Outlayer.create("masonry");
  Masonry.compatOptions.fitWidth = "isFitWidth";
  var proto = Masonry.prototype;
  proto._resetLayout = function() {
      this.getSize();
      this._getMeasurement("columnWidth", "outerWidth");
      this._getMeasurement("gutter", "outerWidth");
      this.measureColumns();
      this.colYs = [];
      for (var i = 0; i < this.cols; i++) {
          this.colYs.push(0)
      }
      this.maxY = 0;
      this.horizontalColIndex = 0
  };
  proto.measureColumns = function() {
      this.getContainerWidth();
      if (!this.columnWidth) {
          var firstItem = this.items[0];
          var firstItemElem = firstItem && firstItem.element;
          this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || this.containerWidth
      }
      var columnWidth = this.columnWidth += this.gutter;
      var containerWidth = this.containerWidth + this.gutter;
      var cols = containerWidth / columnWidth;
      var excess = columnWidth - containerWidth % columnWidth;
      var mathMethod = excess && excess < 1 ? "round" : "floor";
      cols = Math[mathMethod](cols);
      this.cols = Math.max(cols, 1)
  };
  proto.getContainerWidth = function() {
      var isFitWidth = this._getOption("fitWidth");
      var container = isFitWidth ? this.element.parentNode : this.element;
      var size = getSize(container);
      this.containerWidth = size && size.innerWidth
  };
  proto._getItemLayoutPosition = function(item) {
      item.getSize();
      var remainder = item.size.outerWidth % this.columnWidth;
      var mathMethod = remainder && remainder < 1 ? "round" : "ceil";
      var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);
      colSpan = Math.min(colSpan, this.cols);
      var colPosMethod = this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition";
      var colPosition = this[colPosMethod](colSpan, item);
      var position = {
          x: this.columnWidth * colPosition.col,
          y: colPosition.y
      };
      var setHeight = colPosition.y + item.size.outerHeight;
      var setMax = colSpan + colPosition.col;
      for (var i = colPosition.col; i < setMax; i++) {
          this.colYs[i] = setHeight
      }
      return position
  };
  proto._getTopColPosition = function(colSpan) {
      var colGroup = this._getTopColGroup(colSpan);
      var minimumY = Math.min.apply(Math, colGroup);
      return {
          col: colGroup.indexOf(minimumY),
          y: minimumY
      }
  };
  proto._getTopColGroup = function(colSpan) {
      if (colSpan < 2) {
          return this.colYs
      }
      var colGroup = [];
      var groupCount = this.cols + 1 - colSpan;
      for (var i = 0; i < groupCount; i++) {
          colGroup[i] = this._getColGroupY(i, colSpan)
      }
      return colGroup
  };
  proto._getColGroupY = function(col, colSpan) {
      if (colSpan < 2) {
          return this.colYs[col]
      }
      var groupColYs = this.colYs.slice(col, col + colSpan);
      return Math.max.apply(Math, groupColYs)
  };
  proto._getHorizontalColPosition = function(colSpan, item) {
      var col = this.horizontalColIndex % this.cols;
      var isOver = colSpan > 1 && col + colSpan > this.cols;
      col = isOver ? 0 : col;
      var hasSize = item.size.outerWidth && item.size.outerHeight;
      this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;
      return {
          col: col,
          y: this._getColGroupY(col, colSpan)
      }
  };
  proto._manageStamp = function(stamp) {
      var stampSize = getSize(stamp);
      var offset = this._getElementOffset(stamp);
      var isOriginLeft = this._getOption("originLeft");
      var firstX = isOriginLeft ? offset.left : offset.right;
      var lastX = firstX + stampSize.outerWidth;
      var firstCol = Math.floor(firstX / this.columnWidth);
      firstCol = Math.max(0, firstCol);
      var lastCol = Math.floor(lastX / this.columnWidth);
      lastCol -= lastX % this.columnWidth ? 0 : 1;
      lastCol = Math.min(this.cols - 1, lastCol);
      var isOriginTop = this._getOption("originTop");
      var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;
      for (var i = firstCol; i <= lastCol; i++) {
          this.colYs[i] = Math.max(stampMaxY, this.colYs[i])
      }
  };
  proto._getContainerSize = function() {
      this.maxY = Math.max.apply(Math, this.colYs);
      var size = {
          height: this.maxY
      };
      if (this._getOption("fitWidth")) {
          size.width = this._getContainerFitWidth()
      }
      return size
  };
  proto._getContainerFitWidth = function() {
      var unusedCols = 0;
      var i = this.cols;
      while (--i) {
          if (this.colYs[i] !== 0) {
              break
          }
          unusedCols++
      }
      return (this.cols - unusedCols) * this.columnWidth - this.gutter
  };
  proto.needsResizeLayout = function() {
      var previousWidth = this.containerWidth;
      this.getContainerWidth();
      return previousWidth != this.containerWidth
  };
  return Masonry
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("../layout-mode"), require("masonry-layout"))
  } else {
      factory(window.Isotope.LayoutMode, window.Masonry)
  }
})(window, function factory(LayoutMode, Masonry) {
  "use strict";
  var MasonryMode = LayoutMode.create("masonry");
  var proto = MasonryMode.prototype;
  var keepModeMethods = {
      _getElementOffset: true,
      layout: true,
      _getMeasurement: true
  };
  for (var method in Masonry.prototype) {
      if (!keepModeMethods[method]) {
          proto[method] = Masonry.prototype[method]
      }
  }
  var measureColumns = proto.measureColumns;
  proto.measureColumns = function() {
      this.items = this.isotope.filteredItems;
      measureColumns.call(this)
  };
  var _getOption = proto._getOption;
  proto._getOption = function(option) {
      if (option == "fitWidth") {
          return this.options.isFitWidth !== undefined ? this.options.isFitWidth : this.options.fitWidth
      }
      return _getOption.apply(this.isotope, arguments)
  };
  return MasonryMode
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], factory)
  } else if (typeof exports == "object") {
      module.exports = factory(require("../layout-mode"))
  } else {
      factory(window.Isotope.LayoutMode)
  }
})(window, function factory(LayoutMode) {
  "use strict";
  var FitRows = LayoutMode.create("fitRows");
  var proto = FitRows.prototype;
  proto._resetLayout = function() {
      this.x = 0;
      this.y = 0;
      this.maxY = 0;
      this._getMeasurement("gutter", "outerWidth")
  };
  proto._getItemLayoutPosition = function(item) {
      item.getSize();
      var itemWidth = item.size.outerWidth + this.gutter;
      var containerWidth = this.isotope.size.innerWidth + this.gutter;
      if (this.x !== 0 && itemWidth + this.x > containerWidth) {
          this.x = 0;
          this.y = this.maxY
      }
      var position = {
          x: this.x,
          y: this.y
      };
      this.maxY = Math.max(this.maxY, this.y + item.size.outerHeight);
      this.x += itemWidth;
      return position
  };
  proto._getContainerSize = function() {
      return {
          height: this.maxY
      }
  };
  return FitRows
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], factory)
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(require("../layout-mode"))
  } else {
      factory(window.Isotope.LayoutMode)
  }
})(window, function factory(LayoutMode) {
  "use strict";
  var Vertical = LayoutMode.create("vertical", {
      horizontalAlignment: 0
  });
  var proto = Vertical.prototype;
  proto._resetLayout = function() {
      this.y = 0
  };
  proto._getItemLayoutPosition = function(item) {
      item.getSize();
      var x = (this.isotope.size.innerWidth - item.size.outerWidth) * this.options.horizontalAlignment;
      var y = this.y;
      this.y += item.size.outerHeight;
      return {
          x: x,
          y: y
      }
  };
  proto._getContainerSize = function() {
      return {
          height: this.y
      }
  };
  return Vertical
});
(function(window, factory) {
  if (typeof define == "function" && define.amd) {
      define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], function(Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
          return factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode)
      })
  } else if (typeof module == "object" && module.exports) {
      module.exports = factory(window, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical"))
  } else {
      window.Isotope = factory(window, window.Outlayer, window.getSize, window.matchesSelector, window.fizzyUIUtils, window.Isotope.Item, window.Isotope.LayoutMode)
  }
})(window, function factory(window, Outlayer, getSize, matchesSelector, utils, Item, LayoutMode) {
  var jQuery = window.jQuery;
  var trim = String.prototype.trim ? function(str) {
      return str.trim()
  } : function(str) {
      return str.replace(/^\s+|\s+$/g, "")
  };
  var Isotope = Outlayer.create("isotope", {
      layoutMode: "masonry",
      isJQueryFiltering: true,
      sortAscending: true
  });
  Isotope.Item = Item;
  Isotope.LayoutMode = LayoutMode;
  var proto = Isotope.prototype;
  proto._create = function() {
      this.itemGUID = 0;
      this._sorters = {};
      this._getSorters();
      Outlayer.prototype._create.call(this);
      this.modes = {};
      this.filteredItems = this.items;
      this.sortHistory = ["original-order"];
      for (var name in LayoutMode.modes) {
          this._initLayoutMode(name)
      }
  };
  proto.reloadItems = function() {
      this.itemGUID = 0;
      Outlayer.prototype.reloadItems.call(this)
  };
  proto._itemize = function() {
      var items = Outlayer.prototype._itemize.apply(this, arguments);
      for (var i = 0; i < items.length; i++) {
          var item = items[i];
          item.id = this.itemGUID++
      }
      this._updateItemsSortData(items);
      return items
  };
  proto._initLayoutMode = function(name) {
      var Mode = LayoutMode.modes[name];
      var initialOpts = this.options[name] || {};
      this.options[name] = Mode.options ? utils.extend(Mode.options, initialOpts) : initialOpts;
      this.modes[name] = new Mode(this)
  };
  proto.layout = function() {
      if (!this._isLayoutInited && this._getOption("initLayout")) {
          this.arrange();
          return
      }
      this._layout()
  };
  proto._layout = function() {
      var isInstant = this._getIsInstant();
      this._resetLayout();
      this._manageStamps();
      this.layoutItems(this.filteredItems, isInstant);
      this._isLayoutInited = true
  };
  proto.arrange = function(opts) {
      this.option(opts);
      this._getIsInstant();
      var filtered = this._filter(this.items);
      this.filteredItems = filtered.matches;
      this._bindArrangeComplete();
      if (this._isInstant) {
          this._noTransition(this._hideReveal, [filtered])
      } else {
          this._hideReveal(filtered)
      }
      this._sort();
      this._layout()
  };
  proto._init = proto.arrange;
  proto._hideReveal = function(filtered) {
      this.reveal(filtered.needReveal);
      this.hide(filtered.needHide)
  };
  proto._getIsInstant = function() {
      var isLayoutInstant = this._getOption("layoutInstant");
      var isInstant = isLayoutInstant !== undefined ? isLayoutInstant : !this._isLayoutInited;
      this._isInstant = isInstant;
      return isInstant
  };
  proto._bindArrangeComplete = function() {
      var isLayoutComplete, isHideComplete, isRevealComplete;
      var _this = this;

      function arrangeParallelCallback() {
          if (isLayoutComplete && isHideComplete && isRevealComplete) {
              _this.dispatchEvent("arrangeComplete", null, [_this.filteredItems])
          }
      }
      this.once("layoutComplete", function() {
          isLayoutComplete = true;
          arrangeParallelCallback()
      });
      this.once("hideComplete", function() {
          isHideComplete = true;
          arrangeParallelCallback()
      });
      this.once("revealComplete", function() {
          isRevealComplete = true;
          arrangeParallelCallback()
      })
  };
  proto._filter = function(items) {
      var filter = this.options.filter;
      filter = filter || "*";
      var matches = [];
      var hiddenMatched = [];
      var visibleUnmatched = [];
      var test = this._getFilterTest(filter);
      for (var i = 0; i < items.length; i++) {
          var item = items[i];
          if (item.isIgnored) {
              continue
          }
          var isMatched = test(item);
          if (isMatched) {
              matches.push(item)
          }
          if (isMatched && item.isHidden) {
              hiddenMatched.push(item)
          } else if (!isMatched && !item.isHidden) {
              visibleUnmatched.push(item)
          }
      }
      return {
          matches: matches,
          needReveal: hiddenMatched,
          needHide: visibleUnmatched
      }
  };
  proto._getFilterTest = function(filter) {
      if (jQuery && this.options.isJQueryFiltering) {
          return function(item) {
              return jQuery(item.element).is(filter)
          }
      }
      if (typeof filter == "function") {
          return function(item) {
              return filter(item.element)
          }
      }
      return function(item) {
          return matchesSelector(item.element, filter)
      }
  };
  proto.updateSortData = function(elems) {
      var items;
      if (elems) {
          elems = utils.makeArray(elems);
          items = this.getItems(elems)
      } else {
          items = this.items
      }
      this._getSorters();
      this._updateItemsSortData(items)
  };
  proto._getSorters = function() {
      var getSortData = this.options.getSortData;
      for (var key in getSortData) {
          var sorter = getSortData[key];
          this._sorters[key] = mungeSorter(sorter)
      }
  };
  proto._updateItemsSortData = function(items) {
      var len = items && items.length;
      for (var i = 0; len && i < len; i++) {
          var item = items[i];
          item.updateSortData()
      }
  };
  var mungeSorter = function() {
      function mungeSorter(sorter) {
          if (typeof sorter != "string") {
              return sorter
          }
          var args = trim(sorter).split(" ");
          var query = args[0];
          var attrMatch = query.match(/^\[(.+)\]$/);
          var attr = attrMatch && attrMatch[1];
          var getValue = getValueGetter(attr, query);
          var parser = Isotope.sortDataParsers[args[1]];
          sorter = parser ? function(elem) {
              return elem && parser(getValue(elem))
          } : function(elem) {
              return elem && getValue(elem)
          };
          return sorter
      }

      function getValueGetter(attr, query) {
          if (attr) {
              return function getAttribute(elem) {
                  return elem.getAttribute(attr)
              }
          }
          return function getChildText(elem) {
              var child = elem.querySelector(query);
              return child && child.textContent
          }
      }
      return mungeSorter
  }();
  Isotope.sortDataParsers = {
      parseInt: function(val) {
          return parseInt(val, 10)
      },
      parseFloat: function(val) {
          return parseFloat(val)
      }
  };
  proto._sort = function() {
      if (!this.options.sortBy) {
          return
      }
      var sortBys = utils.makeArray(this.options.sortBy);
      if (!this._getIsSameSortBy(sortBys)) {
          this.sortHistory = sortBys.concat(this.sortHistory)
      }
      var itemSorter = getItemSorter(this.sortHistory, this.options.sortAscending);
      this.filteredItems.sort(itemSorter)
  };
  proto._getIsSameSortBy = function(sortBys) {
      for (var i = 0; i < sortBys.length; i++) {
          if (sortBys[i] != this.sortHistory[i]) {
              return false
          }
      }
      return true
  };

  function getItemSorter(sortBys, sortAsc) {
      return function sorter(itemA, itemB) {
          for (var i = 0; i < sortBys.length; i++) {
              var sortBy = sortBys[i];
              var a = itemA.sortData[sortBy];
              var b = itemB.sortData[sortBy];
              if (a > b || a < b) {
                  var isAscending = sortAsc[sortBy] !== undefined ? sortAsc[sortBy] : sortAsc;
                  var direction = isAscending ? 1 : -1;
                  return (a > b ? 1 : -1) * direction
              }
          }
          return 0
      }
  }
  proto._mode = function() {
      var layoutMode = this.options.layoutMode;
      var mode = this.modes[layoutMode];
      if (!mode) {
          throw new Error("No layout mode: " + layoutMode)
      }
      mode.options = this.options[layoutMode];
      return mode
  };
  proto._resetLayout = function() {
      Outlayer.prototype._resetLayout.call(this);
      this._mode()._resetLayout()
  };
  proto._getItemLayoutPosition = function(item) {
      return this._mode()._getItemLayoutPosition(item)
  };
  proto._manageStamp = function(stamp) {
      this._mode()._manageStamp(stamp)
  };
  proto._getContainerSize = function() {
      return this._mode()._getContainerSize()
  };
  proto.needsResizeLayout = function() {
      return this._mode().needsResizeLayout()
  };
  proto.appended = function(elems) {
      var items = this.addItems(elems);
      if (!items.length) {
          return
      }
      var filteredItems = this._filterRevealAdded(items);
      this.filteredItems = this.filteredItems.concat(filteredItems)
  };
  proto.prepended = function(elems) {
      var items = this._itemize(elems);
      if (!items.length) {
          return
      }
      this._resetLayout();
      this._manageStamps();
      var filteredItems = this._filterRevealAdded(items);
      this.layoutItems(this.filteredItems);
      this.filteredItems = filteredItems.concat(this.filteredItems);
      this.items = items.concat(this.items)
  };
  proto._filterRevealAdded = function(items) {
      var filtered = this._filter(items);
      this.hide(filtered.needHide);
      this.reveal(filtered.matches);
      this.layoutItems(filtered.matches, true);
      return filtered.matches
  };
  proto.insert = function(elems) {
      var items = this.addItems(elems);
      if (!items.length) {
          return
      }
      var i, item;
      var len = items.length;
      for (i = 0; i < len; i++) {
          item = items[i];
          this.element.appendChild(item.element)
      }
      var filteredInsertItems = this._filter(items).matches;
      for (i = 0; i < len; i++) {
          items[i].isLayoutInstant = true
      }
      this.arrange();
      for (i = 0; i < len; i++) {
          delete items[i].isLayoutInstant
      }
      this.reveal(filteredInsertItems)
  };
  var _remove = proto.remove;
  proto.remove = function(elems) {
      elems = utils.makeArray(elems);
      var removeItems = this.getItems(elems);
      _remove.call(this, elems);
      var len = removeItems && removeItems.length;
      for (var i = 0; len && i < len; i++) {
          var item = removeItems[i];
          utils.removeFrom(this.filteredItems, item)
      }
  };
  proto.shuffle = function() {
      for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          item.sortData.random = Math.random()
      }
      this.options.sortBy = "random";
      this._sort();
      this._layout()
  };
  proto._noTransition = function(fn, args) {
      var transitionDuration = this.options.transitionDuration;
      this.options.transitionDuration = 0;
      var returnValue = fn.apply(this, args);
      this.options.transitionDuration = transitionDuration;
      return returnValue
  };
  proto.getFilteredItemElements = function() {
      return this.filteredItems.map(function(item) {
          return item.element
      })
  };
  return Isotope
});
(function(factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else if (typeof exports === "object") {
      module.exports = factory(require("jquery"))
  } else {
      factory(jQuery)
  }
})(function($) {
  var pluses = /\+/g;

  function encode(s) {
      return config.raw ? s : encodeURIComponent(s)
  }

  function decode(s) {
      return config.raw ? s : decodeURIComponent(s)
  }

  function stringifyCookieValue(value) {
      return encode(config.json ? JSON.stringify(value) : String(value))
  }

  function parseCookieValue(s) {
      if (s.indexOf('"') === 0) {
          s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\")
      }
      try {
          s = decodeURIComponent(s.replace(pluses, " "));
          return config.json ? JSON.parse(s) : s
      } catch (e) {}
  }

  function read(s, converter) {
      var value = config.raw ? s : parseCookieValue(s);
      return $.isFunction(converter) ? converter(value) : value
  }
  var config = $.cookie = function(key, value, options) {
      if (arguments.length > 1 && !$.isFunction(value)) {
          options = $.extend({}, config.defaults, options);
          if (typeof options.expires === "number") {
              var days = options.expires,
                  t = options.expires = new Date;
              t.setMilliseconds(t.getMilliseconds() + days * 864e5)
          }
          return document.cookie = [encode(key), "=", stringifyCookieValue(value), options.expires ? "; expires=" + options.expires.toUTCString() : "", options.path ? "; path=" + options.path : "", options.domain ? "; domain=" + options.domain : "", options.secure ? "; secure" : ""].join("")
      }
      var result = key ? undefined : {},
          cookies = document.cookie ? document.cookie.split("; ") : [],
          i = 0,
          l = cookies.length;
      for (; i < l; i++) {
          var parts = cookies[i].split("="),
              name = decode(parts.shift()),
              cookie = parts.join("=");
          if (key === name) {
              result = read(cookie, value);
              break
          }
          if (!key && (cookie = read(cookie)) !== undefined) {
              result[name] = cookie
          }
      }
      return result
  };
  config.defaults = {};
  $.removeCookie = function(key, options) {
      $.cookie(key, "", $.extend({}, options, {
          expires: -1
      }));
      return !$.cookie(key)
  }
});
(function($) {
  var selectors = [];
  var check_binded = false;
  var check_lock = false;
  var defaults = {
      interval: 250,
      force_process: false
  };
  var $window = $(window);
  var $prior_appeared = [];

  function appeared(selector) {
      return $(selector).filter(function() {
          return $(this).is(":appeared")
      })
  }

  function process() {
      check_lock = false;
      for (var index = 0, selectorsLength = selectors.length; index < selectorsLength; index++) {
          var $appeared = appeared(selectors[index]);
          $appeared.trigger("appear", [$appeared]);
          if ($prior_appeared[index]) {
              var $disappeared = $prior_appeared[index].not($appeared);
              $disappeared.trigger("disappear", [$disappeared])
          }
          $prior_appeared[index] = $appeared
      }
  }

  function add_selector(selector) {
      selectors.push(selector);
      $prior_appeared.push()
  }
  $.expr.pseudos.appeared = $.expr.createPseudo(function(arg) {
      return function(element) {
          var $element = $(element);
          if (!$element.is(":visible")) {
              return false
          }
          var window_left = $window.scrollLeft();
          var window_top = $window.scrollTop();
          var offset = $element.offset();
          var left = offset.left;
          var top = offset.top;
          if (top + $element.height() >= window_top && top - ($element.data("appear-top-offset") || 0) <= window_top + $window.height() && left + $element.width() >= window_left && left - ($element.data("appear-left-offset") || 0) <= window_left + $window.width()) {
              return true
          } else {
              return false
          }
      }
  });
  $.fn.extend({
      appear: function(selector, options) {
          $.appear(this, options);
          return this
      }
  });
  $.extend({
      appear: function(selector, options) {
          var opts = $.extend({}, defaults, options || {});
          if (!check_binded) {
              var on_check = function() {
                  if (check_lock) {
                      return
                  }
                  check_lock = true;
                  setTimeout(process, opts.interval)
              };
              $(window).scroll(on_check).resize(on_check);
              check_binded = true
          }
          if (opts.force_process) {
              setTimeout(process, opts.interval)
          }
          add_selector(selector)
      },
      force_appear: function() {
          if (check_binded) {
              process();
              return true
          }
          return false
      }
  })
})(function() {
  if (typeof module !== "undefined") {
      return require("jquery")
  } else {
      return jQuery
  }
}());
(function(factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else if (typeof exports === "object") {
      factory(require("jquery"))
  } else {
      factory(jQuery)
  }
})(function($) {
  var CountTo = function(element, options) {
      this.$element = $(element);
      this.options = $.extend({}, CountTo.DEFAULTS, this.dataOptions(), options);
      this.init()
  };
  CountTo.DEFAULTS = {
      from: 0,
      to: 0,
      speed: 1e3,
      refreshInterval: 100,
      decimals: 0,
      formatter: formatter,
      onUpdate: null,
      onComplete: null
  };
  CountTo.prototype.init = function() {
      this.value = this.options.from;
      this.loops = Math.ceil(this.options.speed / this.options.refreshInterval);
      this.loopCount = 0;
      this.increment = (this.options.to - this.options.from) / this.loops
  };
  CountTo.prototype.dataOptions = function() {
      var options = {
          from: this.$element.data("from"),
          to: this.$element.data("to"),
          speed: this.$element.data("speed"),
          refreshInterval: this.$element.data("refresh-interval"),
          decimals: this.$element.data("decimals")
      };
      var keys = Object.keys(options);
      for (var i in keys) {
          var key = keys[i];
          if (typeof options[key] === "undefined") {
              delete options[key]
          }
      }
      return options
  };
  CountTo.prototype.update = function() {
      this.value += this.increment;
      this.loopCount++;
      this.render();
      if (typeof this.options.onUpdate == "function") {
          this.options.onUpdate.call(this.$element, this.value)
      }
      if (this.loopCount >= this.loops) {
          clearInterval(this.interval);
          this.value = this.options.to;
          if (typeof this.options.onComplete == "function") {
              this.options.onComplete.call(this.$element, this.value)
          }
      }
  };
  CountTo.prototype.render = function() {
      var formattedValue = this.options.formatter.call(this.$element, this.value, this.options);
      this.$element.text(formattedValue)
  };
  CountTo.prototype.restart = function() {
      this.stop();
      this.init();
      this.start()
  };
  CountTo.prototype.start = function() {
      this.stop();
      this.render();
      this.interval = setInterval(this.update.bind(this), this.options.refreshInterval)
  };
  CountTo.prototype.stop = function() {
      if (this.interval) {
          clearInterval(this.interval)
      }
  };
  CountTo.prototype.toggle = function() {
      if (this.interval) {
          this.stop()
      } else {
          this.start()
      }
  };

  function formatter(value, options) {
      return value.toFixed(options.decimals)
  }
  $.fn.countTo = function(option) {
      return this.each(function() {
          var $this = $(this);
          var data = $this.data("countTo");
          var init = !data || typeof option === "object";
          var options = typeof option === "object" ? option : {};
          var method = typeof option === "string" ? option : "start";
          if (init) {
              if (data) data.stop();
              $this.data("countTo", data = new CountTo(this, options))
          }
          data[method].call(data)
      })
  }
});
(function(factory) {
  "use strict";
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else {
      factory(jQuery)
  }
})(function($) {
  "use strict";
  var instances = [],
      matchers = [],
      defaultOptions = {
          precision: 100,
          elapse: false,
          defer: false
      };
  matchers.push(/^[0-9]*$/.source);
  matchers.push(/([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
  matchers.push(/[0-9]{4}([\/\-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
  matchers = new RegExp(matchers.join("|"));

  function parseDateString(dateString) {
      if (dateString instanceof Date) {
          return dateString
      }
      if (String(dateString).match(matchers)) {
          if (String(dateString).match(/^[0-9]*$/)) {
              dateString = Number(dateString)
          }
          if (String(dateString).match(/\-/)) {
              dateString = String(dateString).replace(/\-/g, "/")
          }
          return new Date(dateString)
      } else {
          throw new Error("Couldn't cast `" + dateString + "` to a date object.")
      }
  }
  var DIRECTIVE_KEY_MAP = {
      Y: "years",
      m: "months",
      n: "daysToMonth",
      d: "daysToWeek",
      w: "weeks",
      W: "weeksToMonth",
      H: "hours",
      M: "minutes",
      S: "seconds",
      D: "totalDays",
      I: "totalHours",
      N: "totalMinutes",
      T: "totalSeconds"
  };

  function escapedRegExp(str) {
      var sanitize = str.toString().replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      return new RegExp(sanitize)
  }

  function strftime(offsetObject) {
      return function(format) {
          var directives = format.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi);
          if (directives) {
              for (var i = 0, len = directives.length; i < len; ++i) {
                  var directive = directives[i].match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/),
                      regexp = escapedRegExp(directive[0]),
                      modifier = directive[1] || "",
                      plural = directive[3] || "",
                      value = null;
                  directive = directive[2];
                  if (DIRECTIVE_KEY_MAP.hasOwnProperty(directive)) {
                      value = DIRECTIVE_KEY_MAP[directive];
                      value = Number(offsetObject[value])
                  }
                  if (value !== null) {
                      if (modifier === "!") {
                          value = pluralize(plural, value)
                      }
                      if (modifier === "") {
                          if (value < 10) {
                              value = "0" + value.toString()
                          }
                      }
                      format = format.replace(regexp, value.toString())
                  }
              }
          }
          format = format.replace(/%%/, "%");
          return format
      }
  }

  function pluralize(format, count) {
      var plural = "s",
          singular = "";
      if (format) {
          format = format.replace(/(:|;|\s)/gi, "").split(/\,/);
          if (format.length === 1) {
              plural = format[0]
          } else {
              singular = format[0];
              plural = format[1]
          }
      }
      if (Math.abs(count) > 1) {
          return plural
      } else {
          return singular
      }
  }
  var Countdown = function(el, finalDate, options) {
      this.el = el;
      this.$el = $(el);
      this.interval = null;
      this.offset = {};
      this.options = $.extend({}, defaultOptions);
      this.instanceNumber = instances.length;
      instances.push(this);
      this.$el.data("countdown-instance", this.instanceNumber);
      if (options) {
          if (typeof options === "function") {
              this.$el.on("update.countdown", options);
              this.$el.on("stoped.countdown", options);
              this.$el.on("finish.countdown", options)
          } else {
              this.options = $.extend({}, defaultOptions, options)
          }
      }
      this.setFinalDate(finalDate);
      if (this.options.defer === false) {
          this.start()
      }
  };
  $.extend(Countdown.prototype, {
      start: function() {
          if (this.interval !== null) {
              clearInterval(this.interval)
          }
          var self = this;
          this.update();
          this.interval = setInterval(function() {
              self.update.call(self)
          }, this.options.precision)
      },
      stop: function() {
          clearInterval(this.interval);
          this.interval = null;
          this.dispatchEvent("stoped")
      },
      toggle: function() {
          if (this.interval) {
              this.stop()
          } else {
              this.start()
          }
      },
      pause: function() {
          this.stop()
      },
      resume: function() {
          this.start()
      },
      remove: function() {
          this.stop.call(this);
          instances[this.instanceNumber] = null;
          delete this.$el.data().countdownInstance
      },
      setFinalDate: function(value) {
          this.finalDate = parseDateString(value)
      },
      update: function() {
          if (this.$el.closest("html").length === 0) {
              this.remove();
              return
          }
          var hasEventsAttached = $._data(this.el, "events") !== undefined,
              now = new Date,
              newTotalSecsLeft;
          newTotalSecsLeft = this.finalDate.getTime() - now.getTime();
          newTotalSecsLeft = Math.ceil(newTotalSecsLeft / 1e3);
          newTotalSecsLeft = !this.options.elapse && newTotalSecsLeft < 0 ? 0 : Math.abs(newTotalSecsLeft);
          if (this.totalSecsLeft === newTotalSecsLeft || !hasEventsAttached) {
              return
          } else {
              this.totalSecsLeft = newTotalSecsLeft
          }
          this.elapsed = now >= this.finalDate;
          this.offset = {
              seconds: this.totalSecsLeft % 60,
              minutes: Math.floor(this.totalSecsLeft / 60) % 60,
              hours: Math.floor(this.totalSecsLeft / 60 / 60) % 24,
              days: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
              daysToWeek: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
              daysToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 % 30.4368),
              weeks: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7),
              weeksToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7) % 4,
              months: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 30.4368),
              years: Math.abs(this.finalDate.getFullYear() - now.getFullYear()),
              totalDays: Math.floor(this.totalSecsLeft / 60 / 60 / 24),
              totalHours: Math.floor(this.totalSecsLeft / 60 / 60),
              totalMinutes: Math.floor(this.totalSecsLeft / 60),
              totalSeconds: this.totalSecsLeft
          };
          if (!this.options.elapse && this.totalSecsLeft === 0) {
              this.stop();
              this.dispatchEvent("finish")
          } else {
              this.dispatchEvent("update")
          }
      },
      dispatchEvent: function(eventName) {
          var event = $.Event(eventName + ".countdown");
          event.finalDate = this.finalDate;
          event.elapsed = this.elapsed;
          event.offset = $.extend({}, this.offset);
          event.strftime = strftime(this.offset);
          this.$el.trigger(event)
      }
  });
  $.fn.countdown = function() {
      var argumentsArray = Array.prototype.slice.call(arguments, 0);
      return this.each(function() {
          var instanceNumber = $(this).data("countdown-instance");
          if (instanceNumber !== undefined) {
              var instance = instances[instanceNumber],
                  method = argumentsArray[0];
              if (Countdown.prototype.hasOwnProperty(method)) {
                  instance[method].apply(instance, argumentsArray.slice(1))
              } else if (String(method).match(/^[$A-Z_][0-9A-Z_$]*$/i) === null) {
                  instance.setFinalDate.call(instance, method);
                  instance.start()
              } else {
                  $.error("Method %s does not exist on jQuery.countdown".replace(/\%s/gi, method))
              }
          } else {
              new Countdown(this, argumentsArray[0], argumentsArray[1])
          }
      })
  }
});
(function(root, factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], function(a0) {
          return factory(a0)
      })
  } else if (typeof exports === "object") {
      module.exports = factory(require("jquery"))
  } else {
      factory(jQuery)
  }
})(this, function($) {
  var CanvasRenderer = function(el, options) {
      var cachedBackground;
      var canvas = document.createElement("canvas");
      el.appendChild(canvas);
      if (typeof G_vmlCanvasManager === "object") {
          G_vmlCanvasManager.initElement(canvas)
      }
      var ctx = canvas.getContext("2d");
      canvas.width = canvas.height = options.size;
      var scaleBy = 1;
      if (window.devicePixelRatio > 1) {
          scaleBy = window.devicePixelRatio;
          canvas.style.width = canvas.style.height = [options.size, "px"].join("");
          canvas.width = canvas.height = options.size * scaleBy;
          ctx.scale(scaleBy, scaleBy)
      }
      ctx.translate(options.size / 2, options.size / 2);
      ctx.rotate((-1 / 2 + options.rotate / 180) * Math.PI);
      var radius = (options.size - options.lineWidth) / 2;
      if (options.scaleColor && options.scaleLength) {
          radius -= options.scaleLength + 2
      }
      Date.now = Date.now || function() {
          return +new Date
      };
      var drawCircle = function(color, lineWidth, percent) {
          percent = Math.min(Math.max(-1, percent || 0), 1);
          var isNegative = percent <= 0 ? true : false;
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2 * percent, isNegative);
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.stroke()
      };
      var drawScale = function() {
          var offset;
          var length;
          ctx.lineWidth = 1;
          ctx.fillStyle = options.scaleColor;
          ctx.save();
          for (var i = 24; i > 0; --i) {
              if (i % 6 === 0) {
                  length = options.scaleLength;
                  offset = 0
              } else {
                  length = options.scaleLength * .6;
                  offset = options.scaleLength - length
              }
              ctx.fillRect(-options.size / 2 + offset, 0, length, 1);
              ctx.rotate(Math.PI / 12)
          }
          ctx.restore()
      };
      var reqAnimationFrame = function() {
          return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
              window.setTimeout(callback, 1e3 / 60)
          }
      }();
      var drawBackground = function() {
          if (options.scaleColor) drawScale();
          if (options.trackColor) drawCircle(options.trackColor, options.trackWidth || options.lineWidth, 1)
      };
      this.getCanvas = function() {
          return canvas
      };
      this.getCtx = function() {
          return ctx
      };
      this.clear = function() {
          ctx.clearRect(options.size / -2, options.size / -2, options.size, options.size)
      };
      this.draw = function(percent) {
          if (!!options.scaleColor || !!options.trackColor) {
              if (ctx.getImageData && ctx.putImageData) {
                  if (!cachedBackground) {
                      drawBackground();
                      cachedBackground = ctx.getImageData(0, 0, options.size * scaleBy, options.size * scaleBy)
                  } else {
                      ctx.putImageData(cachedBackground, 0, 0)
                  }
              } else {
                  this.clear();
                  drawBackground()
              }
          } else {
              this.clear()
          }
          ctx.lineCap = options.lineCap;
          var color;
          if (typeof options.barColor === "function") {
              color = options.barColor(percent)
          } else {
              color = options.barColor
          }
          drawCircle(color, options.lineWidth, percent / 100)
      }.bind(this);
      this.animate = function(from, to) {
          var startTime = Date.now();
          options.onStart(from, to);
          var animation = function() {
              var process = Math.min(Date.now() - startTime, options.animate.duration);
              var currentValue = options.easing(this, process, from, to - from, options.animate.duration);
              this.draw(currentValue);
              options.onStep(from, to, currentValue);
              if (process >= options.animate.duration) {
                  options.onStop(from, to)
              } else {
                  reqAnimationFrame(animation)
              }
          }.bind(this);
          reqAnimationFrame(animation)
      }.bind(this)
  };
  var EasyPieChart = function(el, opts) {
      var defaultOptions = {
          barColor: "#ef1e25",
          trackColor: "#f9f9f9",
          scaleColor: "#dfe0e0",
          scaleLength: 5,
          lineCap: "round",
          lineWidth: 3,
          trackWidth: undefined,
          size: 110,
          rotate: 0,
          animate: {
              duration: 1e3,
              enabled: true
          },
          easing: function(x, t, b, c, d) {
              t = t / (d / 2);
              if (t < 1) {
                  return c / 2 * t * t + b
              }
              return -c / 2 * (--t * (t - 2) - 1) + b
          },
          onStart: function(from, to) {
              return
          },
          onStep: function(from, to, currentValue) {
              return
          },
          onStop: function(from, to) {
              return
          }
      };
      if (typeof CanvasRenderer !== "undefined") {
          defaultOptions.renderer = CanvasRenderer
      } else if (typeof SVGRenderer !== "undefined") {
          defaultOptions.renderer = SVGRenderer
      } else {
          throw new Error("Please load either the SVG- or the CanvasRenderer")
      }
      var options = {};
      var currentValue = 0;
      var init = function() {
          this.el = el;
          this.options = options;
          for (var i in defaultOptions) {
              if (defaultOptions.hasOwnProperty(i)) {
                  options[i] = opts && typeof opts[i] !== "undefined" ? opts[i] : defaultOptions[i];
                  if (typeof options[i] === "function") {
                      options[i] = options[i].bind(this)
                  }
              }
          }
          if (typeof options.easing === "string" && typeof jQuery !== "undefined" && jQuery.isFunction(jQuery.easing[options.easing])) {
              options.easing = jQuery.easing[options.easing]
          } else {
              options.easing = defaultOptions.easing
          }
          if (typeof options.animate === "number") {
              options.animate = {
                  duration: options.animate,
                  enabled: true
              }
          }
          if (typeof options.animate === "boolean" && !options.animate) {
              options.animate = {
                  duration: 1e3,
                  enabled: options.animate
              }
          }
          this.renderer = new options.renderer(el, options);
          this.renderer.draw(currentValue);
          if (el.dataset && el.dataset.percent) {
              this.update(parseFloat(el.dataset.percent))
          } else if (el.getAttribute && el.getAttribute("data-percent")) {
              this.update(parseFloat(el.getAttribute("data-percent")))
          }
      }.bind(this);
      this.update = function(newValue) {
          newValue = parseFloat(newValue);
          if (options.animate.enabled) {
              this.renderer.animate(currentValue, newValue)
          } else {
              this.renderer.draw(newValue)
          }
          currentValue = newValue;
          return this
      }.bind(this);
      this.disableAnimation = function() {
          options.animate.enabled = false;
          return this
      };
      this.enableAnimation = function() {
          options.animate.enabled = true;
          return this
      };
      init()
  };
  $.fn.easyPieChart = function(options) {
      return this.each(function() {
          var instanceOptions;
          if (!$.data(this, "easyPieChart")) {
              instanceOptions = $.extend({}, options, $(this).data());
              $.data(this, "easyPieChart", new EasyPieChart(this, instanceOptions))
          }
      })
  }
});
(function($) {
  "use strict";
  $.fn.fitVids = function(options) {
      var settings = {
          customSelector: null,
          ignore: null
      };
      if (!document.getElementById("fit-vids-style")) {
          var head = document.head || document.getElementsByTagName("head")[0];
          var css = ".fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}";
          var div = document.createElement("div");
          div.innerHTML = '<p>x</p><style id="fit-vids-style">' + css + "</style>";
          head.appendChild(div.childNodes[1])
      }
      if (options) {
          $.extend(settings, options)
      }
      return this.each(function() {
          var selectors = ['iframe[src*="player.vimeo.com"]', 'iframe[src*="youtube.com"]', 'iframe[src*="youtube-nocookie.com"]', 'iframe[src*="kickstarter.com"][src*="video.html"]', "object", "embed"];
          if (settings.customSelector) {
              selectors.push(settings.customSelector)
          }
          var ignoreList = ".fitvidsignore";
          if (settings.ignore) {
              ignoreList = ignoreList + ", " + settings.ignore
          }
          var $allVideos = $(this).find(selectors.join(","));
          $allVideos = $allVideos.not("object object");
          $allVideos = $allVideos.not(ignoreList);
          $allVideos.each(function() {
              var $this = $(this);
              if ($this.parents(ignoreList).length > 0) {
                  return
              }
              if (this.tagName.toLowerCase() === "embed" && $this.parent("object").length || $this.parent(".fluid-width-video-wrapper").length) {
                  return
              }
              if (!$this.css("height") && !$this.css("width") && (isNaN($this.attr("height")) || isNaN($this.attr("width")))) {
                  $this.attr("height", 9);
                  $this.attr("width", 16)
              }
              var height = this.tagName.toLowerCase() === "object" || $this.attr("height") && !isNaN(parseInt($this.attr("height"), 10)) ? parseInt($this.attr("height"), 10) : $this.height(),
                  width = !isNaN(parseInt($this.attr("width"), 10)) ? parseInt($this.attr("width"), 10) : $this.width(),
                  aspectRatio = height / width;
              if (!$this.attr("name")) {
                  var videoName = "fitvid" + $.fn.fitVids._count;
                  $this.attr("name", videoName);
                  $.fn.fitVids._count++
              }
              $this.wrap('<div class="fluid-width-video-wrapper"></div>').parent(".fluid-width-video-wrapper").css("padding-top", aspectRatio * 100 + "%");
              $this.removeAttr("height").removeAttr("width")
          })
      })
  };
  $.fn.fitVids._count = 0
})(window.jQuery || window.Zepto);
(function(factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else if (typeof exports === "object") {
      factory(require("jquery"))
  } else {
      factory(window.jQuery || window.Zepto)
  }
})(function($) {
  var CLOSE_EVENT = "Close",
      BEFORE_CLOSE_EVENT = "BeforeClose",
      AFTER_CLOSE_EVENT = "AfterClose",
      BEFORE_APPEND_EVENT = "BeforeAppend",
      MARKUP_PARSE_EVENT = "MarkupParse",
      OPEN_EVENT = "Open",
      CHANGE_EVENT = "Change",
      NS = "mfp",
      EVENT_NS = "." + NS,
      READY_CLASS = "mfp-ready",
      REMOVING_CLASS = "mfp-removing",
      PREVENT_CLOSE_CLASS = "mfp-prevent-close";
  var mfp, MagnificPopup = function() {},
      _isJQ = !!window.jQuery,
      _prevStatus, _window = $(window),
      _document, _prevContentType, _wrapClasses, _currPopupType;
  var _mfpOn = function(name, f) {
          mfp.ev.on(NS + name + EVENT_NS, f)
      },
      _getEl = function(className, appendTo, html, raw) {
          var el = document.createElement("div");
          el.className = "mfp-" + className;
          if (html) {
              el.innerHTML = html
          }
          if (!raw) {
              el = $(el);
              if (appendTo) {
                  el.appendTo(appendTo)
              }
          } else if (appendTo) {
              appendTo.appendChild(el)
          }
          return el
      },
      _mfpTrigger = function(e, data) {
          mfp.ev.triggerHandler(NS + e, data);
          if (mfp.st.callbacks) {
              e = e.charAt(0).toLowerCase() + e.slice(1);
              if (mfp.st.callbacks[e]) {
                  mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [data])
              }
          }
      },
      _getCloseBtn = function(type) {
          if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
              mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace("%title%", mfp.st.tClose));
              _currPopupType = type
          }
          return mfp.currTemplate.closeBtn
      },
      _checkInstance = function() {
          if (!$.magnificPopup.instance) {
              mfp = new MagnificPopup;
              mfp.init();
              $.magnificPopup.instance = mfp
          }
      },
      supportsTransitions = function() {
          var s = document.createElement("p").style,
              v = ["ms", "O", "Moz", "Webkit"];
          if (s["transition"] !== undefined) {
              return true
          }
          while (v.length) {
              if (v.pop() + "Transition" in s) {
                  return true
              }
          }
          return false
      };
  MagnificPopup.prototype = {
      constructor: MagnificPopup,
      init: function() {
          var appVersion = navigator.appVersion;
          mfp.isLowIE = mfp.isIE8 = document.all && !document.addEventListener;
          mfp.isAndroid = /android/gi.test(appVersion);
          mfp.isIOS = /iphone|ipad|ipod/gi.test(appVersion);
          mfp.supportsTransition = supportsTransitions();
          mfp.probablyMobile = mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent);
          _document = $(document);
          mfp.popupsCache = {}
      },
      open: function(data) {
          var i;
          if (data.isObj === false) {
              mfp.items = data.items.toArray();
              mfp.index = 0;
              var items = data.items,
                  item;
              for (i = 0; i < items.length; i++) {
                  item = items[i];
                  if (item.parsed) {
                      item = item.el[0]
                  }
                  if (item === data.el[0]) {
                      mfp.index = i;
                      break
                  }
              }
          } else {
              mfp.items = $.isArray(data.items) ? data.items : [data.items];
              mfp.index = data.index || 0
          }
          if (mfp.isOpen) {
              mfp.updateItemHTML();
              return
          }
          mfp.types = [];
          _wrapClasses = "";
          if (data.mainEl && data.mainEl.length) {
              mfp.ev = data.mainEl.eq(0)
          } else {
              mfp.ev = _document
          }
          if (data.key) {
              if (!mfp.popupsCache[data.key]) {
                  mfp.popupsCache[data.key] = {}
              }
              mfp.currTemplate = mfp.popupsCache[data.key]
          } else {
              mfp.currTemplate = {}
          }
          mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
          mfp.fixedContentPos = mfp.st.fixedContentPos === "auto" ? !mfp.probablyMobile : mfp.st.fixedContentPos;
          if (mfp.st.modal) {
              mfp.st.closeOnContentClick = false;
              mfp.st.closeOnBgClick = false;
              mfp.st.showCloseBtn = false;
              mfp.st.enableEscapeKey = false
          }
          if (!mfp.bgOverlay) {
              mfp.bgOverlay = _getEl("bg").on("click" + EVENT_NS, function() {
                  mfp.close()
              });
              mfp.wrap = _getEl("wrap").attr("tabindex", -1).on("click" + EVENT_NS, function(e) {
                  if (mfp._checkIfClose(e.target)) {
                      mfp.close()
                  }
              });
              mfp.container = _getEl("container", mfp.wrap)
          }
          mfp.contentContainer = _getEl("content");
          if (mfp.st.preloader) {
              mfp.preloader = _getEl("preloader", mfp.container, mfp.st.tLoading)
          }
          var modules = $.magnificPopup.modules;
          for (i = 0; i < modules.length; i++) {
              var n = modules[i];
              n = n.charAt(0).toUpperCase() + n.slice(1);
              mfp["init" + n].call(mfp)
          }
          _mfpTrigger("BeforeOpen");
          if (mfp.st.showCloseBtn) {
              if (!mfp.st.closeBtnInside) {
                  mfp.wrap.append(_getCloseBtn())
              } else {
                  _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                      values.close_replaceWith = _getCloseBtn(item.type)
                  });
                  _wrapClasses += " mfp-close-btn-in"
              }
          }
          if (mfp.st.alignTop) {
              _wrapClasses += " mfp-align-top"
          }
          if (mfp.fixedContentPos) {
              mfp.wrap.css({
                  overflow: mfp.st.overflowY,
                  overflowX: "hidden",
                  overflowY: mfp.st.overflowY
              })
          } else {
              mfp.wrap.css({
                  top: _window.scrollTop(),
                  position: "absolute"
              })
          }
          if (mfp.st.fixedBgPos === false || mfp.st.fixedBgPos === "auto" && !mfp.fixedContentPos) {
              mfp.bgOverlay.css({
                  height: _document.height(),
                  position: "absolute"
              })
          }
          if (mfp.st.enableEscapeKey) {
              _document.on("keyup" + EVENT_NS, function(e) {
                  if (e.keyCode === 27) {
                      mfp.close()
                  }
              })
          }
          _window.on("resize" + EVENT_NS, function() {
              mfp.updateSize()
          });
          if (!mfp.st.closeOnContentClick) {
              _wrapClasses += " mfp-auto-cursor"
          }
          if (_wrapClasses) mfp.wrap.addClass(_wrapClasses);
          var windowHeight = mfp.wH = _window.height();
          var windowStyles = {};
          if (mfp.fixedContentPos) {
              if (mfp._hasScrollBar(windowHeight)) {
                  var s = mfp._getScrollbarSize();
                  if (s) {
                      windowStyles.marginRight = s
                  }
              }
          }
          if (mfp.fixedContentPos) {
              if (!mfp.isIE7) {
                  windowStyles.overflow = "hidden"
              } else {
                  $("body, html").css("overflow", "hidden")
              }
          }
          var classesToadd = mfp.st.mainClass;
          if (mfp.isIE7) {
              classesToadd += " mfp-ie7"
          }
          if (classesToadd) {
              mfp._addClassToMFP(classesToadd)
          }
          mfp.updateItemHTML();
          _mfpTrigger("BuildControls");
          $("html").css(windowStyles);
          mfp.bgOverlay.add(mfp.wrap).prependTo(mfp.st.prependTo || $(document.body));
          mfp._lastFocusedEl = document.activeElement;
          setTimeout(function() {
              if (mfp.content) {
                  mfp._addClassToMFP(READY_CLASS);
                  mfp._setFocus()
              } else {
                  mfp.bgOverlay.addClass(READY_CLASS)
              }
              _document.on("focusin" + EVENT_NS, mfp._onFocusIn)
          }, 16);
          mfp.isOpen = true;
          mfp.updateSize(windowHeight);
          _mfpTrigger(OPEN_EVENT);
          return data
      },
      close: function() {
          if (!mfp.isOpen) return;
          _mfpTrigger(BEFORE_CLOSE_EVENT);
          mfp.isOpen = false;
          if (mfp.st.removalDelay && !mfp.isLowIE && mfp.supportsTransition) {
              mfp._addClassToMFP(REMOVING_CLASS);
              setTimeout(function() {
                  mfp._close()
              }, mfp.st.removalDelay)
          } else {
              mfp._close()
          }
      },
      _close: function() {
          _mfpTrigger(CLOSE_EVENT);
          var classesToRemove = REMOVING_CLASS + " " + READY_CLASS + " ";
          mfp.bgOverlay.detach();
          mfp.wrap.detach();
          mfp.container.empty();
          if (mfp.st.mainClass) {
              classesToRemove += mfp.st.mainClass + " "
          }
          mfp._removeClassFromMFP(classesToRemove);
          if (mfp.fixedContentPos) {
              var windowStyles = {
                  marginRight: ""
              };
              if (mfp.isIE7) {
                  $("body, html").css("overflow", "")
              } else {
                  windowStyles.overflow = ""
              }
              $("html").css(windowStyles)
          }
          _document.off("keyup" + EVENT_NS + " focusin" + EVENT_NS);
          mfp.ev.off(EVENT_NS);
          mfp.wrap.attr("class", "mfp-wrap").removeAttr("style");
          mfp.bgOverlay.attr("class", "mfp-bg");
          mfp.container.attr("class", "mfp-container");
          if (mfp.st.showCloseBtn && (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true)) {
              if (mfp.currTemplate.closeBtn) mfp.currTemplate.closeBtn.detach()
          }
          if (mfp.st.autoFocusLast && mfp._lastFocusedEl) {
              $(mfp._lastFocusedEl).focus()
          }
          mfp.currItem = null;
          mfp.content = null;
          mfp.currTemplate = null;
          mfp.prevHeight = 0;
          _mfpTrigger(AFTER_CLOSE_EVENT)
      },
      updateSize: function(winHeight) {
          if (mfp.isIOS) {
              var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
              var height = window.innerHeight * zoomLevel;
              mfp.wrap.css("height", height);
              mfp.wH = height
          } else {
              mfp.wH = winHeight || _window.height()
          }
          if (!mfp.fixedContentPos) {
              mfp.wrap.css("height", mfp.wH)
          }
          _mfpTrigger("Resize")
      },
      updateItemHTML: function() {
          var item = mfp.items[mfp.index];
          mfp.contentContainer.detach();
          if (mfp.content) mfp.content.detach();
          if (!item.parsed) {
              item = mfp.parseEl(mfp.index)
          }
          var type = item.type;
          _mfpTrigger("BeforeChange", [mfp.currItem ? mfp.currItem.type : "", type]);
          mfp.currItem = item;
          if (!mfp.currTemplate[type]) {
              var markup = mfp.st[type] ? mfp.st[type].markup : false;
              _mfpTrigger("FirstMarkupParse", markup);
              if (markup) {
                  mfp.currTemplate[type] = $(markup)
              } else {
                  mfp.currTemplate[type] = true
              }
          }
          if (_prevContentType && _prevContentType !== item.type) {
              mfp.container.removeClass("mfp-" + _prevContentType + "-holder")
          }
          var newContent = mfp["get" + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
          mfp.appendContent(newContent, type);
          item.preloaded = true;
          _mfpTrigger(CHANGE_EVENT, item);
          _prevContentType = item.type;
          mfp.container.prepend(mfp.contentContainer);
          _mfpTrigger("AfterChange")
      },
      appendContent: function(newContent, type) {
          mfp.content = newContent;
          if (newContent) {
              if (mfp.st.showCloseBtn && mfp.st.closeBtnInside && mfp.currTemplate[type] === true) {
                  if (!mfp.content.find(".mfp-close").length) {
                      mfp.content.append(_getCloseBtn())
                  }
              } else {
                  mfp.content = newContent
              }
          } else {
              mfp.content = ""
          }
          _mfpTrigger(BEFORE_APPEND_EVENT);
          mfp.container.addClass("mfp-" + type + "-holder");
          mfp.contentContainer.append(mfp.content)
      },
      parseEl: function(index) {
          var item = mfp.items[index],
              type;
          if (item.tagName) {
              item = {
                  el: $(item)
              }
          } else {
              type = item.type;
              item = {
                  data: item,
                  src: item.src
              }
          }
          if (item.el) {
              var types = mfp.types;
              for (var i = 0; i < types.length; i++) {
                  if (item.el.hasClass("mfp-" + types[i])) {
                      type = types[i];
                      break
                  }
              }
              item.src = item.el.attr("data-mfp-src");
              if (!item.src) {
                  item.src = item.el.attr("href")
              }
          }
          item.type = type || mfp.st.type || "inline";
          item.index = index;
          item.parsed = true;
          mfp.items[index] = item;
          _mfpTrigger("ElementParse", item);
          return mfp.items[index]
      },
      addGroup: function(el, options) {
          var eHandler = function(e) {
              e.mfpEl = this;
              mfp._openClick(e, el, options)
          };
          if (!options) {
              options = {}
          }
          var eName = "click.magnificPopup";
          options.mainEl = el;
          if (options.items) {
              options.isObj = true;
              el.off(eName).on(eName, eHandler)
          } else {
              options.isObj = false;
              if (options.delegate) {
                  el.off(eName).on(eName, options.delegate, eHandler)
              } else {
                  options.items = el;
                  el.off(eName).on(eName, eHandler)
              }
          }
      },
      _openClick: function(e, el, options) {
          var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;
          if (!midClick && (e.which === 2 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey)) {
              return
          }
          var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;
          if (disableOn) {
              if ($.isFunction(disableOn)) {
                  if (!disableOn.call(mfp)) {
                      return true
                  }
              } else {
                  if (_window.width() < disableOn) {
                      return true
                  }
              }
          }
          if (e.type) {
              e.preventDefault();
              if (mfp.isOpen) {
                  e.stopPropagation()
              }
          }
          options.el = $(e.mfpEl);
          if (options.delegate) {
              options.items = el.find(options.delegate)
          }
          mfp.open(options)
      },
      updateStatus: function(status, text) {
          if (mfp.preloader) {
              if (_prevStatus !== status) {
                  mfp.container.removeClass("mfp-s-" + _prevStatus)
              }
              if (!text && status === "loading") {
                  text = mfp.st.tLoading
              }
              var data = {
                  status: status,
                  text: text
              };
              _mfpTrigger("UpdateStatus", data);
              status = data.status;
              text = data.text;
              mfp.preloader.html(text);
              mfp.preloader.find("a").on("click", function(e) {
                  e.stopImmediatePropagation()
              });
              mfp.container.addClass("mfp-s-" + status);
              _prevStatus = status
          }
      },
      _checkIfClose: function(target) {
          if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
              return
          }
          var closeOnContent = mfp.st.closeOnContentClick;
          var closeOnBg = mfp.st.closeOnBgClick;
          if (closeOnContent && closeOnBg) {
              return true
          } else {
              if (!mfp.content || $(target).hasClass("mfp-close") || mfp.preloader && target === mfp.preloader[0]) {
                  return true
              }
              if (target !== mfp.content[0] && !$.contains(mfp.content[0], target)) {
                  if (closeOnBg) {
                      if ($.contains(document, target)) {
                          return true
                      }
                  }
              } else if (closeOnContent) {
                  return true
              }
          }
          return false
      },
      _addClassToMFP: function(cName) {
          mfp.bgOverlay.addClass(cName);
          mfp.wrap.addClass(cName)
      },
      _removeClassFromMFP: function(cName) {
          this.bgOverlay.removeClass(cName);
          mfp.wrap.removeClass(cName)
      },
      _hasScrollBar: function(winHeight) {
          return (mfp.isIE7 ? _document.height() : document.body.scrollHeight) > (winHeight || _window.height())
      },
      _setFocus: function() {
          (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus()
      },
      _onFocusIn: function(e) {
          if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
              mfp._setFocus();
              return false
          }
      },
      _parseMarkup: function(template, values, item) {
          var arr;
          if (item.data) {
              values = $.extend(item.data, values)
          }
          _mfpTrigger(MARKUP_PARSE_EVENT, [template, values, item]);
          $.each(values, function(key, value) {
              if (value === undefined || value === false) {
                  return true
              }
              arr = key.split("_");
              if (arr.length > 1) {
                  var el = template.find(EVENT_NS + "-" + arr[0]);
                  if (el.length > 0) {
                      var attr = arr[1];
                      if (attr === "replaceWith") {
                          if (el[0] !== value[0]) {
                              el.replaceWith(value)
                          }
                      } else if (attr === "img") {
                          if (el.is("img")) {
                              el.attr("src", value)
                          } else {
                              el.replaceWith($("<img>").attr("src", value).attr("class", el.attr("class")))
                          }
                      } else {
                          el.attr(arr[1], value)
                      }
                  }
              } else {
                  template.find(EVENT_NS + "-" + key).html(value)
              }
          })
      },
      _getScrollbarSize: function() {
          if (mfp.scrollbarSize === undefined) {
              var scrollDiv = document.createElement("div");
              scrollDiv.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;";
              document.body.appendChild(scrollDiv);
              mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
              document.body.removeChild(scrollDiv)
          }
          return mfp.scrollbarSize
      }
  };
  $.magnificPopup = {
      instance: null,
      proto: MagnificPopup.prototype,
      modules: [],
      open: function(options, index) {
          _checkInstance();
          if (!options) {
              options = {}
          } else {
              options = $.extend(true, {}, options)
          }
          options.isObj = true;
          options.index = index || 0;
          return this.instance.open(options)
      },
      close: function() {
          return $.magnificPopup.instance && $.magnificPopup.instance.close()
      },
      registerModule: function(name, module) {
          if (module.options) {
              $.magnificPopup.defaults[name] = module.options
          }
          $.extend(this.proto, module.proto);
          this.modules.push(name)
      },
      defaults: {
          disableOn: 0,
          key: null,
          midClick: false,
          mainClass: "",
          preloader: true,
          focus: "",
          closeOnContentClick: false,
          closeOnBgClick: true,
          closeBtnInside: true,
          showCloseBtn: true,
          enableEscapeKey: true,
          modal: false,
          alignTop: false,
          removalDelay: 0,
          prependTo: null,
          fixedContentPos: "auto",
          fixedBgPos: "auto",
          overflowY: "auto",
          closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
          tClose: "Close (Esc)",
          tLoading: "Loading...",
          autoFocusLast: true
      }
  };
  $.fn.magnificPopup = function(options) {
      _checkInstance();
      var jqEl = $(this);
      if (typeof options === "string") {
          if (options === "open") {
              var items, itemOpts = _isJQ ? jqEl.data("magnificPopup") : jqEl[0].magnificPopup,
                  index = parseInt(arguments[1], 10) || 0;
              if (itemOpts.items) {
                  items = itemOpts.items[index]
              } else {
                  items = jqEl;
                  if (itemOpts.delegate) {
                      items = items.find(itemOpts.delegate)
                  }
                  items = items.eq(index)
              }
              mfp._openClick({
                  mfpEl: items
              }, jqEl, itemOpts)
          } else {
              if (mfp.isOpen) mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1))
          }
      } else {
          options = $.extend(true, {}, options);
          if (_isJQ) {
              jqEl.data("magnificPopup", options)
          } else {
              jqEl[0].magnificPopup = options
          }
          mfp.addGroup(jqEl, options)
      }
      return jqEl
  };
  var INLINE_NS = "inline",
      _hiddenClass, _inlinePlaceholder, _lastInlineElement, _putInlineElementsBack = function() {
          if (_lastInlineElement) {
              _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
              _lastInlineElement = null
          }
      };
  $.magnificPopup.registerModule(INLINE_NS, {
      options: {
          hiddenClass: "hide",
          markup: "",
          tNotFound: "Content not found"
      },
      proto: {
          initInline: function() {
              mfp.types.push(INLINE_NS);
              _mfpOn(CLOSE_EVENT + "." + INLINE_NS, function() {
                  _putInlineElementsBack()
              })
          },
          getInline: function(item, template) {
              _putInlineElementsBack();
              if (item.src) {
                  var inlineSt = mfp.st.inline,
                      el = $(item.src);
                  if (el.length) {
                      var parent = el[0].parentNode;
                      if (parent && parent.tagName) {
                          if (!_inlinePlaceholder) {
                              _hiddenClass = inlineSt.hiddenClass;
                              _inlinePlaceholder = _getEl(_hiddenClass);
                              _hiddenClass = "mfp-" + _hiddenClass
                          }
                          _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass)
                      }
                      mfp.updateStatus("ready")
                  } else {
                      mfp.updateStatus("error", inlineSt.tNotFound);
                      el = $("<div>")
                  }
                  item.inlineElement = el;
                  return el
              }
              mfp.updateStatus("ready");
              mfp._parseMarkup(template, {}, item);
              return template
          }
      }
  });
  var AJAX_NS = "ajax",
      _ajaxCur, _removeAjaxCursor = function() {
          if (_ajaxCur) {
              $(document.body).removeClass(_ajaxCur)
          }
      },
      _destroyAjaxRequest = function() {
          _removeAjaxCursor();
          if (mfp.req) {
              mfp.req.abort()
          }
      };
  $.magnificPopup.registerModule(AJAX_NS, {
      options: {
          settings: null,
          cursor: "mfp-ajax-cur",
          tError: '<a href="%url%">The content</a> could not be loaded.'
      },
      proto: {
          initAjax: function() {
              mfp.types.push(AJAX_NS);
              _ajaxCur = mfp.st.ajax.cursor;
              _mfpOn(CLOSE_EVENT + "." + AJAX_NS, _destroyAjaxRequest);
              _mfpOn("BeforeChange." + AJAX_NS, _destroyAjaxRequest)
          },
          getAjax: function(item) {
              if (_ajaxCur) {
                  $(document.body).addClass(_ajaxCur)
              }
              mfp.updateStatus("loading");
              var opts = $.extend({
                  url: item.src,
                  success: function(data, textStatus, jqXHR) {
                      var temp = {
                          data: data,
                          xhr: jqXHR
                      };
                      _mfpTrigger("ParseAjax", temp);
                      mfp.appendContent($(temp.data), AJAX_NS);
                      item.finished = true;
                      _removeAjaxCursor();
                      mfp._setFocus();
                      setTimeout(function() {
                          mfp.wrap.addClass(READY_CLASS)
                      }, 16);
                      mfp.updateStatus("ready");
                      _mfpTrigger("AjaxContentAdded")
                  },
                  error: function() {
                      _removeAjaxCursor();
                      item.finished = item.loadError = true;
                      mfp.updateStatus("error", mfp.st.ajax.tError.replace("%url%", item.src))
                  }
              }, mfp.st.ajax.settings);
              mfp.req = $.ajax(opts);
              return ""
          }
      }
  });
  var _imgInterval, _getTitle = function(item) {
      if (item.data && item.data.title !== undefined) return item.data.title;
      var src = mfp.st.image.titleSrc;
      if (src) {
          if ($.isFunction(src)) {
              return src.call(mfp, item)
          } else if (item.el) {
              return item.el.attr(src) || ""
          }
      }
      return ""
  };
  $.magnificPopup.registerModule("image", {
      options: {
          markup: '<div class="mfp-figure">' + '<div class="mfp-close"></div>' + "<figure>" + '<div class="mfp-img"></div>' + "<figcaption>" + '<div class="mfp-bottom-bar">' + '<div class="mfp-title"></div>' + '<div class="mfp-counter"></div>' + "</div>" + "</figcaption>" + "</figure>" + "</div>",
          cursor: "mfp-zoom-out-cur",
          titleSrc: "title",
          verticalFit: true,
          tError: '<a href="%url%">The image</a> could not be loaded.'
      },
      proto: {
          initImage: function() {
              var imgSt = mfp.st.image,
                  ns = ".image";
              mfp.types.push("image");
              _mfpOn(OPEN_EVENT + ns, function() {
                  if (mfp.currItem.type === "image" && imgSt.cursor) {
                      $(document.body).addClass(imgSt.cursor)
                  }
              });
              _mfpOn(CLOSE_EVENT + ns, function() {
                  if (imgSt.cursor) {
                      $(document.body).removeClass(imgSt.cursor)
                  }
                  _window.off("resize" + EVENT_NS)
              });
              _mfpOn("Resize" + ns, mfp.resizeImage);
              if (mfp.isLowIE) {
                  _mfpOn("AfterChange", mfp.resizeImage)
              }
          },
          resizeImage: function() {
              var item = mfp.currItem;
              if (!item || !item.img) return;
              if (mfp.st.image.verticalFit) {
                  var decr = 0;
                  if (mfp.isLowIE) {
                      decr = parseInt(item.img.css("padding-top"), 10) + parseInt(item.img.css("padding-bottom"), 10)
                  }
                  item.img.css("max-height", mfp.wH - decr)
              }
          },
          _onImageHasSize: function(item) {
              if (item.img) {
                  item.hasSize = true;
                  if (_imgInterval) {
                      clearInterval(_imgInterval)
                  }
                  item.isCheckingImgSize = false;
                  _mfpTrigger("ImageHasSize", item);
                  if (item.imgHidden) {
                      if (mfp.content) mfp.content.removeClass("mfp-loading");
                      item.imgHidden = false
                  }
              }
          },
          findImageSize: function(item) {
              var counter = 0,
                  img = item.img[0],
                  mfpSetInterval = function(delay) {
                      if (_imgInterval) {
                          clearInterval(_imgInterval)
                      }
                      _imgInterval = setInterval(function() {
                          if (img.naturalWidth > 0) {
                              mfp._onImageHasSize(item);
                              return
                          }
                          if (counter > 200) {
                              clearInterval(_imgInterval)
                          }
                          counter++;
                          if (counter === 3) {
                              mfpSetInterval(10)
                          } else if (counter === 40) {
                              mfpSetInterval(50)
                          } else if (counter === 100) {
                              mfpSetInterval(500)
                          }
                      }, delay)
                  };
              mfpSetInterval(1)
          },
          getImage: function(item, template) {
              var guard = 0,
                  onLoadComplete = function() {
                      if (item) {
                          if (item.img[0].complete) {
                              item.img.off(".mfploader");
                              if (item === mfp.currItem) {
                                  mfp._onImageHasSize(item);
                                  mfp.updateStatus("ready")
                              }
                              item.hasSize = true;
                              item.loaded = true;
                              _mfpTrigger("ImageLoadComplete")
                          } else {
                              guard++;
                              if (guard < 200) {
                                  setTimeout(onLoadComplete, 100)
                              } else {
                                  onLoadError()
                              }
                          }
                      }
                  },
                  onLoadError = function() {
                      if (item) {
                          item.img.off(".mfploader");
                          if (item === mfp.currItem) {
                              mfp._onImageHasSize(item);
                              mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src))
                          }
                          item.hasSize = true;
                          item.loaded = true;
                          item.loadError = true
                      }
                  },
                  imgSt = mfp.st.image;
              var el = template.find(".mfp-img");
              if (el.length) {
                  var img = document.createElement("img");
                  img.className = "mfp-img";
                  if (item.el && item.el.find("img").length) {
                      img.alt = item.el.find("img").attr("alt")
                  }
                  item.img = $(img).on("load.mfploader", onLoadComplete).on("error.mfploader", onLoadError);
                  img.src = item.src;
                  if (el.is("img")) {
                      item.img = item.img.clone()
                  }
                  img = item.img[0];
                  if (img.naturalWidth > 0) {
                      item.hasSize = true
                  } else if (!img.width) {
                      item.hasSize = false
                  }
              }
              mfp._parseMarkup(template, {
                  title: _getTitle(item),
                  img_replaceWith: item.img
              }, item);
              mfp.resizeImage();
              if (item.hasSize) {
                  if (_imgInterval) clearInterval(_imgInterval);
                  if (item.loadError) {
                      template.addClass("mfp-loading");
                      mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src))
                  } else {
                      template.removeClass("mfp-loading");
                      mfp.updateStatus("ready")
                  }
                  return template
              }
              mfp.updateStatus("loading");
              item.loading = true;
              if (!item.hasSize) {
                  item.imgHidden = true;
                  template.addClass("mfp-loading");
                  mfp.findImageSize(item)
              }
              return template
          }
      }
  });
  var hasMozTransform, getHasMozTransform = function() {
      if (hasMozTransform === undefined) {
          hasMozTransform = document.createElement("p").style.MozTransform !== undefined
      }
      return hasMozTransform
  };
  $.magnificPopup.registerModule("zoom", {
      options: {
          enabled: false,
          easing: "ease-in-out",
          duration: 300,
          opener: function(element) {
              return element.is("img") ? element : element.find("img")
          }
      },
      proto: {
          initZoom: function() {
              var zoomSt = mfp.st.zoom,
                  ns = ".zoom",
                  image;
              if (!zoomSt.enabled || !mfp.supportsTransition) {
                  return
              }
              var duration = zoomSt.duration,
                  getElToAnimate = function(image) {
                      var newImg = image.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
                          transition = "all " + zoomSt.duration / 1e3 + "s " + zoomSt.easing,
                          cssObj = {
                              position: "fixed",
                              zIndex: 9999,
                              left: 0,
                              top: 0,
                              "-webkit-backface-visibility": "hidden"
                          },
                          t = "transition";
                      cssObj["-webkit-" + t] = cssObj["-moz-" + t] = cssObj["-o-" + t] = cssObj[t] = transition;
                      newImg.css(cssObj);
                      return newImg
                  },
                  showMainContent = function() {
                      mfp.content.css("visibility", "visible")
                  },
                  openTimeout, animatedImg;
              _mfpOn("BuildControls" + ns, function() {
                  if (mfp._allowZoom()) {
                      clearTimeout(openTimeout);
                      mfp.content.css("visibility", "hidden");
                      image = mfp._getItemToZoom();
                      if (!image) {
                          showMainContent();
                          return
                      }
                      animatedImg = getElToAnimate(image);
                      animatedImg.css(mfp._getOffset());
                      mfp.wrap.append(animatedImg);
                      openTimeout = setTimeout(function() {
                          animatedImg.css(mfp._getOffset(true));
                          openTimeout = setTimeout(function() {
                              showMainContent();
                              setTimeout(function() {
                                  animatedImg.remove();
                                  image = animatedImg = null;
                                  _mfpTrigger("ZoomAnimationEnded")
                              }, 16)
                          }, duration)
                      }, 16)
                  }
              });
              _mfpOn(BEFORE_CLOSE_EVENT + ns, function() {
                  if (mfp._allowZoom()) {
                      clearTimeout(openTimeout);
                      mfp.st.removalDelay = duration;
                      if (!image) {
                          image = mfp._getItemToZoom();
                          if (!image) {
                              return
                          }
                          animatedImg = getElToAnimate(image)
                      }
                      animatedImg.css(mfp._getOffset(true));
                      mfp.wrap.append(animatedImg);
                      mfp.content.css("visibility", "hidden");
                      setTimeout(function() {
                          animatedImg.css(mfp._getOffset())
                      }, 16)
                  }
              });
              _mfpOn(CLOSE_EVENT + ns, function() {
                  if (mfp._allowZoom()) {
                      showMainContent();
                      if (animatedImg) {
                          animatedImg.remove()
                      }
                      image = null
                  }
              })
          },
          _allowZoom: function() {
              return mfp.currItem.type === "image"
          },
          _getItemToZoom: function() {
              if (mfp.currItem.hasSize) {
                  return mfp.currItem.img
              } else {
                  return false
              }
          },
          _getOffset: function(isLarge) {
              var el;
              if (isLarge) {
                  el = mfp.currItem.img
              } else {
                  el = mfp.st.zoom.opener(mfp.currItem.el || mfp.currItem)
              }
              var offset = el.offset();
              var paddingTop = parseInt(el.css("padding-top"), 10);
              var paddingBottom = parseInt(el.css("padding-bottom"), 10);
              offset.top -= $(window).scrollTop() - paddingTop;
              var obj = {
                  width: el.width(),
                  height: (_isJQ ? el.innerHeight() : el[0].offsetHeight) - paddingBottom - paddingTop
              };
              if (getHasMozTransform()) {
                  obj["-moz-transform"] = obj["transform"] = "translate(" + offset.left + "px," + offset.top + "px)"
              } else {
                  obj.left = offset.left;
                  obj.top = offset.top
              }
              return obj
          }
      }
  });
  var IFRAME_NS = "iframe",
      _emptyPage = "//about:blank",
      _fixIframeBugs = function(isShowing) {
          if (mfp.currTemplate[IFRAME_NS]) {
              var el = mfp.currTemplate[IFRAME_NS].find("iframe");
              if (el.length) {
                  if (!isShowing) {
                      el[0].src = _emptyPage
                  }
                  if (mfp.isIE8) {
                      el.css("display", isShowing ? "block" : "none")
                  }
              }
          }
      };
  $.magnificPopup.registerModule(IFRAME_NS, {
      options: {
          markup: '<div class="mfp-iframe-scaler">' + '<div class="mfp-close"></div>' + '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' + "</div>",
          srcAction: "iframe_src",
          patterns: {
              youtube: {
                  index: "youtube.com",
                  id: "v=",
                  src: "//www.youtube.com/embed/%id%?autoplay=1"
              },
              vimeo: {
                  index: "vimeo.com/",
                  id: "/",
                  src: "//player.vimeo.com/video/%id%?autoplay=1"
              },
              gmaps: {
                  index: "//maps.google.",
                  src: "%id%&output=embed"
              }
          }
      },
      proto: {
          initIframe: function() {
              mfp.types.push(IFRAME_NS);
              _mfpOn("BeforeChange", function(e, prevType, newType) {
                  if (prevType !== newType) {
                      if (prevType === IFRAME_NS) {
                          _fixIframeBugs()
                      } else if (newType === IFRAME_NS) {
                          _fixIframeBugs(true)
                      }
                  }
              });
              _mfpOn(CLOSE_EVENT + "." + IFRAME_NS, function() {
                  _fixIframeBugs()
              })
          },
          getIframe: function(item, template) {
              var embedSrc = item.src;
              var iframeSt = mfp.st.iframe;
              $.each(iframeSt.patterns, function() {
                  if (embedSrc.indexOf(this.index) > -1) {
                      if (this.id) {
                          if (typeof this.id === "string") {
                              embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length)
                          } else {
                              embedSrc = this.id.call(this, embedSrc)
                          }
                      }
                      embedSrc = this.src.replace("%id%", embedSrc);
                      return false
                  }
              });
              var dataObj = {};
              if (iframeSt.srcAction) {
                  dataObj[iframeSt.srcAction] = embedSrc
              }
              mfp._parseMarkup(template, dataObj, item);
              mfp.updateStatus("ready");
              return template
          }
      }
  });
  var _getLoopedId = function(index) {
          var numSlides = mfp.items.length;
          if (index > numSlides - 1) {
              return index - numSlides
          } else if (index < 0) {
              return numSlides + index
          }
          return index
      },
      _replaceCurrTotal = function(text, curr, total) {
          return text.replace(/%curr%/gi, curr + 1).replace(/%total%/gi, total)
      };
  $.magnificPopup.registerModule("gallery", {
      options: {
          enabled: false,
          arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
          preload: [0, 2],
          navigateByImgClick: true,
          arrows: true,
          tPrev: "Previous (Left arrow key)",
          tNext: "Next (Right arrow key)",
          tCounter: "%curr% of %total%"
      },
      proto: {
          initGallery: function() {
              var gSt = mfp.st.gallery,
                  ns = ".mfp-gallery";
              mfp.direction = true;
              if (!gSt || !gSt.enabled) return false;
              _wrapClasses += " mfp-gallery";
              _mfpOn(OPEN_EVENT + ns, function() {
                  if (gSt.navigateByImgClick) {
                      mfp.wrap.on("click" + ns, ".mfp-img", function() {
                          if (mfp.items.length > 1) {
                              mfp.next();
                              return false
                          }
                      })
                  }
                  _document.on("keydown" + ns, function(e) {
                      if (e.keyCode === 37) {
                          mfp.prev()
                      } else if (e.keyCode === 39) {
                          mfp.next()
                      }
                  })
              });
              _mfpOn("UpdateStatus" + ns, function(e, data) {
                  if (data.text) {
                      data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length)
                  }
              });
              _mfpOn(MARKUP_PARSE_EVENT + ns, function(e, element, values, item) {
                  var l = mfp.items.length;
                  values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : ""
              });
              _mfpOn("BuildControls" + ns, function() {
                  if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                      var markup = gSt.arrowMarkup,
                          arrowLeft = mfp.arrowLeft = $(markup.replace(/%title%/gi, gSt.tPrev).replace(/%dir%/gi, "left")).addClass(PREVENT_CLOSE_CLASS),
                          arrowRight = mfp.arrowRight = $(markup.replace(/%title%/gi, gSt.tNext).replace(/%dir%/gi, "right")).addClass(PREVENT_CLOSE_CLASS);
                      arrowLeft.click(function() {
                          mfp.prev()
                      });
                      arrowRight.click(function() {
                          mfp.next()
                      });
                      mfp.container.append(arrowLeft.add(arrowRight))
                  }
              });
              _mfpOn(CHANGE_EVENT + ns, function() {
                  if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);
                  mfp._preloadTimeout = setTimeout(function() {
                      mfp.preloadNearbyImages();
                      mfp._preloadTimeout = null
                  }, 16)
              });
              _mfpOn(CLOSE_EVENT + ns, function() {
                  _document.off(ns);
                  mfp.wrap.off("click" + ns);
                  mfp.arrowRight = mfp.arrowLeft = null
              })
          },
          next: function() {
              mfp.direction = true;
              mfp.index = _getLoopedId(mfp.index + 1);
              mfp.updateItemHTML()
          },
          prev: function() {
              mfp.direction = false;
              mfp.index = _getLoopedId(mfp.index - 1);
              mfp.updateItemHTML()
          },
          goTo: function(newIndex) {
              mfp.direction = newIndex >= mfp.index;
              mfp.index = newIndex;
              mfp.updateItemHTML()
          },
          preloadNearbyImages: function() {
              var p = mfp.st.gallery.preload,
                  preloadBefore = Math.min(p[0], mfp.items.length),
                  preloadAfter = Math.min(p[1], mfp.items.length),
                  i;
              for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                  mfp._preloadItem(mfp.index + i)
              }
              for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                  mfp._preloadItem(mfp.index - i)
              }
          },
          _preloadItem: function(index) {
              index = _getLoopedId(index);
              if (mfp.items[index].preloaded) {
                  return
              }
              var item = mfp.items[index];
              if (!item.parsed) {
                  item = mfp.parseEl(index)
              }
              _mfpTrigger("LazyLoad", item);
              if (item.type === "image") {
                  item.img = $('<img class="mfp-img" />').on("load.mfploader", function() {
                      item.hasSize = true
                  }).on("error.mfploader", function() {
                      item.hasSize = true;
                      item.loadError = true;
                      _mfpTrigger("LazyLoadError", item)
                  }).attr("src", item.src)
              }
              item.preloaded = true
          }
      }
  });
  var RETINA_NS = "retina";
  $.magnificPopup.registerModule(RETINA_NS, {
      options: {
          replaceSrc: function(item) {
              return item.src.replace(/\.\w+$/, function(m) {
                  return "@2x" + m
              })
          },
          ratio: 1
      },
      proto: {
          initRetina: function() {
              if (window.devicePixelRatio > 1) {
                  var st = mfp.st.retina,
                      ratio = st.ratio;
                  ratio = !isNaN(ratio) ? ratio : ratio();
                  if (ratio > 1) {
                      _mfpOn("ImageHasSize" + "." + RETINA_NS, function(e, item) {
                          item.img.css({
                              "max-width": item.img[0].naturalWidth / ratio,
                              width: "100%"
                          })
                      });
                      _mfpOn("ElementParse" + "." + RETINA_NS, function(e, item) {
                          item.src = st.replaceSrc(item, ratio)
                      })
                  }
              }
          }
      }
  });
  _checkInstance()
});
! function(a) {
  "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}(function(a) {
  function b(b) {
      var g = b || window.event,
          h = i.call(arguments, 1),
          j = 0,
          l = 0,
          m = 0,
          n = 0,
          o = 0,
          p = 0;
      if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
          if (1 === g.deltaMode) {
              var q = a.data(this, "mousewheel-line-height");
              j *= q, m *= q, l *= q
          } else if (2 === g.deltaMode) {
              var r = a.data(this, "mousewheel-page-height");
              j *= r, m *= r, l *= r
          }
          if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
              var s = this.getBoundingClientRect();
              o = b.clientX - s.left, p = b.clientY - s.top
          }
          return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h)
      }
  }

  function c() {
      f = null
  }

  function d(a, b) {
      return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
  }
  var e, f, g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
      h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
      i = Array.prototype.slice;
  if (a.event.fixHooks)
      for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = a.event.special.mousewheel = {
      version: "3.1.12",
      setup: function() {
          if (this.addEventListener)
              for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);
          else this.onmousewheel = b;
          a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this))
      },
      teardown: function() {
          if (this.removeEventListener)
              for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);
          else this.onmousewheel = null;
          a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height")
      },
      getLineHeight: function(b) {
          var c = a(b),
              d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
          return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
      },
      getPageHeight: function(b) {
          return a(b).height()
      },
      settings: {
          adjustOldDeltas: !0,
          normalizeOffset: !0
      }
  };
  a.fn.extend({
      mousewheel: function(a) {
          return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
      },
      unmousewheel: function(a) {
          return this.unbind("mousewheel", a)
      }
  })
});
! function(a) {
  "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}(function(a) {
  function b(b) {
      var g = b || window.event,
          h = i.call(arguments, 1),
          j = 0,
          l = 0,
          m = 0,
          n = 0,
          o = 0,
          p = 0;
      if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
          if (1 === g.deltaMode) {
              var q = a.data(this, "mousewheel-line-height");
              j *= q, m *= q, l *= q
          } else if (2 === g.deltaMode) {
              var r = a.data(this, "mousewheel-page-height");
              j *= r, m *= r, l *= r
          }
          if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
              var s = this.getBoundingClientRect();
              o = b.clientX - s.left, p = b.clientY - s.top
          }
          return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h)
      }
  }

  function c() {
      f = null
  }

  function d(a, b) {
      return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
  }
  var e, f, g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
      h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
      i = Array.prototype.slice;
  if (a.event.fixHooks)
      for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = a.event.special.mousewheel = {
      version: "3.1.12",
      setup: function() {
          if (this.addEventListener)
              for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);
          else this.onmousewheel = b;
          a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this))
      },
      teardown: function() {
          if (this.removeEventListener)
              for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);
          else this.onmousewheel = null;
          a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height")
      },
      getLineHeight: function(b) {
          var c = a(b),
              d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
          return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
      },
      getPageHeight: function(b) {
          return a(b).height()
      },
      settings: {
          adjustOldDeltas: !0,
          normalizeOffset: !0
      }
  };
  a.fn.extend({
      mousewheel: function(a) {
          return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
      },
      unmousewheel: function(a) {
          return this.unbind("mousewheel", a)
      }
  })
});
! function(e) {
  "function" == typeof define && define.amd ? define(["jquery"], e) : "undefined" != typeof module && module.exports ? module.exports = e : e(jQuery, window, document)
}(function(e) {
  ! function(t) {
      var o = "function" == typeof define && define.amd,
          a = "undefined" != typeof module && module.exports,
          n = "https:" == document.location.protocol ? "https:" : "http:",
          i = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
      o || (a ? require("jquery-mousewheel")(e) : e.event.special.mousewheel || e("head").append(decodeURI("%3Cscript src=" + n + "//" + i + "%3E%3C/script%3E"))), t()
  }(function() {
      var t, o = "mCustomScrollbar",
          a = "mCS",
          n = ".mCustomScrollbar",
          i = {
              setTop: 0,
              setLeft: 0,
              axis: "y",
              scrollbarPosition: "inside",
              scrollInertia: 950,
              autoDraggerLength: !0,
              alwaysShowScrollbar: 0,
              snapOffset: 0,
              mouseWheel: {
                  enable: !0,
                  scrollAmount: "auto",
                  axis: "y",
                  deltaFactor: "auto",
                  disableOver: ["select", "option", "keygen", "datalist", "textarea"]
              },
              scrollButtons: {
                  scrollType: "stepless",
                  scrollAmount: "auto"
              },
              keyboard: {
                  enable: !0,
                  scrollType: "stepless",
                  scrollAmount: "auto"
              },
              contentTouchScroll: 25,
              documentTouchScroll: !0,
              advanced: {
                  autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                  updateOnContentResize: !0,
                  updateOnImageLoad: "auto",
                  autoUpdateTimeout: 60
              },
              theme: "light",
              callbacks: {
                  onTotalScrollOffset: 0,
                  onTotalScrollBackOffset: 0,
                  alwaysTriggerOffsets: !0
              }
          },
          r = 0,
          l = {},
          s = window.attachEvent && !window.addEventListener ? 1 : 0,
          c = !1,
          d = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
          u = {
              init: function(t) {
                  var t = e.extend(!0, {}, i, t),
                      o = f.call(this);
                  if (t.live) {
                      var s = t.liveSelector || this.selector || n,
                          c = e(s);
                      if ("off" === t.live) return void m(s);
                      l[s] = setTimeout(function() {
                          c.mCustomScrollbar(t), "once" === t.live && c.length && m(s)
                      }, 500)
                  } else m(s);
                  return t.setWidth = t.set_width ? t.set_width : t.setWidth, t.setHeight = t.set_height ? t.set_height : t.setHeight, t.axis = t.horizontalScroll ? "x" : p(t.axis), t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia, "object" != typeof t.mouseWheel && 1 == t.mouseWheel && (t.mouseWheel = {
                      enable: !0,
                      scrollAmount: "auto",
                      axis: "y",
                      preventDefault: !1,
                      deltaFactor: "auto",
                      normalizeDelta: !1,
                      invert: !1
                  }), t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount, t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta ? t.advanced.normalizeMouseWheelDelta : t.mouseWheel.normalizeDelta, t.scrollButtons.scrollType = g(t.scrollButtons.scrollType), h(t), e(o).each(function() {
                      var o = e(this);
                      if (!o.data(a)) {
                          o.data(a, {
                              idx: ++r,
                              opt: t,
                              scrollRatio: {
                                  y: null,
                                  x: null
                              },
                              overflowed: null,
                              contentReset: {
                                  y: null,
                                  x: null
                              },
                              bindEvents: !1,
                              tweenRunning: !1,
                              sequential: {},
                              langDir: o.css("direction"),
                              cbOffsets: null,
                              trigger: null,
                              poll: {
                                  size: {
                                      o: 0,
                                      n: 0
                                  },
                                  img: {
                                      o: 0,
                                      n: 0
                                  },
                                  change: {
                                      o: 0,
                                      n: 0
                                  }
                              }
                          });
                          var n = o.data(a),
                              i = n.opt,
                              l = o.data("mcs-axis"),
                              s = o.data("mcs-scrollbar-position"),
                              c = o.data("mcs-theme");
                          l && (i.axis = l), s && (i.scrollbarPosition = s), c && (i.theme = c, h(i)), v.call(this), n && i.callbacks.onCreate && "function" == typeof i.callbacks.onCreate && i.callbacks.onCreate.call(this), e("#mCSB_" + n.idx + "_container img:not(." + d[2] + ")").addClass(d[2]), u.update.call(null, o)
                      }
                  })
              },
              update: function(t, o) {
                  var n = t || f.call(this);
                  return e(n).each(function() {
                      var t = e(this);
                      if (t.data(a)) {
                          var n = t.data(a),
                              i = n.opt,
                              r = e("#mCSB_" + n.idx + "_container"),
                              l = e("#mCSB_" + n.idx),
                              s = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
                          if (!r.length) return;
                          n.tweenRunning && Q(t), o && n && i.callbacks.onBeforeUpdate && "function" == typeof i.callbacks.onBeforeUpdate && i.callbacks.onBeforeUpdate.call(this), t.hasClass(d[3]) && t.removeClass(d[3]), t.hasClass(d[4]) && t.removeClass(d[4]), l.css("max-height", "none"), l.height() !== t.height() && l.css("max-height", t.height()), _.call(this), "y" === i.axis || i.advanced.autoExpandHorizontalScroll || r.css("width", x(r)), n.overflowed = y.call(this), M.call(this), i.autoDraggerLength && S.call(this), b.call(this), T.call(this);
                          var c = [Math.abs(r[0].offsetTop), Math.abs(r[0].offsetLeft)];
                          "x" !== i.axis && (n.overflowed[0] ? s[0].height() > s[0].parent().height() ? B.call(this) : (G(t, c[0].toString(), {
                              dir: "y",
                              dur: 0,
                              overwrite: "none"
                          }), n.contentReset.y = null) : (B.call(this), "y" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[1] && G(t, c[1].toString(), {
                              dir: "x",
                              dur: 0,
                              overwrite: "none"
                          }))), "y" !== i.axis && (n.overflowed[1] ? s[1].width() > s[1].parent().width() ? B.call(this) : (G(t, c[1].toString(), {
                              dir: "x",
                              dur: 0,
                              overwrite: "none"
                          }), n.contentReset.x = null) : (B.call(this), "x" === i.axis ? k.call(this) : "yx" === i.axis && n.overflowed[0] && G(t, c[0].toString(), {
                              dir: "y",
                              dur: 0,
                              overwrite: "none"
                          }))), o && n && (2 === o && i.callbacks.onImageLoad && "function" == typeof i.callbacks.onImageLoad ? i.callbacks.onImageLoad.call(this) : 3 === o && i.callbacks.onSelectorChange && "function" == typeof i.callbacks.onSelectorChange ? i.callbacks.onSelectorChange.call(this) : i.callbacks.onUpdate && "function" == typeof i.callbacks.onUpdate && i.callbacks.onUpdate.call(this)), N.call(this)
                      }
                  })
              },
              scrollTo: function(t, o) {
                  if ("undefined" != typeof t && null != t) {
                      var n = f.call(this);
                      return e(n).each(function() {
                          var n = e(this);
                          if (n.data(a)) {
                              var i = n.data(a),
                                  r = i.opt,
                                  l = {
                                      trigger: "external",
                                      scrollInertia: r.scrollInertia,
                                      scrollEasing: "mcsEaseInOut",
                                      moveDragger: !1,
                                      timeout: 60,
                                      callbacks: !0,
                                      onStart: !0,
                                      onUpdate: !0,
                                      onComplete: !0
                                  },
                                  s = e.extend(!0, {}, l, o),
                                  c = Y.call(this, t),
                                  d = s.scrollInertia > 0 && s.scrollInertia < 17 ? 17 : s.scrollInertia;
                              c[0] = X.call(this, c[0], "y"), c[1] = X.call(this, c[1], "x"), s.moveDragger && (c[0] *= i.scrollRatio.y, c[1] *= i.scrollRatio.x), s.dur = ne() ? 0 : d, setTimeout(function() {
                                  null !== c[0] && "undefined" != typeof c[0] && "x" !== r.axis && i.overflowed[0] && (s.dir = "y", s.overwrite = "all", G(n, c[0].toString(), s)), null !== c[1] && "undefined" != typeof c[1] && "y" !== r.axis && i.overflowed[1] && (s.dir = "x", s.overwrite = "none", G(n, c[1].toString(), s))
                              }, s.timeout)
                          }
                      })
                  }
              },
              stop: function() {
                  var t = f.call(this);
                  return e(t).each(function() {
                      var t = e(this);
                      t.data(a) && Q(t)
                  })
              },
              disable: function(t) {
                  var o = f.call(this);
                  return e(o).each(function() {
                      var o = e(this);
                      if (o.data(a)) {
                          o.data(a);
                          N.call(this, "remove"), k.call(this), t && B.call(this), M.call(this, !0), o.addClass(d[3])
                      }
                  })
              },
              destroy: function() {
                  var t = f.call(this);
                  return e(t).each(function() {
                      var n = e(this);
                      if (n.data(a)) {
                          var i = n.data(a),
                              r = i.opt,
                              l = e("#mCSB_" + i.idx),
                              s = e("#mCSB_" + i.idx + "_container"),
                              c = e(".mCSB_" + i.idx + "_scrollbar");
                          r.live && m(r.liveSelector || e(t).selector), N.call(this, "remove"), k.call(this), B.call(this), n.removeData(a), $(this, "mcs"), c.remove(), s.find("img." + d[2]).removeClass(d[2]), l.replaceWith(s.contents()), n.removeClass(o + " _" + a + "_" + i.idx + " " + d[6] + " " + d[7] + " " + d[5] + " " + d[3]).addClass(d[4])
                      }
                  })
              }
          },
          f = function() {
              return "object" != typeof e(this) || e(this).length < 1 ? n : this
          },
          h = function(t) {
              var o = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
                  a = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
                  n = ["minimal", "minimal-dark"],
                  i = ["minimal", "minimal-dark"],
                  r = ["minimal", "minimal-dark"];
              t.autoDraggerLength = e.inArray(t.theme, o) > -1 ? !1 : t.autoDraggerLength, t.autoExpandScrollbar = e.inArray(t.theme, a) > -1 ? !1 : t.autoExpandScrollbar, t.scrollButtons.enable = e.inArray(t.theme, n) > -1 ? !1 : t.scrollButtons.enable, t.autoHideScrollbar = e.inArray(t.theme, i) > -1 ? !0 : t.autoHideScrollbar, t.scrollbarPosition = e.inArray(t.theme, r) > -1 ? "outside" : t.scrollbarPosition
          },
          m = function(e) {
              l[e] && (clearTimeout(l[e]), $(l, e))
          },
          p = function(e) {
              return "yx" === e || "xy" === e || "auto" === e ? "yx" : "x" === e || "horizontal" === e ? "x" : "y"
          },
          g = function(e) {
              return "stepped" === e || "pixels" === e || "step" === e || "click" === e ? "stepped" : "stepless"
          },
          v = function() {
              var t = e(this),
                  n = t.data(a),
                  i = n.opt,
                  r = i.autoExpandScrollbar ? " " + d[1] + "_expand" : "",
                  l = ["<div id='mCSB_" + n.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_vertical" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div></div><div class='mCSB_draggerRail' /></div>", "<div id='mCSB_" + n.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_horizontal" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div></div><div class='mCSB_draggerRail' /></div>"],
                  s = "yx" === i.axis ? "mCSB_vertical_horizontal" : "x" === i.axis ? "mCSB_horizontal" : "mCSB_vertical",
                  c = "yx" === i.axis ? l[0] + l[1] : "x" === i.axis ? l[1] : l[0],
                  u = "yx" === i.axis ? "<div id='mCSB_" + n.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
                  f = i.autoHideScrollbar ? " " + d[6] : "",
                  h = "x" !== i.axis && "rtl" === n.langDir ? " " + d[7] : "";
              i.setWidth && t.css("width", i.setWidth), i.setHeight && t.css("height", i.setHeight), i.setLeft = "y" !== i.axis && "rtl" === n.langDir ? "989999px" : i.setLeft, t.addClass(o + " _" + a + "_" + n.idx + f + h).wrapInner("<div id='mCSB_" + n.idx + "' class='mCustomScrollBox mCS-" + i.theme + " " + s + "'><div id='mCSB_" + n.idx + "_container' class='mCSB_container' style='position:relative; top:" + i.setTop + "; left:" + i.setLeft + ";' dir='" + n.langDir + "' /></div>");
              var m = e("#mCSB_" + n.idx),
                  p = e("#mCSB_" + n.idx + "_container");
              "y" === i.axis || i.advanced.autoExpandHorizontalScroll || p.css("width", x(p)), "outside" === i.scrollbarPosition ? ("static" === t.css("position") && t.css("position", "relative"), t.css("overflow", "visible"), m.addClass("mCSB_outside").after(c)) : (m.addClass("mCSB_inside").append(c), p.wrap(u)), w.call(this);
              var g = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
              g[0].css("min-height", g[0].height()), g[1].css("min-width", g[1].width())
          },
          x = function(t) {
              var o = [t[0].scrollWidth, Math.max.apply(Math, t.children().map(function() {
                      return e(this).outerWidth(!0)
                  }).get())],
                  a = t.parent().width();
              return o[0] > a ? o[0] : o[1] > a ? o[1] : "100%"
          },
          _ = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = e("#mCSB_" + o.idx + "_container");
              if (n.advanced.autoExpandHorizontalScroll && "y" !== n.axis) {
                  i.css({
                      width: "auto",
                      "min-width": 0,
                      "overflow-x": "scroll"
                  });
                  var r = Math.ceil(i[0].scrollWidth);
                  3 === n.advanced.autoExpandHorizontalScroll || 2 !== n.advanced.autoExpandHorizontalScroll && r > i.parent().width() ? i.css({
                      width: r,
                      "min-width": "100%",
                      "overflow-x": "inherit"
                  }) : i.css({
                      "overflow-x": "inherit",
                      position: "absolute"
                  }).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
                      width: Math.ceil(i[0].getBoundingClientRect().right + .4) - Math.floor(i[0].getBoundingClientRect().left),
                      "min-width": "100%",
                      position: "relative"
                  }).unwrap()
              }
          },
          w = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = e(".mCSB_" + o.idx + "_scrollbar:first"),
                  r = oe(n.scrollButtons.tabindex) ? "tabindex='" + n.scrollButtons.tabindex + "'" : "",
                  l = ["<a href='#' class='" + d[13] + "' " + r + " />", "<a href='#' class='" + d[14] + "' " + r + " />", "<a href='#' class='" + d[15] + "' " + r + " />", "<a href='#' class='" + d[16] + "' " + r + " />"],
                  s = ["x" === n.axis ? l[2] : l[0], "x" === n.axis ? l[3] : l[1], l[2], l[3]];
              n.scrollButtons.enable && i.prepend(s[0]).append(s[1]).next(".mCSB_scrollTools").prepend(s[2]).append(s[3])
          },
          S = function() {
              var t = e(this),
                  o = t.data(a),
                  n = e("#mCSB_" + o.idx),
                  i = e("#mCSB_" + o.idx + "_container"),
                  r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
                  l = [n.height() / i.outerHeight(!1), n.width() / i.outerWidth(!1)],
                  c = [parseInt(r[0].css("min-height")), Math.round(l[0] * r[0].parent().height()), parseInt(r[1].css("min-width")), Math.round(l[1] * r[1].parent().width())],
                  d = s && c[1] < c[0] ? c[0] : c[1],
                  u = s && c[3] < c[2] ? c[2] : c[3];
              r[0].css({
                  height: d,
                  "max-height": r[0].parent().height() - 10
              }).find(".mCSB_dragger_bar").css({
                  "line-height": c[0] + "px"
              }), r[1].css({
                  width: u,
                  "max-width": r[1].parent().width() - 10
              })
          },
          b = function() {
              var t = e(this),
                  o = t.data(a),
                  n = e("#mCSB_" + o.idx),
                  i = e("#mCSB_" + o.idx + "_container"),
                  r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
                  l = [i.outerHeight(!1) - n.height(), i.outerWidth(!1) - n.width()],
                  s = [l[0] / (r[0].parent().height() - r[0].height()), l[1] / (r[1].parent().width() - r[1].width())];
              o.scrollRatio = {
                  y: s[0],
                  x: s[1]
              }
          },
          C = function(e, t, o) {
              var a = o ? d[0] + "_expanded" : "",
                  n = e.closest(".mCSB_scrollTools");
              "active" === t ? (e.toggleClass(d[0] + " " + a), n.toggleClass(d[1]), e[0]._draggable = e[0]._draggable ? 0 : 1) : e[0]._draggable || ("hide" === t ? (e.removeClass(d[0]), n.removeClass(d[1])) : (e.addClass(d[0]), n.addClass(d[1])))
          },
          y = function() {
              var t = e(this),
                  o = t.data(a),
                  n = e("#mCSB_" + o.idx),
                  i = e("#mCSB_" + o.idx + "_container"),
                  r = null == o.overflowed ? i.height() : i.outerHeight(!1),
                  l = null == o.overflowed ? i.width() : i.outerWidth(!1),
                  s = i[0].scrollHeight,
                  c = i[0].scrollWidth;
              return s > r && (r = s), c > l && (l = c), [r > n.height(), l > n.width()]
          },
          B = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = e("#mCSB_" + o.idx),
                  r = e("#mCSB_" + o.idx + "_container"),
                  l = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")];
              if (Q(t), ("x" !== n.axis && !o.overflowed[0] || "y" === n.axis && o.overflowed[0]) && (l[0].add(r).css("top", 0), G(t, "_resetY")), "y" !== n.axis && !o.overflowed[1] || "x" === n.axis && o.overflowed[1]) {
                  var s = dx = 0;
                  "rtl" === o.langDir && (s = i.width() - r.outerWidth(!1), dx = Math.abs(s / o.scrollRatio.x)), r.css("left", s), l[1].css("left", dx), G(t, "_resetX")
              }
          },
          T = function() {
              function t() {
                  r = setTimeout(function() {
                      e.event.special.mousewheel ? (clearTimeout(r), W.call(o[0])) : t()
                  }, 100)
              }
              var o = e(this),
                  n = o.data(a),
                  i = n.opt;
              if (!n.bindEvents) {
                  if (I.call(this), i.contentTouchScroll && D.call(this), E.call(this), i.mouseWheel.enable) {
                      var r;
                      t()
                  }
                  P.call(this), U.call(this), i.advanced.autoScrollOnFocus && H.call(this), i.scrollButtons.enable && F.call(this), i.keyboard.enable && q.call(this), n.bindEvents = !0
              }
          },
          k = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = a + "_" + o.idx,
                  r = ".mCSB_" + o.idx + "_scrollbar",
                  l = e("#mCSB_" + o.idx + ",#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper," + r + " ." + d[12] + ",#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal," + r + ">a"),
                  s = e("#mCSB_" + o.idx + "_container");
              n.advanced.releaseDraggableSelectors && l.add(e(n.advanced.releaseDraggableSelectors)), n.advanced.extraDraggableSelectors && l.add(e(n.advanced.extraDraggableSelectors)), o.bindEvents && (e(document).add(e(!A() || top.document)).unbind("." + i), l.each(function() {
                  e(this).unbind("." + i)
              }), clearTimeout(t[0]._focusTimeout), $(t[0], "_focusTimeout"), clearTimeout(o.sequential.step), $(o.sequential, "step"), clearTimeout(s[0].onCompleteTimeout), $(s[0], "onCompleteTimeout"), o.bindEvents = !1)
          },
          M = function(t) {
              var o = e(this),
                  n = o.data(a),
                  i = n.opt,
                  r = e("#mCSB_" + n.idx + "_container_wrapper"),
                  l = r.length ? r : e("#mCSB_" + n.idx + "_container"),
                  s = [e("#mCSB_" + n.idx + "_scrollbar_vertical"), e("#mCSB_" + n.idx + "_scrollbar_horizontal")],
                  c = [s[0].find(".mCSB_dragger"), s[1].find(".mCSB_dragger")];
              "x" !== i.axis && (n.overflowed[0] && !t ? (s[0].add(c[0]).add(s[0].children("a")).css("display", "block"), l.removeClass(d[8] + " " + d[10])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[0].css("display", "none"), l.removeClass(d[10])) : (s[0].css("display", "none"), l.addClass(d[10])), l.addClass(d[8]))), "y" !== i.axis && (n.overflowed[1] && !t ? (s[1].add(c[1]).add(s[1].children("a")).css("display", "block"), l.removeClass(d[9] + " " + d[11])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[1].css("display", "none"), l.removeClass(d[11])) : (s[1].css("display", "none"), l.addClass(d[11])), l.addClass(d[9]))), n.overflowed[0] || n.overflowed[1] ? o.removeClass(d[5]) : o.addClass(d[5])
          },
          O = function(t) {
              var o = t.type,
                  a = t.target.ownerDocument !== document && null !== frameElement ? [e(frameElement).offset().top, e(frameElement).offset().left] : null,
                  n = A() && t.target.ownerDocument !== top.document && null !== frameElement ? [e(t.view.frameElement).offset().top, e(t.view.frameElement).offset().left] : [0, 0];
              switch (o) {
                  case "pointerdown":
                  case "MSPointerDown":
                  case "pointermove":
                  case "MSPointerMove":
                  case "pointerup":
                  case "MSPointerUp":
                      return a ? [t.originalEvent.pageY - a[0] + n[0], t.originalEvent.pageX - a[1] + n[1], !1] : [t.originalEvent.pageY, t.originalEvent.pageX, !1];
                  case "touchstart":
                  case "touchmove":
                  case "touchend":
                      var i = t.originalEvent.touches[0] || t.originalEvent.changedTouches[0],
                          r = t.originalEvent.touches.length || t.originalEvent.changedTouches.length;
                      return t.target.ownerDocument !== document ? [i.screenY, i.screenX, r > 1] : [i.pageY, i.pageX, r > 1];
                  default:
                      return a ? [t.pageY - a[0] + n[0], t.pageX - a[1] + n[1], !1] : [t.pageY, t.pageX, !1]
              }
          },
          I = function() {
              function t(e, t, a, n) {
                  if (h[0].idleTimer = d.scrollInertia < 233 ? 250 : 0, o.attr("id") === f[1]) var i = "x",
                      s = (o[0].offsetLeft - t + n) * l.scrollRatio.x;
                  else var i = "y",
                      s = (o[0].offsetTop - e + a) * l.scrollRatio.y;
                  G(r, s.toString(), {
                      dir: i,
                      drag: !0
                  })
              }
              var o, n, i, r = e(this),
                  l = r.data(a),
                  d = l.opt,
                  u = a + "_" + l.idx,
                  f = ["mCSB_" + l.idx + "_dragger_vertical", "mCSB_" + l.idx + "_dragger_horizontal"],
                  h = e("#mCSB_" + l.idx + "_container"),
                  m = e("#" + f[0] + ",#" + f[1]),
                  p = d.advanced.releaseDraggableSelectors ? m.add(e(d.advanced.releaseDraggableSelectors)) : m,
                  g = d.advanced.extraDraggableSelectors ? e(!A() || top.document).add(e(d.advanced.extraDraggableSelectors)) : e(!A() || top.document);
              m.bind("contextmenu." + u, function(e) {
                  e.preventDefault()
              }).bind("mousedown." + u + " touchstart." + u + " pointerdown." + u + " MSPointerDown." + u, function(t) {
                  if (t.stopImmediatePropagation(), t.preventDefault(), ee(t)) {
                      c = !0, s && (document.onselectstart = function() {
                          return !1
                      }), L.call(h, !1), Q(r), o = e(this);
                      var a = o.offset(),
                          l = O(t)[0] - a.top,
                          u = O(t)[1] - a.left,
                          f = o.height() + a.top,
                          m = o.width() + a.left;
                      f > l && l > 0 && m > u && u > 0 && (n = l, i = u), C(o, "active", d.autoExpandScrollbar)
                  }
              }).bind("touchmove." + u, function(e) {
                  e.stopImmediatePropagation(), e.preventDefault();
                  var a = o.offset(),
                      r = O(e)[0] - a.top,
                      l = O(e)[1] - a.left;
                  t(n, i, r, l)
              }), e(document).add(g).bind("mousemove." + u + " pointermove." + u + " MSPointerMove." + u, function(e) {
                  if (o) {
                      var a = o.offset(),
                          r = O(e)[0] - a.top,
                          l = O(e)[1] - a.left;
                      if (n === r && i === l) return;
                      t(n, i, r, l)
                  }
              }).add(p).bind("mouseup." + u + " touchend." + u + " pointerup." + u + " MSPointerUp." + u, function() {
                  o && (C(o, "active", d.autoExpandScrollbar), o = null), c = !1, s && (document.onselectstart = null), L.call(h, !0)
              })
          },
          D = function() {
              function o(e) {
                  if (!te(e) || c || O(e)[2]) return void(t = 0);
                  t = 1, b = 0, C = 0, d = 1, y.removeClass("mCS_touch_action");
                  var o = I.offset();
                  u = O(e)[0] - o.top, f = O(e)[1] - o.left, z = [O(e)[0], O(e)[1]]
              }

              function n(e) {
                  if (te(e) && !c && !O(e)[2] && (T.documentTouchScroll || e.preventDefault(), e.stopImmediatePropagation(), (!C || b) && d)) {
                      g = K();
                      var t = M.offset(),
                          o = O(e)[0] - t.top,
                          a = O(e)[1] - t.left,
                          n = "mcsLinearOut";
                      if (E.push(o), W.push(a), z[2] = Math.abs(O(e)[0] - z[0]), z[3] = Math.abs(O(e)[1] - z[1]), B.overflowed[0]) var i = D[0].parent().height() - D[0].height(),
                          r = u - o > 0 && o - u > -(i * B.scrollRatio.y) && (2 * z[3] < z[2] || "yx" === T.axis);
                      if (B.overflowed[1]) var l = D[1].parent().width() - D[1].width(),
                          h = f - a > 0 && a - f > -(l * B.scrollRatio.x) && (2 * z[2] < z[3] || "yx" === T.axis);
                      r || h ? (U || e.preventDefault(), b = 1) : (C = 1, y.addClass("mCS_touch_action")), U && e.preventDefault(), w = "yx" === T.axis ? [u - o, f - a] : "x" === T.axis ? [null, f - a] : [u - o, null], I[0].idleTimer = 250, B.overflowed[0] && s(w[0], R, n, "y", "all", !0), B.overflowed[1] && s(w[1], R, n, "x", L, !0)
                  }
              }

              function i(e) {
                  if (!te(e) || c || O(e)[2]) return void(t = 0);
                  t = 1, e.stopImmediatePropagation(), Q(y), p = K();
                  var o = M.offset();
                  h = O(e)[0] - o.top, m = O(e)[1] - o.left, E = [], W = []
              }

              function r(e) {
                  if (te(e) && !c && !O(e)[2]) {
                      d = 0, e.stopImmediatePropagation(), b = 0, C = 0, v = K();
                      var t = M.offset(),
                          o = O(e)[0] - t.top,
                          a = O(e)[1] - t.left;
                      if (!(v - g > 30)) {
                          _ = 1e3 / (v - p);
                          var n = "mcsEaseOut",
                              i = 2.5 > _,
                              r = i ? [E[E.length - 2], W[W.length - 2]] : [0, 0];
                          x = i ? [o - r[0], a - r[1]] : [o - h, a - m];
                          var u = [Math.abs(x[0]), Math.abs(x[1])];
                          _ = i ? [Math.abs(x[0] / 4), Math.abs(x[1] / 4)] : [_, _];
                          var f = [Math.abs(I[0].offsetTop) - x[0] * l(u[0] / _[0], _[0]), Math.abs(I[0].offsetLeft) - x[1] * l(u[1] / _[1], _[1])];
                          w = "yx" === T.axis ? [f[0], f[1]] : "x" === T.axis ? [null, f[1]] : [f[0], null], S = [4 * u[0] + T.scrollInertia, 4 * u[1] + T.scrollInertia];
                          var y = parseInt(T.contentTouchScroll) || 0;
                          w[0] = u[0] > y ? w[0] : 0, w[1] = u[1] > y ? w[1] : 0, B.overflowed[0] && s(w[0], S[0], n, "y", L, !1), B.overflowed[1] && s(w[1], S[1], n, "x", L, !1)
                      }
                  }
              }

              function l(e, t) {
                  var o = [1.5 * t, 2 * t, t / 1.5, t / 2];
                  return e > 90 ? t > 4 ? o[0] : o[3] : e > 60 ? t > 3 ? o[3] : o[2] : e > 30 ? t > 8 ? o[1] : t > 6 ? o[0] : t > 4 ? t : o[2] : t > 8 ? t : o[3]
              }

              function s(e, t, o, a, n, i) {
                  e && G(y, e.toString(), {
                      dur: t,
                      scrollEasing: o,
                      dir: a,
                      overwrite: n,
                      drag: i
                  })
              }
              var d, u, f, h, m, p, g, v, x, _, w, S, b, C, y = e(this),
                  B = y.data(a),
                  T = B.opt,
                  k = a + "_" + B.idx,
                  M = e("#mCSB_" + B.idx),
                  I = e("#mCSB_" + B.idx + "_container"),
                  D = [e("#mCSB_" + B.idx + "_dragger_vertical"), e("#mCSB_" + B.idx + "_dragger_horizontal")],
                  E = [],
                  W = [],
                  R = 0,
                  L = "yx" === T.axis ? "none" : "all",
                  z = [],
                  P = I.find("iframe"),
                  H = ["touchstart." + k + " pointerdown." + k + " MSPointerDown." + k, "touchmove." + k + " pointermove." + k + " MSPointerMove." + k, "touchend." + k + " pointerup." + k + " MSPointerUp." + k],
                  U = void 0 !== document.body.style.touchAction && "" !== document.body.style.touchAction;
              I.bind(H[0], function(e) {
                  o(e)
              }).bind(H[1], function(e) {
                  n(e)
              }), M.bind(H[0], function(e) {
                  i(e)
              }).bind(H[2], function(e) {
                  r(e)
              }), P.length && P.each(function() {
                  e(this).bind("load", function() {
                      A(this) && e(this.contentDocument || this.contentWindow.document).bind(H[0], function(e) {
                          o(e), i(e)
                      }).bind(H[1], function(e) {
                          n(e)
                      }).bind(H[2], function(e) {
                          r(e)
                      })
                  })
              })
          },
          E = function() {
              function o() {
                  return window.getSelection ? window.getSelection().toString() : document.selection && "Control" != document.selection.type ? document.selection.createRange().text : 0
              }

              function n(e, t, o) {
                  d.type = o && i ? "stepped" : "stepless", d.scrollAmount = 10, j(r, e, t, "mcsLinearOut", o ? 60 : null)
              }
              var i, r = e(this),
                  l = r.data(a),
                  s = l.opt,
                  d = l.sequential,
                  u = a + "_" + l.idx,
                  f = e("#mCSB_" + l.idx + "_container"),
                  h = f.parent();
              f.bind("mousedown." + u, function() {
                  t || i || (i = 1, c = !0)
              }).add(document).bind("mousemove." + u, function(e) {
                  if (!t && i && o()) {
                      var a = f.offset(),
                          r = O(e)[0] - a.top + f[0].offsetTop,
                          c = O(e)[1] - a.left + f[0].offsetLeft;
                      r > 0 && r < h.height() && c > 0 && c < h.width() ? d.step && n("off", null, "stepped") : ("x" !== s.axis && l.overflowed[0] && (0 > r ? n("on", 38) : r > h.height() && n("on", 40)), "y" !== s.axis && l.overflowed[1] && (0 > c ? n("on", 37) : c > h.width() && n("on", 39)))
                  }
              }).bind("mouseup." + u + " dragend." + u, function() {
                  t || (i && (i = 0, n("off", null)), c = !1)
              })
          },
          W = function() {
              function t(t, a) {
                  if (Q(o), !z(o, t.target)) {
                      var r = "auto" !== i.mouseWheel.deltaFactor ? parseInt(i.mouseWheel.deltaFactor) : s && t.deltaFactor < 100 ? 100 : t.deltaFactor || 100,
                          d = i.scrollInertia;
                      if ("x" === i.axis || "x" === i.mouseWheel.axis) var u = "x",
                          f = [Math.round(r * n.scrollRatio.x), parseInt(i.mouseWheel.scrollAmount)],
                          h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.width() ? .9 * l.width() : f[0],
                          m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetLeft),
                          p = c[1][0].offsetLeft,
                          g = c[1].parent().width() - c[1].width(),
                          v = "y" === i.mouseWheel.axis ? t.deltaY || a : t.deltaX;
                      else var u = "y",
                          f = [Math.round(r * n.scrollRatio.y), parseInt(i.mouseWheel.scrollAmount)],
                          h = "auto" !== i.mouseWheel.scrollAmount ? f[1] : f[0] >= l.height() ? .9 * l.height() : f[0],
                          m = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetTop),
                          p = c[0][0].offsetTop,
                          g = c[0].parent().height() - c[0].height(),
                          v = t.deltaY || a;
                      "y" === u && !n.overflowed[0] || "x" === u && !n.overflowed[1] || ((i.mouseWheel.invert || t.webkitDirectionInvertedFromDevice) && (v = -v), i.mouseWheel.normalizeDelta && (v = 0 > v ? -1 : 1), (v > 0 && 0 !== p || 0 > v && p !== g || i.mouseWheel.preventDefault) && (t.stopImmediatePropagation(), t.preventDefault()), t.deltaFactor < 5 && !i.mouseWheel.normalizeDelta && (h = t.deltaFactor, d = 17), G(o, (m - v * h).toString(), {
                          dir: u,
                          dur: d
                      }))
                  }
              }
              if (e(this).data(a)) {
                  var o = e(this),
                      n = o.data(a),
                      i = n.opt,
                      r = a + "_" + n.idx,
                      l = e("#mCSB_" + n.idx),
                      c = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")],
                      d = e("#mCSB_" + n.idx + "_container").find("iframe");
                  d.length && d.each(function() {
                      e(this).bind("load", function() {
                          A(this) && e(this.contentDocument || this.contentWindow.document).bind("mousewheel." + r, function(e, o) {
                              t(e, o)
                          })
                      })
                  }), l.bind("mousewheel." + r, function(e, o) {
                      t(e, o)
                  })
              }
          },
          R = new Object,
          A = function(t) {
              var o = !1,
                  a = !1,
                  n = null;
              if (void 0 === t ? a = "#empty" : void 0 !== e(t).attr("id") && (a = e(t).attr("id")), a !== !1 && void 0 !== R[a]) return R[a];
              if (t) {
                  try {
                      var i = t.contentDocument || t.contentWindow.document;
                      n = i.body.innerHTML
                  } catch (r) {}
                  o = null !== n
              } else {
                  try {
                      var i = top.document;
                      n = i.body.innerHTML
                  } catch (r) {}
                  o = null !== n
              }
              return a !== !1 && (R[a] = o), o
          },
          L = function(e) {
              var t = this.find("iframe");
              if (t.length) {
                  var o = e ? "auto" : "none";
                  t.css("pointer-events", o)
              }
          },
          z = function(t, o) {
              var n = o.nodeName.toLowerCase(),
                  i = t.data(a).opt.mouseWheel.disableOver,
                  r = ["select", "textarea"];
              return e.inArray(n, i) > -1 && !(e.inArray(n, r) > -1 && !e(o).is(":focus"))
          },
          P = function() {
              var t, o = e(this),
                  n = o.data(a),
                  i = a + "_" + n.idx,
                  r = e("#mCSB_" + n.idx + "_container"),
                  l = r.parent(),
                  s = e(".mCSB_" + n.idx + "_scrollbar ." + d[12]);
              s.bind("mousedown." + i + " touchstart." + i + " pointerdown." + i + " MSPointerDown." + i, function(o) {
                  c = !0, e(o.target).hasClass("mCSB_dragger") || (t = 1)
              }).bind("touchend." + i + " pointerup." + i + " MSPointerUp." + i, function() {
                  c = !1
              }).bind("click." + i, function(a) {
                  if (t && (t = 0, e(a.target).hasClass(d[12]) || e(a.target).hasClass("mCSB_draggerRail"))) {
                      Q(o);
                      var i = e(this),
                          s = i.find(".mCSB_dragger");
                      if (i.parent(".mCSB_scrollTools_horizontal").length > 0) {
                          if (!n.overflowed[1]) return;
                          var c = "x",
                              u = a.pageX > s.offset().left ? -1 : 1,
                              f = Math.abs(r[0].offsetLeft) - u * (.9 * l.width())
                      } else {
                          if (!n.overflowed[0]) return;
                          var c = "y",
                              u = a.pageY > s.offset().top ? -1 : 1,
                              f = Math.abs(r[0].offsetTop) - u * (.9 * l.height())
                      }
                      G(o, f.toString(), {
                          dir: c,
                          scrollEasing: "mcsEaseInOut"
                      })
                  }
              })
          },
          H = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = a + "_" + o.idx,
                  r = e("#mCSB_" + o.idx + "_container"),
                  l = r.parent();
              r.bind("focusin." + i, function() {
                  var o = e(document.activeElement),
                      a = r.find(".mCustomScrollBox").length,
                      i = 0;
                  o.is(n.advanced.autoScrollOnFocus) && (Q(t), clearTimeout(t[0]._focusTimeout), t[0]._focusTimer = a ? (i + 17) * a : 0, t[0]._focusTimeout = setTimeout(function() {
                      var e = [ae(o)[0], ae(o)[1]],
                          a = [r[0].offsetTop, r[0].offsetLeft],
                          s = [a[0] + e[0] >= 0 && a[0] + e[0] < l.height() - o.outerHeight(!1), a[1] + e[1] >= 0 && a[0] + e[1] < l.width() - o.outerWidth(!1)],
                          c = "yx" !== n.axis || s[0] || s[1] ? "all" : "none";
                      "x" === n.axis || s[0] || G(t, e[0].toString(), {
                          dir: "y",
                          scrollEasing: "mcsEaseInOut",
                          overwrite: c,
                          dur: i
                      }), "y" === n.axis || s[1] || G(t, e[1].toString(), {
                          dir: "x",
                          scrollEasing: "mcsEaseInOut",
                          overwrite: c,
                          dur: i
                      })
                  }, t[0]._focusTimer))
              })
          },
          U = function() {
              var t = e(this),
                  o = t.data(a),
                  n = a + "_" + o.idx,
                  i = e("#mCSB_" + o.idx + "_container").parent();
              i.bind("scroll." + n, function() {
                  0 === i.scrollTop() && 0 === i.scrollLeft() || e(".mCSB_" + o.idx + "_scrollbar").css("visibility", "hidden")
              })
          },
          F = function() {
              var t = e(this),
                  o = t.data(a),
                  n = o.opt,
                  i = o.sequential,
                  r = a + "_" + o.idx,
                  l = ".mCSB_" + o.idx + "_scrollbar",
                  s = e(l + ">a");
              s.bind("contextmenu." + r, function(e) {
                  e.preventDefault()
              }).bind("mousedown." + r + " touchstart." + r + " pointerdown." + r + " MSPointerDown." + r + " mouseup." + r + " touchend." + r + " pointerup." + r + " MSPointerUp." + r + " mouseout." + r + " pointerout." + r + " MSPointerOut." + r + " click." + r, function(a) {
                  function r(e, o) {
                      i.scrollAmount = n.scrollButtons.scrollAmount, j(t, e, o)
                  }
                  if (a.preventDefault(), ee(a)) {
                      var l = e(this).attr("class");
                      switch (i.type = n.scrollButtons.scrollType, a.type) {
                          case "mousedown":
                          case "touchstart":
                          case "pointerdown":
                          case "MSPointerDown":
                              if ("stepped" === i.type) return;
                              c = !0, o.tweenRunning = !1, r("on", l);
                              break;
                          case "mouseup":
                          case "touchend":
                          case "pointerup":
                          case "MSPointerUp":
                          case "mouseout":
                          case "pointerout":
                          case "MSPointerOut":
                              if ("stepped" === i.type) return;
                              c = !1, i.dir && r("off", l);
                              break;
                          case "click":
                              if ("stepped" !== i.type || o.tweenRunning) return;
                              r("on", l)
                      }
                  }
              })
          },
          q = function() {
              function t(t) {
                  function a(e, t) {
                      r.type = i.keyboard.scrollType, r.scrollAmount = i.keyboard.scrollAmount, "stepped" === r.type && n.tweenRunning || j(o, e, t)
                  }
                  switch (t.type) {
                      case "blur":
                          n.tweenRunning && r.dir && a("off", null);
                          break;
                      case "keydown":
                      case "keyup":
                          var l = t.keyCode ? t.keyCode : t.which,
                              s = "on";
                          if ("x" !== i.axis && (38 === l || 40 === l) || "y" !== i.axis && (37 === l || 39 === l)) {
                              if ((38 === l || 40 === l) && !n.overflowed[0] || (37 === l || 39 === l) && !n.overflowed[1]) return;
                              "keyup" === t.type && (s = "off"), e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), a(s, l))
                          } else if (33 === l || 34 === l) {
                              if ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type) {
                                  Q(o);
                                  var f = 34 === l ? -1 : 1;
                                  if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                                      m = Math.abs(c[0].offsetLeft) - f * (.9 * d.width());
                                  else var h = "y",
                                      m = Math.abs(c[0].offsetTop) - f * (.9 * d.height());
                                  G(o, m.toString(), {
                                      dir: h,
                                      scrollEasing: "mcsEaseInOut"
                                  })
                              }
                          } else if ((35 === l || 36 === l) && !e(document.activeElement).is(u) && ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type)) {
                              if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                                  m = 35 === l ? Math.abs(d.width() - c.outerWidth(!1)) : 0;
                              else var h = "y",
                                  m = 35 === l ? Math.abs(d.height() - c.outerHeight(!1)) : 0;
                              G(o, m.toString(), {
                                  dir: h,
                                  scrollEasing: "mcsEaseInOut"
                              })
                          }
                  }
              }
              var o = e(this),
                  n = o.data(a),
                  i = n.opt,
                  r = n.sequential,
                  l = a + "_" + n.idx,
                  s = e("#mCSB_" + n.idx),
                  c = e("#mCSB_" + n.idx + "_container"),
                  d = c.parent(),
                  u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
                  f = c.find("iframe"),
                  h = ["blur." + l + " keydown." + l + " keyup." + l];
              f.length && f.each(function() {
                  e(this).bind("load", function() {
                      A(this) && e(this.contentDocument || this.contentWindow.document).bind(h[0], function(e) {
                          t(e)
                      })
                  })
              }), s.attr("tabindex", "0").bind(h[0], function(e) {
                  t(e)
              })
          },
          j = function(t, o, n, i, r) {
              function l(e) {
                  u.snapAmount && (f.scrollAmount = u.snapAmount instanceof Array ? "x" === f.dir[0] ? u.snapAmount[1] : u.snapAmount[0] : u.snapAmount);
                  var o = "stepped" !== f.type,
                      a = r ? r : e ? o ? p / 1.5 : g : 1e3 / 60,
                      n = e ? o ? 7.5 : 40 : 2.5,
                      s = [Math.abs(h[0].offsetTop), Math.abs(h[0].offsetLeft)],
                      d = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
                      m = "x" === f.dir[0] ? s[1] + f.dir[1] * (d[1] * n) : s[0] + f.dir[1] * (d[0] * n),
                      v = "x" === f.dir[0] ? s[1] + f.dir[1] * parseInt(f.scrollAmount) : s[0] + f.dir[1] * parseInt(f.scrollAmount),
                      x = "auto" !== f.scrollAmount ? v : m,
                      _ = i ? i : e ? o ? "mcsLinearOut" : "mcsEaseInOut" : "mcsLinear",
                      w = !!e;
                  return e && 17 > a && (x = "x" === f.dir[0] ? s[1] : s[0]), G(t, x.toString(), {
                      dir: f.dir[0],
                      scrollEasing: _,
                      dur: a,
                      onComplete: w
                  }), e ? void(f.dir = !1) : (clearTimeout(f.step), void(f.step = setTimeout(function() {
                      l()
                  }, a)))
              }

              function s() {
                  clearTimeout(f.step), $(f, "step"), Q(t)
              }
              var c = t.data(a),
                  u = c.opt,
                  f = c.sequential,
                  h = e("#mCSB_" + c.idx + "_container"),
                  m = "stepped" === f.type,
                  p = u.scrollInertia < 26 ? 26 : u.scrollInertia,
                  g = u.scrollInertia < 1 ? 17 : u.scrollInertia;
              switch (o) {
                  case "on":
                      if (f.dir = [n === d[16] || n === d[15] || 39 === n || 37 === n ? "x" : "y", n === d[13] || n === d[15] || 38 === n || 37 === n ? -1 : 1], Q(t), oe(n) && "stepped" === f.type) return;
                      l(m);
                      break;
                  case "off":
                      s(), (m || c.tweenRunning && f.dir) && l(!0)
              }
          },
          Y = function(t) {
              var o = e(this).data(a).opt,
                  n = [];
              return "function" == typeof t && (t = t()), t instanceof Array ? n = t.length > 1 ? [t[0], t[1]] : "x" === o.axis ? [null, t[0]] : [t[0], null] : (n[0] = t.y ? t.y : t.x || "x" === o.axis ? null : t, n[1] = t.x ? t.x : t.y || "y" === o.axis ? null : t), "function" == typeof n[0] && (n[0] = n[0]()), "function" == typeof n[1] && (n[1] = n[1]()), n
          },
          X = function(t, o) {
              if (null != t && "undefined" != typeof t) {
                  var n = e(this),
                      i = n.data(a),
                      r = i.opt,
                      l = e("#mCSB_" + i.idx + "_container"),
                      s = l.parent(),
                      c = typeof t;
                  o || (o = "x" === r.axis ? "x" : "y");
                  var d = "x" === o ? l.outerWidth(!1) - s.width() : l.outerHeight(!1) - s.height(),
                      f = "x" === o ? l[0].offsetLeft : l[0].offsetTop,
                      h = "x" === o ? "left" : "top";
                  switch (c) {
                      case "function":
                          return t();
                      case "object":
                          var m = t.jquery ? t : e(t);
                          if (!m.length) return;
                          return "x" === o ? ae(m)[1] : ae(m)[0];
                      case "string":
                      case "number":
                          if (oe(t)) return Math.abs(t);
                          if (-1 !== t.indexOf("%")) return Math.abs(d * parseInt(t) / 100);
                          if (-1 !== t.indexOf("-=")) return Math.abs(f - parseInt(t.split("-=")[1]));
                          if (-1 !== t.indexOf("+=")) {
                              var p = f + parseInt(t.split("+=")[1]);
                              return p >= 0 ? 0 : Math.abs(p)
                          }
                          if (-1 !== t.indexOf("px") && oe(t.split("px")[0])) return Math.abs(t.split("px")[0]);
                          if ("top" === t || "left" === t) return 0;
                          if ("bottom" === t) return Math.abs(s.height() - l.outerHeight(!1));
                          if ("right" === t) return Math.abs(s.width() - l.outerWidth(!1));
                          if ("first" === t || "last" === t) {
                              var m = l.find(":" + t);
                              return "x" === o ? ae(m)[1] : ae(m)[0]
                          }
                          return e(t).length ? "x" === o ? ae(e(t))[1] : ae(e(t))[0] : (l.css(h, t), void u.update.call(null, n[0]))
                  }
              }
          },
          N = function(t) {
              function o() {
                  return clearTimeout(f[0].autoUpdate), 0 === l.parents("html").length ? void(l = null) : void(f[0].autoUpdate = setTimeout(function() {
                      return c.advanced.updateOnSelectorChange && (s.poll.change.n = i(), s.poll.change.n !== s.poll.change.o) ? (s.poll.change.o = s.poll.change.n, void r(3)) : c.advanced.updateOnContentResize && (s.poll.size.n = l[0].scrollHeight + l[0].scrollWidth + f[0].offsetHeight + l[0].offsetHeight + l[0].offsetWidth, s.poll.size.n !== s.poll.size.o) ? (s.poll.size.o = s.poll.size.n, void r(1)) : !c.advanced.updateOnImageLoad || "auto" === c.advanced.updateOnImageLoad && "y" === c.axis || (s.poll.img.n = f.find("img").length, s.poll.img.n === s.poll.img.o) ? void((c.advanced.updateOnSelectorChange || c.advanced.updateOnContentResize || c.advanced.updateOnImageLoad) && o()) : (s.poll.img.o = s.poll.img.n, void f.find("img").each(function() {
                          n(this)
                      }))
                  }, c.advanced.autoUpdateTimeout))
              }

              function n(t) {
                  function o(e, t) {
                      return function() {
                          return t.apply(e, arguments)
                      }
                  }

                  function a() {
                      this.onload = null, e(t).addClass(d[2]), r(2)
                  }
                  if (e(t).hasClass(d[2])) return void r();
                  var n = new Image;
                  n.onload = o(n, a), n.src = t.src
              }

              function i() {
                  c.advanced.updateOnSelectorChange === !0 && (c.advanced.updateOnSelectorChange = "*");
                  var e = 0,
                      t = f.find(c.advanced.updateOnSelectorChange);
                  return c.advanced.updateOnSelectorChange && t.length > 0 && t.each(function() {
                      e += this.offsetHeight + this.offsetWidth
                  }), e
              }

              function r(e) {
                  clearTimeout(f[0].autoUpdate), u.update.call(null, l[0], e)
              }
              var l = e(this),
                  s = l.data(a),
                  c = s.opt,
                  f = e("#mCSB_" + s.idx + "_container");
              return t ? (clearTimeout(f[0].autoUpdate), void $(f[0], "autoUpdate")) : void o()
          },
          V = function(e, t, o) {
              return Math.round(e / t) * t - o
          },
          Q = function(t) {
              var o = t.data(a),
                  n = e("#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper,#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal");
              n.each(function() {
                  Z.call(this)
              })
          },
          G = function(t, o, n) {
              function i(e) {
                  return s && c.callbacks[e] && "function" == typeof c.callbacks[e]
              }

              function r() {
                  return [c.callbacks.alwaysTriggerOffsets || w >= S[0] + y, c.callbacks.alwaysTriggerOffsets || -B >= w]
              }

              function l() {
                  var e = [h[0].offsetTop, h[0].offsetLeft],
                      o = [x[0].offsetTop, x[0].offsetLeft],
                      a = [h.outerHeight(!1), h.outerWidth(!1)],
                      i = [f.height(), f.width()];
                  t[0].mcs = {
                      content: h,
                      top: e[0],
                      left: e[1],
                      draggerTop: o[0],
                      draggerLeft: o[1],
                      topPct: Math.round(100 * Math.abs(e[0]) / (Math.abs(a[0]) - i[0])),
                      leftPct: Math.round(100 * Math.abs(e[1]) / (Math.abs(a[1]) - i[1])),
                      direction: n.dir
                  }
              }
              var s = t.data(a),
                  c = s.opt,
                  d = {
                      trigger: "internal",
                      dir: "y",
                      scrollEasing: "mcsEaseOut",
                      drag: !1,
                      dur: c.scrollInertia,
                      overwrite: "all",
                      callbacks: !0,
                      onStart: !0,
                      onUpdate: !0,
                      onComplete: !0
                  },
                  n = e.extend(d, n),
                  u = [n.dur, n.drag ? 0 : n.dur],
                  f = e("#mCSB_" + s.idx),
                  h = e("#mCSB_" + s.idx + "_container"),
                  m = h.parent(),
                  p = c.callbacks.onTotalScrollOffset ? Y.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
                  g = c.callbacks.onTotalScrollBackOffset ? Y.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];
              if (s.trigger = n.trigger, 0 === m.scrollTop() && 0 === m.scrollLeft() || (e(".mCSB_" + s.idx + "_scrollbar").css("visibility", "visible"), m.scrollTop(0).scrollLeft(0)), "_resetY" !== o || s.contentReset.y || (i("onOverflowYNone") && c.callbacks.onOverflowYNone.call(t[0]), s.contentReset.y = 1), "_resetX" !== o || s.contentReset.x || (i("onOverflowXNone") && c.callbacks.onOverflowXNone.call(t[0]), s.contentReset.x = 1), "_resetY" !== o && "_resetX" !== o) {
                  if (!s.contentReset.y && t[0].mcs || !s.overflowed[0] || (i("onOverflowY") && c.callbacks.onOverflowY.call(t[0]), s.contentReset.x = null), !s.contentReset.x && t[0].mcs || !s.overflowed[1] || (i("onOverflowX") && c.callbacks.onOverflowX.call(t[0]), s.contentReset.x = null), c.snapAmount) {
                      var v = c.snapAmount instanceof Array ? "x" === n.dir ? c.snapAmount[1] : c.snapAmount[0] : c.snapAmount;
                      o = V(o, v, c.snapOffset)
                  }
                  switch (n.dir) {
                      case "x":
                          var x = e("#mCSB_" + s.idx + "_dragger_horizontal"),
                              _ = "left",
                              w = h[0].offsetLeft,
                              S = [f.width() - h.outerWidth(!1), x.parent().width() - x.width()],
                              b = [o, 0 === o ? 0 : o / s.scrollRatio.x],
                              y = p[1],
                              B = g[1],
                              T = y > 0 ? y / s.scrollRatio.x : 0,
                              k = B > 0 ? B / s.scrollRatio.x : 0;
                          break;
                      case "y":
                          var x = e("#mCSB_" + s.idx + "_dragger_vertical"),
                              _ = "top",
                              w = h[0].offsetTop,
                              S = [f.height() - h.outerHeight(!1), x.parent().height() - x.height()],
                              b = [o, 0 === o ? 0 : o / s.scrollRatio.y],
                              y = p[0],
                              B = g[0],
                              T = y > 0 ? y / s.scrollRatio.y : 0,
                              k = B > 0 ? B / s.scrollRatio.y : 0
                  }
                  b[1] < 0 || 0 === b[0] && 0 === b[1] ? b = [0, 0] : b[1] >= S[1] ? b = [S[0], S[1]] : b[0] = -b[0], t[0].mcs || (l(), i("onInit") && c.callbacks.onInit.call(t[0])), clearTimeout(h[0].onCompleteTimeout), J(x[0], _, Math.round(b[1]), u[1], n.scrollEasing), !s.tweenRunning && (0 === w && b[0] >= 0 || w === S[0] && b[0] <= S[0]) || J(h[0], _, Math.round(b[0]), u[0], n.scrollEasing, n.overwrite, {
                      onStart: function() {
                          n.callbacks && n.onStart && !s.tweenRunning && (i("onScrollStart") && (l(), c.callbacks.onScrollStart.call(t[0])), s.tweenRunning = !0, C(x), s.cbOffsets = r())
                      },
                      onUpdate: function() {
                          n.callbacks && n.onUpdate && i("whileScrolling") && (l(), c.callbacks.whileScrolling.call(t[0]))
                      },
                      onComplete: function() {
                          if (n.callbacks && n.onComplete) {
                              "yx" === c.axis && clearTimeout(h[0].onCompleteTimeout);
                              var e = h[0].idleTimer || 0;
                              h[0].onCompleteTimeout = setTimeout(function() {
                                  i("onScroll") && (l(), c.callbacks.onScroll.call(t[0])), i("onTotalScroll") && b[1] >= S[1] - T && s.cbOffsets[0] && (l(), c.callbacks.onTotalScroll.call(t[0])), i("onTotalScrollBack") && b[1] <= k && s.cbOffsets[1] && (l(), c.callbacks.onTotalScrollBack.call(t[0])), s.tweenRunning = !1, h[0].idleTimer = 0, C(x, "hide")
                              }, e)
                          }
                      }
                  })
              }
          },
          J = function(e, t, o, a, n, i, r) {
              function l() {
                  S.stop || (x || m.call(), x = K() - v, s(), x >= S.time && (S.time = x > S.time ? x + f - (x - S.time) : x + f - 1, S.time < x + 1 && (S.time = x + 1)), S.time < a ? S.id = h(l) : g.call())
              }

              function s() {
                  a > 0 ? (S.currVal = u(S.time, _, b, a, n), w[t] = Math.round(S.currVal) + "px") : w[t] = o + "px", p.call()
              }

              function c() {
                  f = 1e3 / 60, S.time = x + f, h = window.requestAnimationFrame ? window.requestAnimationFrame : function(e) {
                      return s(), setTimeout(e, .01)
                  }, S.id = h(l)
              }

              function d() {
                  null != S.id && (window.requestAnimationFrame ? window.cancelAnimationFrame(S.id) : clearTimeout(S.id), S.id = null)
              }

              function u(e, t, o, a, n) {
                  switch (n) {
                      case "linear":
                      case "mcsLinear":
                          return o * e / a + t;
                      case "mcsLinearOut":
                          return e /= a, e--, o * Math.sqrt(1 - e * e) + t;
                      case "easeInOutSmooth":
                          return e /= a / 2, 1 > e ? o / 2 * e * e + t : (e--, -o / 2 * (e * (e - 2) - 1) + t);
                      case "easeInOutStrong":
                          return e /= a / 2, 1 > e ? o / 2 * Math.pow(2, 10 * (e - 1)) + t : (e--, o / 2 * (-Math.pow(2, -10 * e) + 2) + t);
                      case "easeInOut":
                      case "mcsEaseInOut":
                          return e /= a / 2, 1 > e ? o / 2 * e * e * e + t : (e -= 2, o / 2 * (e * e * e + 2) + t);
                      case "easeOutSmooth":
                          return e /= a, e--, -o * (e * e * e * e - 1) + t;
                      case "easeOutStrong":
                          return o * (-Math.pow(2, -10 * e / a) + 1) + t;
                      case "easeOut":
                      case "mcsEaseOut":
                      default:
                          var i = (e /= a) * e,
                              r = i * e;
                          return t + o * (.499999999999997 * r * i + -2.5 * i * i + 5.5 * r + -6.5 * i + 4 * e)
                  }
              }
              e._mTween || (e._mTween = {
                  top: {},
                  left: {}
              });
              var f, h, r = r || {},
                  m = r.onStart || function() {},
                  p = r.onUpdate || function() {},
                  g = r.onComplete || function() {},
                  v = K(),
                  x = 0,
                  _ = e.offsetTop,
                  w = e.style,
                  S = e._mTween[t];
              "left" === t && (_ = e.offsetLeft);
              var b = o - _;
              S.stop = 0, "none" !== i && d(), c()
          },
          K = function() {
              return window.performance && window.performance.now ? window.performance.now() : window.performance && window.performance.webkitNow ? window.performance.webkitNow() : Date.now ? Date.now() : (new Date).getTime()
          },
          Z = function() {
              var e = this;
              e._mTween || (e._mTween = {
                  top: {},
                  left: {}
              });
              for (var t = ["top", "left"], o = 0; o < t.length; o++) {
                  var a = t[o];
                  e._mTween[a].id && (window.requestAnimationFrame ? window.cancelAnimationFrame(e._mTween[a].id) : clearTimeout(e._mTween[a].id), e._mTween[a].id = null, e._mTween[a].stop = 1)
              }
          },
          $ = function(e, t) {
              try {
                  delete e[t]
              } catch (o) {
                  e[t] = null
              }
          },
          ee = function(e) {
              return !(e.which && 1 !== e.which)
          },
          te = function(e) {
              var t = e.originalEvent.pointerType;
              return !(t && "touch" !== t && 2 !== t)
          },
          oe = function(e) {
              return !isNaN(parseFloat(e)) && isFinite(e)
          },
          ae = function(e) {
              var t = e.parents(".mCSB_container");
              return [e.offset().top - t.offset().top, e.offset().left - t.offset().left]
          },
          ne = function() {
              function e() {
                  var e = ["webkit", "moz", "ms", "o"];
                  if ("hidden" in document) return "hidden";
                  for (var t = 0; t < e.length; t++)
                      if (e[t] + "Hidden" in document) return e[t] + "Hidden";
                  return null
              }
              var t = e();
              return t ? document[t] : !1
          };
      e.fn[o] = function(t) {
          return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
      }, e[o] = function(t) {
          return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
      }, e[o].defaults = i, window[o] = !0, e(window).bind("load", function() {
          e(n)[o](), e.extend(e.expr[":"], {
              mcsInView: e.expr[":"].mcsInView || function(t) {
                  var o, a, n = e(t),
                      i = n.parents(".mCSB_container");
                  if (i.length) return o = i.parent(), a = [i[0].offsetTop, i[0].offsetLeft], a[0] + ae(n)[0] >= 0 && a[0] + ae(n)[0] < o.height() - n.outerHeight(!1) && a[1] + ae(n)[1] >= 0 && a[1] + ae(n)[1] < o.width() - n.outerWidth(!1)
              },
              mcsInSight: e.expr[":"].mcsInSight || function(t, o, a) {
                  var n, i, r, l, s = e(t),
                      c = s.parents(".mCSB_container"),
                      d = "exact" === a[3] ? [
                          [1, 0],
                          [1, 0]
                      ] : [
                          [.9, .1],
                          [.6, .4]
                      ];
                  if (c.length) return n = [s.outerHeight(!1), s.outerWidth(!1)], r = [c[0].offsetTop + ae(s)[0], c[0].offsetLeft + ae(s)[1]], i = [c.parent()[0].offsetHeight, c.parent()[0].offsetWidth], l = [n[0] < i[0] ? d[0] : d[1], n[1] < i[1] ? d[0] : d[1]], r[0] - i[0] * l[0][0] < 0 && r[0] + n[0] - i[0] * l[0][1] >= 0 && r[1] - i[1] * l[1][0] < 0 && r[1] + n[1] - i[1] * l[1][1] >= 0
              },
              mcsOverflow: e.expr[":"].mcsOverflow || function(t) {
                  var o = e(t).data(a);
                  if (o) return o.overflowed[0] || o.overflowed[1]
              }
          })
      })
  })
});
(function(factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else if (typeof module === "object" && module.exports) {
      module.exports = function(root, jQuery) {
          if (jQuery === undefined) {
              if (typeof window !== "undefined") {
                  jQuery = require("jquery")
              } else {
                  jQuery = require("jquery")(root)
              }
          }
          factory(jQuery);
          return jQuery
      }
  } else {
      factory(jQuery)
  }
})(function($) {
  var JustifiedGallery = function($gallery, settings) {
      this.settings = settings;
      this.checkSettings();
      this.imgAnalyzerTimeout = null;
      this.entries = null;
      this.buildingRow = {
          entriesBuff: [],
          width: 0,
          height: 0,
          aspectRatio: 0
      };
      this.lastFetchedEntry = null;
      this.lastAnalyzedIndex = -1;
      this["yield"] = {
          every: 2,
          flushed: 0
      };
      this.border = settings.border >= 0 ? settings.border : settings.margins;
      this.maxRowHeight = this.retrieveMaxRowHeight();
      this.suffixRanges = this.retrieveSuffixRanges();
      this.offY = this.border;
      this.rows = 0;
      this.spinner = {
          phase: 0,
          timeSlot: 150,
          $el: $('<div class="jg-spinner"><span></span><span></span><span></span></div>'),
          intervalId: null
      };
      this.scrollBarOn = false;
      this.checkWidthIntervalId = null;
      this.galleryWidth = $gallery.width();
      this.$gallery = $gallery
  };
  JustifiedGallery.prototype.getSuffix = function(width, height) {
      var longestSide, i;
      longestSide = width > height ? width : height;
      for (i = 0; i < this.suffixRanges.length; i++) {
          if (longestSide <= this.suffixRanges[i]) {
              return this.settings.sizeRangeSuffixes[this.suffixRanges[i]]
          }
      }
      return this.settings.sizeRangeSuffixes[this.suffixRanges[i - 1]]
  };
  JustifiedGallery.prototype.removeSuffix = function(str, suffix) {
      return str.substring(0, str.length - suffix.length)
  };
  JustifiedGallery.prototype.endsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1
  };
  JustifiedGallery.prototype.getUsedSuffix = function(str) {
      for (var si in this.settings.sizeRangeSuffixes) {
          if (this.settings.sizeRangeSuffixes.hasOwnProperty(si)) {
              if (this.settings.sizeRangeSuffixes[si].length === 0) continue;
              if (this.endsWith(str, this.settings.sizeRangeSuffixes[si])) return this.settings.sizeRangeSuffixes[si]
          }
      }
      return ""
  };
  JustifiedGallery.prototype.newSrc = function(imageSrc, imgWidth, imgHeight, image) {
      var newImageSrc;
      if (this.settings.thumbnailPath) {
          newImageSrc = this.settings.thumbnailPath(imageSrc, imgWidth, imgHeight, image)
      } else {
          var matchRes = imageSrc.match(this.settings.extension);
          var ext = matchRes !== null ? matchRes[0] : "";
          newImageSrc = imageSrc.replace(this.settings.extension, "");
          newImageSrc = this.removeSuffix(newImageSrc, this.getUsedSuffix(newImageSrc));
          newImageSrc += this.getSuffix(imgWidth, imgHeight) + ext
      }
      return newImageSrc
  };
  JustifiedGallery.prototype.showImg = function($entry, callback) {
      if (this.settings.cssAnimation) {
          $entry.addClass("jg-entry-visible");
          if (callback) callback()
      } else {
          $entry.stop().fadeTo(this.settings.imagesAnimationDuration, 1, callback);
          $entry.find(this.settings.imgSelector).stop().fadeTo(this.settings.imagesAnimationDuration, 1, callback)
      }
  };
  JustifiedGallery.prototype.extractImgSrcFromImage = function($image) {
      var imageSrc = $image.data("safe-src");
      var imageSrcLoc = "data-safe-src";
      if (typeof imageSrc === "undefined") {
          imageSrc = $image.attr("src");
          imageSrcLoc = "src"
      }
      $image.data("jg.originalSrc", imageSrc);
      $image.data("jg.src", imageSrc);
      $image.data("jg.originalSrcLoc", imageSrcLoc);
      return imageSrc
  };
  JustifiedGallery.prototype.imgFromEntry = function($entry) {
      var $img = $entry.find(this.settings.imgSelector);
      return $img.length === 0 ? null : $img
  };
  JustifiedGallery.prototype.captionFromEntry = function($entry) {
      var $caption = $entry.find("> .jg-caption");
      return $caption.length === 0 ? null : $caption
  };
  JustifiedGallery.prototype.displayEntry = function($entry, x, y, imgWidth, imgHeight, rowHeight) {
      $entry.width(imgWidth);
      $entry.height(rowHeight);
      $entry.css("top", y);
      $entry.css("left", x);
      var $image = this.imgFromEntry($entry);
      if ($image !== null) {
          $image.css("width", imgWidth);
          $image.css("height", imgHeight);
          $image.css("margin-left", -imgWidth / 2);
          $image.css("margin-top", -imgHeight / 2);
          var imageSrc = $image.data("jg.src");
          if (imageSrc) {
              imageSrc = this.newSrc(imageSrc, imgWidth, imgHeight, $image[0]);
              $image.one("error", function() {
                  this.resetImgSrc($image)
              });
              var loadNewImage = function() {
                  $image.attr("src", imageSrc)
              };
              if ($entry.data("jg.loaded") === "skipped" && imageSrc) {
                  this.onImageEvent(imageSrc, function() {
                      this.showImg($entry, loadNewImage);
                      $entry.data("jg.loaded", true)
                  }.bind(this))
              } else {
                  this.showImg($entry, loadNewImage)
              }
          }
      } else {
          this.showImg($entry)
      }
      this.displayEntryCaption($entry)
  };
  JustifiedGallery.prototype.displayEntryCaption = function($entry) {
      var $image = this.imgFromEntry($entry);
      if ($image !== null && this.settings.captions) {
          var $imgCaption = this.captionFromEntry($entry);
          if ($imgCaption === null) {
              var caption = $image.attr("alt");
              if (!this.isValidCaption(caption)) caption = $entry.attr("title");
              if (this.isValidCaption(caption)) {
                  $imgCaption = $('<div class="jg-caption">' + caption + "</div>");
                  $entry.append($imgCaption);
                  $entry.data("jg.createdCaption", true)
              }
          }
          if ($imgCaption !== null) {
              if (!this.settings.cssAnimation) $imgCaption.stop().fadeTo(0, this.settings.captionSettings.nonVisibleOpacity);
              this.addCaptionEventsHandlers($entry)
          }
      } else {
          this.removeCaptionEventsHandlers($entry)
      }
  };
  JustifiedGallery.prototype.isValidCaption = function(caption) {
      return typeof caption !== "undefined" && caption.length > 0
  };
  JustifiedGallery.prototype.onEntryMouseEnterForCaption = function(eventObject) {
      var $caption = this.captionFromEntry($(eventObject.currentTarget));
      if (this.settings.cssAnimation) {
          $caption.addClass("jg-caption-visible").removeClass("jg-caption-hidden")
      } else {
          $caption.stop().fadeTo(this.settings.captionSettings.animationDuration, this.settings.captionSettings.visibleOpacity)
      }
  };
  JustifiedGallery.prototype.onEntryMouseLeaveForCaption = function(eventObject) {
      var $caption = this.captionFromEntry($(eventObject.currentTarget));
      if (this.settings.cssAnimation) {
          $caption.removeClass("jg-caption-visible").removeClass("jg-caption-hidden")
      } else {
          $caption.stop().fadeTo(this.settings.captionSettings.animationDuration, this.settings.captionSettings.nonVisibleOpacity)
      }
  };
  JustifiedGallery.prototype.addCaptionEventsHandlers = function($entry) {
      var captionMouseEvents = $entry.data("jg.captionMouseEvents");
      if (typeof captionMouseEvents === "undefined") {
          captionMouseEvents = {
              mouseenter: $.proxy(this.onEntryMouseEnterForCaption, this),
              mouseleave: $.proxy(this.onEntryMouseLeaveForCaption, this)
          };
          $entry.on("mouseenter", undefined, undefined, captionMouseEvents.mouseenter);
          $entry.on("mouseleave", undefined, undefined, captionMouseEvents.mouseleave);
          $entry.data("jg.captionMouseEvents", captionMouseEvents)
      }
  };
  JustifiedGallery.prototype.removeCaptionEventsHandlers = function($entry) {
      var captionMouseEvents = $entry.data("jg.captionMouseEvents");
      if (typeof captionMouseEvents !== "undefined") {
          $entry.off("mouseenter", undefined, captionMouseEvents.mouseenter);
          $entry.off("mouseleave", undefined, captionMouseEvents.mouseleave);
          $entry.removeData("jg.captionMouseEvents")
      }
  };
  JustifiedGallery.prototype.clearBuildingRow = function() {
      this.buildingRow.entriesBuff = [];
      this.buildingRow.aspectRatio = 0;
      this.buildingRow.width = 0
  };
  JustifiedGallery.prototype.prepareBuildingRow = function(isLastRow, hiddenRow) {
      var i, $entry, imgAspectRatio, newImgW, newImgH, justify = true;
      var minHeight = 0;
      var availableWidth = this.galleryWidth - 2 * this.border - (this.buildingRow.entriesBuff.length - 1) * this.settings.margins;
      var rowHeight = availableWidth / this.buildingRow.aspectRatio;
      var defaultRowHeight = this.settings.rowHeight;
      var justifiable = this.buildingRow.width / availableWidth > this.settings.justifyThreshold;
      if (hiddenRow || isLastRow && this.settings.lastRow === "hide" && !justifiable) {
          for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
              $entry = this.buildingRow.entriesBuff[i];
              if (this.settings.cssAnimation) $entry.removeClass("jg-entry-visible");
              else {
                  $entry.stop().fadeTo(0, .1);
                  $entry.find("> img, > a > img").fadeTo(0, 0)
              }
          }
          return -1
      }
      if (isLastRow && !justifiable && this.settings.lastRow !== "justify" && this.settings.lastRow !== "hide") {
          justify = false;
          if (this.rows > 0) {
              defaultRowHeight = (this.offY - this.border - this.settings.margins * this.rows) / this.rows;
              justify = defaultRowHeight * this.buildingRow.aspectRatio / availableWidth > this.settings.justifyThreshold
          }
      }
      for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
          $entry = this.buildingRow.entriesBuff[i];
          imgAspectRatio = $entry.data("jg.width") / $entry.data("jg.height");
          if (justify) {
              newImgW = i === this.buildingRow.entriesBuff.length - 1 ? availableWidth : rowHeight * imgAspectRatio;
              newImgH = rowHeight
          } else {
              newImgW = defaultRowHeight * imgAspectRatio;
              newImgH = defaultRowHeight
          }
          availableWidth -= Math.round(newImgW);
          $entry.data("jg.jwidth", Math.round(newImgW));
          $entry.data("jg.jheight", Math.ceil(newImgH));
          if (i === 0 || minHeight > newImgH) minHeight = newImgH
      }
      this.buildingRow.height = minHeight;
      return justify
  };
  JustifiedGallery.prototype.flushRow = function(isLastRow, hiddenRow) {
      var settings = this.settings;
      var $entry, buildingRowRes, offX = this.border,
          i;
      buildingRowRes = this.prepareBuildingRow(isLastRow, hiddenRow);
      if (hiddenRow || isLastRow && settings.lastRow === "hide" && buildingRowRes === -1) {
          this.clearBuildingRow();
          return
      }
      if (this.maxRowHeight) {
          if (this.maxRowHeight < this.buildingRow.height) this.buildingRow.height = this.maxRowHeight
      }
      if (isLastRow && (settings.lastRow === "center" || settings.lastRow === "right")) {
          var availableWidth = this.galleryWidth - 2 * this.border - (this.buildingRow.entriesBuff.length - 1) * settings.margins;
          for (i = 0; i < this.buildingRow.entriesBuff.length; i++) {
              $entry = this.buildingRow.entriesBuff[i];
              availableWidth -= $entry.data("jg.jwidth")
          }
          if (settings.lastRow === "center") offX += Math.round(availableWidth / 2);
          else if (settings.lastRow === "right") offX += availableWidth
      }
      var lastEntryIdx = this.buildingRow.entriesBuff.length - 1;
      for (i = 0; i <= lastEntryIdx; i++) {
          $entry = this.buildingRow.entriesBuff[this.settings.rtl ? lastEntryIdx - i : i];
          this.displayEntry($entry, offX, this.offY, $entry.data("jg.jwidth"), $entry.data("jg.jheight"), this.buildingRow.height);
          offX += $entry.data("jg.jwidth") + settings.margins
      }
      this.galleryHeightToSet = this.offY + this.buildingRow.height + this.border;
      this.setGalleryTempHeight(this.galleryHeightToSet + this.getSpinnerHeight());
      if (!isLastRow || this.buildingRow.height <= settings.rowHeight && buildingRowRes) {
          this.offY += this.buildingRow.height + settings.margins;
          this.rows += 1;
          this.clearBuildingRow();
          this.settings.triggerEvent.call(this, "jg.rowflush")
      }
  };
  var galleryPrevStaticHeight = 0;
  JustifiedGallery.prototype.rememberGalleryHeight = function() {
      galleryPrevStaticHeight = this.$gallery.height();
      this.$gallery.height(galleryPrevStaticHeight)
  };
  JustifiedGallery.prototype.setGalleryTempHeight = function(height) {
      galleryPrevStaticHeight = Math.max(height, galleryPrevStaticHeight);
      this.$gallery.height(galleryPrevStaticHeight)
  };
  JustifiedGallery.prototype.setGalleryFinalHeight = function(height) {
      galleryPrevStaticHeight = height;
      this.$gallery.height(height)
  };
  JustifiedGallery.prototype.checkWidth = function() {
      this.checkWidthIntervalId = setInterval($.proxy(function() {
          if (!this.$gallery.is(":visible")) return;
          var galleryWidth = parseFloat(this.$gallery.width());
          if (Math.abs(galleryWidth - this.galleryWidth) > this.settings.refreshSensitivity) {
              this.galleryWidth = galleryWidth;
              this.rewind();
              this.rememberGalleryHeight();
              this.startImgAnalyzer(true)
          }
      }, this), this.settings.refreshTime)
  };
  JustifiedGallery.prototype.isSpinnerActive = function() {
      return this.spinner.intervalId !== null
  };
  JustifiedGallery.prototype.getSpinnerHeight = function() {
      return this.spinner.$el.innerHeight()
  };
  JustifiedGallery.prototype.stopLoadingSpinnerAnimation = function() {
      clearInterval(this.spinner.intervalId);
      this.spinner.intervalId = null;
      this.setGalleryTempHeight(this.$gallery.height() - this.getSpinnerHeight());
      this.spinner.$el.detach()
  };
  JustifiedGallery.prototype.startLoadingSpinnerAnimation = function() {
      var spinnerContext = this.spinner;
      var $spinnerPoints = spinnerContext.$el.find("span");
      clearInterval(spinnerContext.intervalId);
      this.$gallery.append(spinnerContext.$el);
      this.setGalleryTempHeight(this.offY + this.buildingRow.height + this.getSpinnerHeight());
      spinnerContext.intervalId = setInterval(function() {
          if (spinnerContext.phase < $spinnerPoints.length) {
              $spinnerPoints.eq(spinnerContext.phase).fadeTo(spinnerContext.timeSlot, 1)
          } else {
              $spinnerPoints.eq(spinnerContext.phase - $spinnerPoints.length).fadeTo(spinnerContext.timeSlot, 0)
          }
          spinnerContext.phase = (spinnerContext.phase + 1) % ($spinnerPoints.length * 2)
      }, spinnerContext.timeSlot)
  };
  JustifiedGallery.prototype.rewind = function() {
      this.lastFetchedEntry = null;
      this.lastAnalyzedIndex = -1;
      this.offY = this.border;
      this.rows = 0;
      this.clearBuildingRow()
  };
  JustifiedGallery.prototype.getSelectorWithoutSpinner = function() {
      return this.settings.selector + ", div:not(.jg-spinner)"
  };
  JustifiedGallery.prototype.getAllEntries = function() {
      var selector = this.getSelectorWithoutSpinner();
      return this.$gallery.children(selector).toArray()
  };
  JustifiedGallery.prototype.updateEntries = function(norewind) {
      var newEntries;
      if (norewind && this.lastFetchedEntry != null) {
          var selector = this.getSelectorWithoutSpinner();
          newEntries = $(this.lastFetchedEntry).nextAll(selector).toArray()
      } else {
          this.entries = [];
          newEntries = this.getAllEntries()
      }
      if (newEntries.length > 0) {
          if ($.isFunction(this.settings.sort)) {
              newEntries = this.sortArray(newEntries)
          } else if (this.settings.randomize) {
              newEntries = this.shuffleArray(newEntries)
          }
          this.lastFetchedEntry = newEntries[newEntries.length - 1];
          if (this.settings.filter) {
              newEntries = this.filterArray(newEntries)
          } else {
              this.resetFilters(newEntries)
          }
      }
      this.entries = this.entries.concat(newEntries);
      return true
  };
  JustifiedGallery.prototype.insertToGallery = function(entries) {
      var that = this;
      $.each(entries, function() {
          $(this).appendTo(that.$gallery)
      })
  };
  JustifiedGallery.prototype.shuffleArray = function(a) {
      var i, j, temp;
      for (i = a.length - 1; i > 0; i--) {
          j = Math.floor(Math.random() * (i + 1));
          temp = a[i];
          a[i] = a[j];
          a[j] = temp
      }
      this.insertToGallery(a);
      return a
  };
  JustifiedGallery.prototype.sortArray = function(a) {
      a.sort(this.settings.sort);
      this.insertToGallery(a);
      return a
  };
  JustifiedGallery.prototype.resetFilters = function(a) {
      for (var i = 0; i < a.length; i++) $(a[i]).removeClass("jg-filtered")
  };
  JustifiedGallery.prototype.filterArray = function(a) {
      var settings = this.settings;
      if ($.type(settings.filter) === "string") {
          return a.filter(function(el) {
              var $el = $(el);
              if ($el.is(settings.filter)) {
                  $el.removeClass("jg-filtered");
                  return true
              } else {
                  $el.addClass("jg-filtered").removeClass("jg-visible");
                  return false
              }
          })
      } else if ($.isFunction(settings.filter)) {
          var filteredArr = a.filter(settings.filter);
          for (var i = 0; i < a.length; i++) {
              if (filteredArr.indexOf(a[i]) === -1) {
                  $(a[i]).addClass("jg-filtered").removeClass("jg-visible")
              } else {
                  $(a[i]).removeClass("jg-filtered")
              }
          }
          return filteredArr
      }
  };
  JustifiedGallery.prototype.resetImgSrc = function($img) {
      if ($img.data("jg.originalSrcLoc") === "src") {
          $img.attr("src", $img.data("jg.originalSrc"))
      } else {
          $img.attr("src", "")
      }
  };
  JustifiedGallery.prototype.destroy = function() {
      clearInterval(this.checkWidthIntervalId);
      this.stopImgAnalyzerStarter();
      $.each(this.getAllEntries(), $.proxy(function(_, entry) {
          var $entry = $(entry);
          $entry.css("width", "");
          $entry.css("height", "");
          $entry.css("top", "");
          $entry.css("left", "");
          $entry.data("jg.loaded", undefined);
          $entry.removeClass("jg-entry jg-filtered jg-entry-visible");
          var $img = this.imgFromEntry($entry);
          if ($img) {
              $img.css("width", "");
              $img.css("height", "");
              $img.css("margin-left", "");
              $img.css("margin-top", "");
              this.resetImgSrc($img);
              $img.data("jg.originalSrc", undefined);
              $img.data("jg.originalSrcLoc", undefined);
              $img.data("jg.src", undefined)
          }
          this.removeCaptionEventsHandlers($entry);
          var $caption = this.captionFromEntry($entry);
          if ($entry.data("jg.createdCaption")) {
              $entry.data("jg.createdCaption", undefined);
              if ($caption !== null) $caption.remove()
          } else {
              if ($caption !== null) $caption.fadeTo(0, 1)
          }
      }, this));
      this.$gallery.css("height", "");
      this.$gallery.removeClass("justified-gallery");
      this.$gallery.data("jg.controller", undefined);
      this.settings.triggerEvent.call(this, "jg.destroy")
  };
  JustifiedGallery.prototype.analyzeImages = function(isForResize) {
      for (var i = this.lastAnalyzedIndex + 1; i < this.entries.length; i++) {
          var $entry = $(this.entries[i]);
          if ($entry.data("jg.loaded") === true || $entry.data("jg.loaded") === "skipped") {
              var availableWidth = this.galleryWidth - 2 * this.border - (this.buildingRow.entriesBuff.length - 1) * this.settings.margins;
              var imgAspectRatio = $entry.data("jg.width") / $entry.data("jg.height");
              this.buildingRow.entriesBuff.push($entry);
              this.buildingRow.aspectRatio += imgAspectRatio;
              this.buildingRow.width += imgAspectRatio * this.settings.rowHeight;
              this.lastAnalyzedIndex = i;
              if (availableWidth / (this.buildingRow.aspectRatio + imgAspectRatio) < this.settings.rowHeight) {
                  this.flushRow(false, this.settings.maxRowsCount > 0 && this.rows === this.settings.maxRowsCount);
                  if (++this["yield"].flushed >= this["yield"].every) {
                      this.startImgAnalyzer(isForResize);
                      return
                  }
              }
          } else if ($entry.data("jg.loaded") !== "error") {
              return
          }
      }
      if (this.buildingRow.entriesBuff.length > 0) {
          this.flushRow(true, this.settings.maxRowsCount > 0 && this.rows === this.settings.maxRowsCount)
      }
      if (this.isSpinnerActive()) {
          this.stopLoadingSpinnerAnimation()
      }
      this.stopImgAnalyzerStarter();
      this.setGalleryFinalHeight(this.galleryHeightToSet);
      this.settings.triggerEvent.call(this, isForResize ? "jg.resize" : "jg.complete")
  };
  JustifiedGallery.prototype.stopImgAnalyzerStarter = function() {
      this["yield"].flushed = 0;
      if (this.imgAnalyzerTimeout !== null) {
          clearTimeout(this.imgAnalyzerTimeout);
          this.imgAnalyzerTimeout = null
      }
  };
  JustifiedGallery.prototype.startImgAnalyzer = function(isForResize) {
      var that = this;
      this.stopImgAnalyzerStarter();
      this.imgAnalyzerTimeout = setTimeout(function() {
          that.analyzeImages(isForResize)
      }, .001)
  };
  JustifiedGallery.prototype.onImageEvent = function(imageSrc, onLoad, onError) {
      if (!onLoad && !onError) return;
      var memImage = new Image;
      var $memImage = $(memImage);
      if (onLoad) {
          $memImage.one("load", function() {
              $memImage.off("load error");
              onLoad(memImage)
          })
      }
      if (onError) {
          $memImage.one("error", function() {
              $memImage.off("load error");
              onError(memImage)
          })
      }
      memImage.src = imageSrc
  };
  JustifiedGallery.prototype.init = function() {
      var imagesToLoad = false,
          skippedImages = false,
          that = this;
      $.each(this.entries, function(index, entry) {
          var $entry = $(entry);
          var $image = that.imgFromEntry($entry);
          $entry.addClass("jg-entry");
          if ($entry.data("jg.loaded") !== true && $entry.data("jg.loaded") !== "skipped") {
              if (that.settings.rel !== null) $entry.attr("rel", that.settings.rel);
              if (that.settings.target !== null) $entry.attr("target", that.settings.target);
              if ($image !== null) {
                  var imageSrc = that.extractImgSrcFromImage($image);
                  if (that.settings.waitThumbnailsLoad === false || !imageSrc) {
                      var width = parseFloat($image.attr("width"));
                      var height = parseFloat($image.attr("height"));
                      if ($image.prop("tagName") === "svg") {
                          width = parseFloat($image[0].getBBox().width);
                          height = parseFloat($image[0].getBBox().height)
                      }
                      if (!isNaN(width) && !isNaN(height)) {
                          $entry.data("jg.width", width);
                          $entry.data("jg.height", height);
                          $entry.data("jg.loaded", "skipped");
                          skippedImages = true;
                          that.startImgAnalyzer(false);
                          return true
                      }
                  }
                  $entry.data("jg.loaded", false);
                  imagesToLoad = true;
                  if (!that.isSpinnerActive()) that.startLoadingSpinnerAnimation();
                  that.onImageEvent(imageSrc, function(loadImg) {
                      $entry.data("jg.width", loadImg.width);
                      $entry.data("jg.height", loadImg.height);
                      $entry.data("jg.loaded", true);
                      that.startImgAnalyzer(false)
                  }, function() {
                      $entry.data("jg.loaded", "error");
                      that.startImgAnalyzer(false)
                  })
              } else {
                  $entry.data("jg.loaded", true);
                  $entry.data("jg.width", $entry.width() | parseFloat($entry.css("width")) | 1);
                  $entry.data("jg.height", $entry.height() | parseFloat($entry.css("height")) | 1)
              }
          }
      });
      if (!imagesToLoad && !skippedImages) this.startImgAnalyzer(false);
      this.checkWidth()
  };
  JustifiedGallery.prototype.checkOrConvertNumber = function(settingContainer, settingName) {
      if ($.type(settingContainer[settingName]) === "string") {
          settingContainer[settingName] = parseFloat(settingContainer[settingName])
      }
      if ($.type(settingContainer[settingName]) === "number") {
          if (isNaN(settingContainer[settingName])) throw "invalid number for " + settingName
      } else {
          throw settingName + " must be a number"
      }
  };
  JustifiedGallery.prototype.checkSizeRangesSuffixes = function() {
      if ($.type(this.settings.sizeRangeSuffixes) !== "object") {
          throw "sizeRangeSuffixes must be defined and must be an object"
      }
      var suffixRanges = [];
      for (var rangeIdx in this.settings.sizeRangeSuffixes) {
          if (this.settings.sizeRangeSuffixes.hasOwnProperty(rangeIdx)) suffixRanges.push(rangeIdx)
      }
      var newSizeRngSuffixes = {
          0: ""
      };
      for (var i = 0; i < suffixRanges.length; i++) {
          if ($.type(suffixRanges[i]) === "string") {
              try {
                  var numIdx = parseInt(suffixRanges[i].replace(/^[a-z]+/, ""), 10);
                  newSizeRngSuffixes[numIdx] = this.settings.sizeRangeSuffixes[suffixRanges[i]]
              } catch (e) {
                  throw "sizeRangeSuffixes keys must contains correct numbers (" + e + ")"
              }
          } else {
              newSizeRngSuffixes[suffixRanges[i]] = this.settings.sizeRangeSuffixes[suffixRanges[i]]
          }
      }
      this.settings.sizeRangeSuffixes = newSizeRngSuffixes
  };
  JustifiedGallery.prototype.retrieveMaxRowHeight = function() {
      var newMaxRowHeight = null;
      var rowHeight = this.settings.rowHeight;
      if ($.type(this.settings.maxRowHeight) === "string") {
          if (this.settings.maxRowHeight.match(/^[0-9]+%$/)) {
              newMaxRowHeight = rowHeight * parseFloat(this.settings.maxRowHeight.match(/^([0-9]+)%$/)[1]) / 100
          } else {
              newMaxRowHeight = parseFloat(this.settings.maxRowHeight)
          }
      } else if ($.type(this.settings.maxRowHeight) === "number") {
          newMaxRowHeight = this.settings.maxRowHeight
      } else if (this.settings.maxRowHeight === false || this.settings.maxRowHeight == null) {
          return null
      } else {
          throw "maxRowHeight must be a number or a percentage"
      }
      if (isNaN(newMaxRowHeight)) throw "invalid number for maxRowHeight";
      if (newMaxRowHeight < rowHeight) newMaxRowHeight = rowHeight;
      return newMaxRowHeight
  };
  JustifiedGallery.prototype.checkSettings = function() {
      this.checkSizeRangesSuffixes();
      this.checkOrConvertNumber(this.settings, "rowHeight");
      this.checkOrConvertNumber(this.settings, "margins");
      this.checkOrConvertNumber(this.settings, "border");
      this.checkOrConvertNumber(this.settings, "maxRowsCount");
      var lastRowModes = ["justify", "nojustify", "left", "center", "right", "hide"];
      if (lastRowModes.indexOf(this.settings.lastRow) === -1) {
          throw "lastRow must be one of: " + lastRowModes.join(", ")
      }
      this.checkOrConvertNumber(this.settings, "justifyThreshold");
      if (this.settings.justifyThreshold < 0 || this.settings.justifyThreshold > 1) {
          throw "justifyThreshold must be in the interval [0,1]"
      }
      if ($.type(this.settings.cssAnimation) !== "boolean") {
          throw "cssAnimation must be a boolean"
      }
      if ($.type(this.settings.captions) !== "boolean") throw "captions must be a boolean";
      this.checkOrConvertNumber(this.settings.captionSettings, "animationDuration");
      this.checkOrConvertNumber(this.settings.captionSettings, "visibleOpacity");
      if (this.settings.captionSettings.visibleOpacity < 0 || this.settings.captionSettings.visibleOpacity > 1) {
          throw "captionSettings.visibleOpacity must be in the interval [0, 1]"
      }
      this.checkOrConvertNumber(this.settings.captionSettings, "nonVisibleOpacity");
      if (this.settings.captionSettings.nonVisibleOpacity < 0 || this.settings.captionSettings.nonVisibleOpacity > 1) {
          throw "captionSettings.nonVisibleOpacity must be in the interval [0, 1]"
      }
      this.checkOrConvertNumber(this.settings, "imagesAnimationDuration");
      this.checkOrConvertNumber(this.settings, "refreshTime");
      this.checkOrConvertNumber(this.settings, "refreshSensitivity");
      if ($.type(this.settings.randomize) !== "boolean") throw "randomize must be a boolean";
      if ($.type(this.settings.selector) !== "string") throw "selector must be a string";
      if (this.settings.sort !== false && !$.isFunction(this.settings.sort)) {
          throw "sort must be false or a comparison function"
      }
      if (this.settings.filter !== false && !$.isFunction(this.settings.filter) && $.type(this.settings.filter) !== "string") {
          throw "filter must be false, a string or a filter function"
      }
  };
  JustifiedGallery.prototype.retrieveSuffixRanges = function() {
      var suffixRanges = [];
      for (var rangeIdx in this.settings.sizeRangeSuffixes) {
          if (this.settings.sizeRangeSuffixes.hasOwnProperty(rangeIdx)) suffixRanges.push(parseInt(rangeIdx, 10))
      }
      suffixRanges.sort(function(a, b) {
          return a > b ? 1 : a < b ? -1 : 0
      });
      return suffixRanges
  };
  JustifiedGallery.prototype.updateSettings = function(newSettings) {
      this.settings = $.extend({}, this.settings, newSettings);
      this.checkSettings();
      this.border = this.settings.border >= 0 ? this.settings.border : this.settings.margins;
      this.maxRowHeight = this.retrieveMaxRowHeight();
      this.suffixRanges = this.retrieveSuffixRanges()
  };
  JustifiedGallery.prototype.defaults = {
      sizeRangeSuffixes: {},
      thumbnailPath: undefined,
      rowHeight: 120,
      maxRowHeight: false,
      maxRowsCount: 0,
      margins: 1,
      border: -1,
      lastRow: "nojustify",
      justifyThreshold: .9,
      waitThumbnailsLoad: true,
      captions: true,
      cssAnimation: true,
      imagesAnimationDuration: 500,
      captionSettings: {
          animationDuration: 500,
          visibleOpacity: .7,
          nonVisibleOpacity: 0
      },
      rel: null,
      target: null,
      extension: /\.[^.\\/]+$/,
      refreshTime: 200,
      refreshSensitivity: 0,
      randomize: false,
      rtl: false,
      sort: false,
      filter: false,
      selector: "a",
      imgSelector: "> img, > a > img, > svg, > a > svg",
      triggerEvent: function(event) {
          this.$gallery.trigger(event)
      }
  };
  $.fn.justifiedGallery = function(arg) {
      return this.each(function(index, gallery) {
          var $gallery = $(gallery);
          $gallery.addClass("justified-gallery");
          var controller = $gallery.data("jg.controller");
          if (typeof controller === "undefined") {
              if (typeof arg !== "undefined" && arg !== null && $.type(arg) !== "object") {
                  if (arg === "destroy") return;
                  throw "The argument must be an object"
              }
              controller = new JustifiedGallery($gallery, $.extend({}, JustifiedGallery.prototype.defaults, arg));
              $gallery.data("jg.controller", controller)
          } else if (arg === "norewind") {} else if (arg === "destroy") {
              controller.destroy();
              return
          } else {
              controller.updateSettings(arg);
              controller.rewind()
          }
          if (!controller.updateEntries(arg === "norewind")) return;
          controller.init()
      })
  }
});
const Retro = [{
  elementType: "geometry",
  stylers: [{
      color: "#ebe3cd"
  }]
}, {
  elementType: "labels.text.fill",
  stylers: [{
      color: "#523735"
  }]
}, {
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#f5f1e6"
  }]
}, {
  featureType: "administrative",
  elementType: "geometry",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "administrative",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#c9b2a6"
  }]
}, {
  featureType: "administrative.land_parcel",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#dcd2be"
  }]
}, {
  featureType: "administrative.land_parcel",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#ae9e90"
  }]
}, {
  featureType: "landscape.natural",
  elementType: "geometry",
  stylers: [{
      color: "#dfd2ae"
  }]
}, {
  featureType: "poi",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "poi",
  elementType: "geometry",
  stylers: [{
      color: "#dfd2ae"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#93817c"
  }]
}, {
  featureType: "poi.park",
  elementType: "geometry.fill",
  stylers: [{
      color: "#a5b076"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#447530"
  }]
}, {
  featureType: "road",
  elementType: "geometry",
  stylers: [{
      color: "#f5f1e6"
  }]
}, {
  featureType: "road",
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "road.arterial",
  elementType: "geometry",
  stylers: [{
      color: "#fdfcf8"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry",
  stylers: [{
      color: "#f8c967"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#e9bc62"
  }]
}, {
  featureType: "road.highway.controlled_access",
  elementType: "geometry",
  stylers: [{
      color: "#e98d58"
  }]
}, {
  featureType: "road.highway.controlled_access",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#db8555"
  }]
}, {
  featureType: "road.local",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#806b63"
  }]
}, {
  featureType: "transit",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "transit.line",
  elementType: "geometry",
  stylers: [{
      color: "#dfd2ae"
  }]
}, {
  featureType: "transit.line",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#8f7d77"
  }]
}, {
  featureType: "transit.line",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#ebe3cd"
  }]
}, {
  featureType: "transit.station",
  elementType: "geometry",
  stylers: [{
      color: "#dfd2ae"
  }]
}, {
  featureType: "water",
  elementType: "geometry.fill",
  stylers: [{
      color: "#b9d3c2"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#92998d"
  }]
}];
const Standard = [];
const Silver = [{
  elementType: "geometry",
  stylers: [{
      color: "#f5f5f5"
  }]
}, {
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  elementType: "labels.text.fill",
  stylers: [{
      color: "#616161"
  }]
}, {
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#f5f5f5"
  }]
}, {
  featureType: "administrative.land_parcel",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#bdbdbd"
  }]
}, {
  featureType: "poi",
  elementType: "geometry",
  stylers: [{
      color: "#eeeeee"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#757575"
  }]
}, {
  featureType: "poi.park",
  elementType: "geometry",
  stylers: [{
      color: "#e5e5e5"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#9e9e9e"
  }]
}, {
  featureType: "road",
  elementType: "geometry",
  stylers: [{
      color: "#ffffff"
  }]
}, {
  featureType: "road.arterial",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#757575"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry",
  stylers: [{
      color: "#dadada"
  }]
}, {
  featureType: "road.highway",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#616161"
  }]
}, {
  featureType: "road.local",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#9e9e9e"
  }]
}, {
  featureType: "transit.line",
  elementType: "geometry",
  stylers: [{
      color: "#e5e5e5"
  }]
}, {
  featureType: "transit.station",
  elementType: "geometry",
  stylers: [{
      color: "#eeeeee"
  }]
}, {
  featureType: "water",
  elementType: "geometry",
  stylers: [{
      color: "#c9c9c9"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#9e9e9e"
  }]
}];
const Dark = [{
  elementType: "geometry",
  stylers: [{
      color: "#212121"
  }]
}, {
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  elementType: "labels.text.fill",
  stylers: [{
      color: "#757575"
  }]
}, {
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#212121"
  }]
}, {
  featureType: "administrative",
  elementType: "geometry",
  stylers: [{
      color: "#757575"
  }, {
      visibility: "off"
  }]
}, {
  featureType: "administrative.country",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#9e9e9e"
  }]
}, {
  featureType: "administrative.land_parcel",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "administrative.locality",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#bdbdbd"
  }]
}, {
  featureType: "poi",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#757575"
  }]
}, {
  featureType: "poi.park",
  elementType: "geometry",
  stylers: [{
      color: "#181818"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#616161"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#1b1b1b"
  }]
}, {
  featureType: "road",
  elementType: "geometry.fill",
  stylers: [{
      color: "#2c2c2c"
  }]
}, {
  featureType: "road",
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "road",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#8a8a8a"
  }]
}, {
  featureType: "road.arterial",
  elementType: "geometry",
  stylers: [{
      color: "#373737"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry",
  stylers: [{
      color: "#3c3c3c"
  }]
}, {
  featureType: "road.highway.controlled_access",
  elementType: "geometry",
  stylers: [{
      color: "#4e4e4e"
  }]
}, {
  featureType: "road.local",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#616161"
  }]
}, {
  featureType: "transit",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "transit",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#757575"
  }]
}, {
  featureType: "water",
  elementType: "geometry",
  stylers: [{
      color: "#000000"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#3d3d3d"
  }]
}];
const Night = [{
  elementType: "geometry",
  stylers: [{
      color: "#242f3e"
  }]
}, {
  elementType: "labels.text.fill",
  stylers: [{
      color: "#746855"
  }]
}, {
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#242f3e"
  }]
}, {
  featureType: "administrative",
  elementType: "geometry",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "administrative.locality",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#d59563"
  }]
}, {
  featureType: "poi",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#d59563"
  }]
}, {
  featureType: "poi.park",
  elementType: "geometry",
  stylers: [{
      color: "#263c3f"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#6b9a76"
  }]
}, {
  featureType: "road",
  elementType: "geometry",
  stylers: [{
      color: "#38414e"
  }]
}, {
  featureType: "road",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#212a37"
  }]
}, {
  featureType: "road",
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "road",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#9ca5b3"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry",
  stylers: [{
      color: "#746855"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#1f2835"
  }]
}, {
  featureType: "road.highway",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#f3d19c"
  }]
}, {
  featureType: "transit",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "transit",
  elementType: "geometry",
  stylers: [{
      color: "#2f3948"
  }]
}, {
  featureType: "transit.station",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#d59563"
  }]
}, {
  featureType: "water",
  elementType: "geometry",
  stylers: [{
      color: "#17263c"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#515c6d"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#17263c"
  }]
}];
const Aubergine = [{
  elementType: "geometry",
  stylers: [{
      color: "#1d2c4d"
  }]
}, {
  elementType: "labels.text.fill",
  stylers: [{
      color: "#8ec3b9"
  }]
}, {
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#1a3646"
  }]
}, {
  featureType: "administrative",
  elementType: "geometry",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "administrative.country",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#4b6878"
  }]
}, {
  featureType: "administrative.land_parcel",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#64779e"
  }]
}, {
  featureType: "administrative.province",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#4b6878"
  }]
}, {
  featureType: "landscape.man_made",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#334e87"
  }]
}, {
  featureType: "landscape.natural",
  elementType: "geometry",
  stylers: [{
      color: "#023e58"
  }]
}, {
  featureType: "poi",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "poi",
  elementType: "geometry",
  stylers: [{
      color: "#283d6a"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#6f9ba5"
  }]
}, {
  featureType: "poi",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#1d2c4d"
  }]
}, {
  featureType: "poi.park",
  elementType: "geometry.fill",
  stylers: [{
      color: "#023e58"
  }]
}, {
  featureType: "poi.park",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#3C7680"
  }]
}, {
  featureType: "road",
  elementType: "geometry",
  stylers: [{
      color: "#304a7d"
  }]
}, {
  featureType: "road",
  elementType: "labels.icon",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "road",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#98a5be"
  }]
}, {
  featureType: "road",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#1d2c4d"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry",
  stylers: [{
      color: "#2c6675"
  }]
}, {
  featureType: "road.highway",
  elementType: "geometry.stroke",
  stylers: [{
      color: "#255763"
  }]
}, {
  featureType: "road.highway",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#b0d5ce"
  }]
}, {
  featureType: "road.highway",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#023e58"
  }]
}, {
  featureType: "transit",
  stylers: [{
      visibility: "off"
  }]
}, {
  featureType: "transit",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#98a5be"
  }]
}, {
  featureType: "transit",
  elementType: "labels.text.stroke",
  stylers: [{
      color: "#1d2c4d"
  }]
}, {
  featureType: "transit.line",
  elementType: "geometry.fill",
  stylers: [{
      color: "#283d6a"
  }]
}, {
  featureType: "transit.station",
  elementType: "geometry",
  stylers: [{
      color: "#3a4762"
  }]
}, {
  featureType: "water",
  elementType: "geometry",
  stylers: [{
      color: "#0e1626"
  }]
}, {
  featureType: "water",
  elementType: "labels.text.fill",
  stylers: [{
      color: "#4e6d70"
  }]
}];
! function(n) {
  var t = n(window),
      o = t.height();
  t.resize(function() {
      o = t.height()
  }), n.fn.parallax = function(i, e, l) {
      var r, u = n(this);

      function c() {
          var l = t.scrollTop();
          u.each(function() {
              var t = n(this),
                  c = t.offset().top;
              c + r(t) < l || c > l + o || (n(window).width() > 1050 ? u.css("backgroundPosition", i + " " + (c - l) * e + "px") : u.css("backgroundPosition", ""))
          })
      }
      u.each(function(n) {
          u.offset().top
      }), (arguments.length < 1 || null === i) && (i = "50%"), (arguments.length < 2 || null === e) && (e = .5), (arguments.length < 3 || null === l) && (l = !0), (arguments.length < 4 || null === pos) && (pos = 0), r = l ? function(n) {
          return n.outerHeight(!0)
      } : function(n) {
          return n.height()
      }, t.bind("scroll", c).resize(c), c()
  }, n.fn.parallaxImg = function(i, e) {
      var l, r = n(this);

      function u() {
          var e = t.scrollTop();
          r.each(function() {
              var t = n(this),
                  u = t.offset().top;
              u + l(t) < e || u > e + o || (n(window).width() > 1050 ? r.css("bottom", i / 10 * -(u - e) + "px") : r.css("bottom", ""))
          })
      }(arguments.length < 1 || null === i) && (i = 1), (arguments.length < 2 || null === e) && (e = !0), l = e ? function(n) {
          return n.outerHeight(!0)
      } : function(n) {
          return n.height()
      }, t.bind("scroll", u).resize(u), u()
  }
}(jQuery);
! function(n) {
  var t = n(window),
      o = t.height();
  t.resize(function() {
      o = t.height()
  }), n.fn.parallaxLiquidImg = function(i, scale, scaleFraction, reverse, e) {
      var l, r = n(this);
      var canScale = scale ? 1 : 0;
      var scale = scale ? scale : 1.2;
      var scaleFraction = scaleFraction ? scaleFraction : .001;
      var lastScrollPos = 0;
      var scrollDir = "";

      function u() {
          var e = t.scrollTop();
          r.each(function() {
              var t = n(this),
                  u = t.offset().top,
                  tHeight = t.outerHeight(),
                  uOffesetBottom = u + tHeight;
              if (e > lastScrollPos) {
                  scrollDir = "forward"
              } else {
                  scrollDir = "reverse"
              }
              lastScrollPos = e;
              if (u < n(window).height() + e && uOffesetBottom > e) {
                  if (scrollDir == "forward") {
                      scale = scale + scaleFraction
                  } else {
                      scale = scale - scaleFraction
                  }
              }
              if (reverse) {
                  if (t.attr("data-parallax-scale")) {
                      u + l(t) < e || u > e + o || (n(window).width() > 1050 ? anime({
                          targets: r[0],
                          translateY: i / 6 * (u - e) + "px",
                          scale: canScale ? scale : 1
                      }) : r.css("transform", "translateY(0px)"))
                  } else {
                      u + l(t) < e || u > e + o || (n(window).width() > 1050 ? anime({
                          targets: r[0],
                          translateY: i / 20 * -(u - e) + "px",
                          scale: canScale ? scale : 1
                      }) : r.css("transform", "translateY(0px)"))
                  }
              } else {
                  if (t.attr("data-parallax-scale")) {
                      u + l(t) < e || u > e + o || (n(window).width() > 1050 ? anime({
                          targets: r[0],
                          translateY: i / 6 * -(u - e) + "px",
                          scale: canScale ? scale : 1
                      }) : r.css("transform", "translateY(0px)"))
                  } else {
                      u + l(t) < e || u > e + o || (n(window).width() > 1050 ? anime({
                          targets: r[0],
                          translateY: i / 20 * (u - e) + "px",
                          scale: canScale ? scale : 1
                      }) : r.css("transform", "translateY(0px)"))
                  }
              }
          })
      }(arguments.length < 1 || null === i) && (i = 1), (arguments.length < 2 || null === e) && (e = !0), l = e ? function(n) {
          return n.outerHeight(!0)
      } : function(n) {
          return n.height()
      }, t.bind("scroll", u).resize(u), u()
  }
}(jQuery);
var pJS = function(tag_id, params) {
  var canvas_el = document.querySelector("#" + tag_id + " > .particles-js-canvas-el");
  this.pJS = {
      canvas: {
          el: canvas_el,
          w: canvas_el.offsetWidth,
          h: canvas_el.offsetHeight
      },
      particles: {
          number: {
              value: 400,
              density: {
                  enable: true,
                  value_area: 800
              }
          },
          color: {
              value: "#fff"
          },
          shape: {
              type: "circle",
              stroke: {
                  width: 0,
                  color: "#ff0000"
              },
              polygon: {
                  nb_sides: 5
              },
              image: {
                  src: "",
                  width: 100,
                  height: 100
              }
          },
          opacity: {
              value: 1,
              random: false,
              anim: {
                  enable: false,
                  speed: 2,
                  opacity_min: 0,
                  sync: false
              }
          },
          size: {
              value: 20,
              random: false,
              anim: {
                  enable: false,
                  speed: 20,
                  size_min: 0,
                  sync: false
              }
          },
          line_linked: {
              enable: true,
              distance: 100,
              color: "#fff",
              opacity: 1,
              width: 1
          },
          move: {
              enable: true,
              speed: 2,
              direction: "none",
              random: false,
              straight: false,
              out_mode: "out",
              bounce: false,
              attract: {
                  enable: false,
                  rotateX: 3e3,
                  rotateY: 3e3
              }
          },
          array: []
      },
      interactivity: {
          detect_on: "canvas",
          events: {
              onhover: {
                  enable: true,
                  mode: "grab"
              },
              onclick: {
                  enable: true,
                  mode: "push"
              },
              resize: true
          },
          modes: {
              grab: {
                  distance: 100,
                  line_linked: {
                      opacity: 1
                  }
              },
              bubble: {
                  distance: 200,
                  size: 80,
                  duration: .4
              },
              repulse: {
                  distance: 200,
                  duration: .4
              },
              push: {
                  particles_nb: 4
              },
              remove: {
                  particles_nb: 2
              }
          },
          mouse: {}
      },
      retina_detect: false,
      fn: {
          interact: {},
          modes: {},
          vendors: {}
      },
      tmp: {}
  };
  var pJS = this.pJS;
  if (params) {
      Object.deepExtend(pJS, params)
  }
  pJS.tmp.obj = {
      size_value: pJS.particles.size.value,
      size_anim_speed: pJS.particles.size.anim.speed,
      move_speed: pJS.particles.move.speed,
      line_linked_distance: pJS.particles.line_linked.distance,
      line_linked_width: pJS.particles.line_linked.width,
      mode_grab_distance: pJS.interactivity.modes.grab.distance,
      mode_bubble_distance: pJS.interactivity.modes.bubble.distance,
      mode_bubble_size: pJS.interactivity.modes.bubble.size,
      mode_repulse_distance: pJS.interactivity.modes.repulse.distance
  };
  pJS.fn.retinaInit = function() {
      if (pJS.retina_detect && window.devicePixelRatio > 1) {
          pJS.canvas.pxratio = window.devicePixelRatio;
          pJS.tmp.retina = true
      } else {
          pJS.canvas.pxratio = 1;
          pJS.tmp.retina = false
      }
      pJS.canvas.w = pJS.canvas.el.offsetWidth * pJS.canvas.pxratio;
      pJS.canvas.h = pJS.canvas.el.offsetHeight * pJS.canvas.pxratio;
      pJS.particles.size.value = pJS.tmp.obj.size_value * pJS.canvas.pxratio;
      pJS.particles.size.anim.speed = pJS.tmp.obj.size_anim_speed * pJS.canvas.pxratio;
      pJS.particles.move.speed = pJS.tmp.obj.move_speed * pJS.canvas.pxratio;
      pJS.particles.line_linked.distance = pJS.tmp.obj.line_linked_distance * pJS.canvas.pxratio;
      pJS.interactivity.modes.grab.distance = pJS.tmp.obj.mode_grab_distance * pJS.canvas.pxratio;
      pJS.interactivity.modes.bubble.distance = pJS.tmp.obj.mode_bubble_distance * pJS.canvas.pxratio;
      pJS.particles.line_linked.width = pJS.tmp.obj.line_linked_width * pJS.canvas.pxratio;
      pJS.interactivity.modes.bubble.size = pJS.tmp.obj.mode_bubble_size * pJS.canvas.pxratio;
      pJS.interactivity.modes.repulse.distance = pJS.tmp.obj.mode_repulse_distance * pJS.canvas.pxratio
  };
  pJS.fn.canvasInit = function() {
      pJS.canvas.ctx = pJS.canvas.el.getContext("2d")
  };
  pJS.fn.canvasSize = function() {
      pJS.canvas.el.width = pJS.canvas.w;
      pJS.canvas.el.height = pJS.canvas.h;
      if (pJS && pJS.interactivity.events.resize) {
          window.addEventListener("resize", function() {
              pJS.canvas.w = pJS.canvas.el.offsetWidth;
              pJS.canvas.h = pJS.canvas.el.offsetHeight;
              if (pJS.tmp.retina) {
                  pJS.canvas.w *= pJS.canvas.pxratio;
                  pJS.canvas.h *= pJS.canvas.pxratio
              }
              pJS.canvas.el.width = pJS.canvas.w;
              pJS.canvas.el.height = pJS.canvas.h;
              if (!pJS.particles.move.enable) {
                  pJS.fn.particlesEmpty();
                  pJS.fn.particlesCreate();
                  pJS.fn.particlesDraw();
                  pJS.fn.vendors.densityAutoParticles()
              }
              pJS.fn.vendors.densityAutoParticles()
          })
      }
  };
  pJS.fn.canvasPaint = function() {
      pJS.canvas.ctx.fillRect(0, 0, pJS.canvas.w, pJS.canvas.h)
  };
  pJS.fn.canvasClear = function() {
      pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h)
  };
  pJS.fn.particle = function(color, opacity, position) {
      this.radius = (pJS.particles.size.random ? Math.random() : 1) * pJS.particles.size.value;
      if (pJS.particles.size.anim.enable) {
          this.size_status = false;
          this.vs = pJS.particles.size.anim.speed / 100;
          if (!pJS.particles.size.anim.sync) {
              this.vs = this.vs * Math.random()
          }
      }
      this.x = position ? position.x : Math.random() * pJS.canvas.w;
      this.y = position ? position.y : Math.random() * pJS.canvas.h;
      if (this.x > pJS.canvas.w - this.radius * 2) this.x = this.x - this.radius;
      else if (this.x < this.radius * 2) this.x = this.x + this.radius;
      if (this.y > pJS.canvas.h - this.radius * 2) this.y = this.y - this.radius;
      else if (this.y < this.radius * 2) this.y = this.y + this.radius;
      if (pJS.particles.move.bounce) {
          pJS.fn.vendors.checkOverlap(this, position)
      }
      this.color = {};
      if (typeof color.value == "object") {
          if (color.value instanceof Array) {
              var color_selected = color.value[Math.floor(Math.random() * pJS.particles.color.value.length)];
              this.color.rgb = hexToRgb(color_selected)
          } else {
              if (color.value.r != undefined && color.value.g != undefined && color.value.b != undefined) {
                  this.color.rgb = {
                      r: color.value.r,
                      g: color.value.g,
                      b: color.value.b
                  }
              }
              if (color.value.h != undefined && color.value.s != undefined && color.value.l != undefined) {
                  this.color.hsl = {
                      h: color.value.h,
                      s: color.value.s,
                      l: color.value.l
                  }
              }
          }
      } else if (color.value == "random") {
          this.color.rgb = {
              r: Math.floor(Math.random() * (255 - 0 + 1)) + 0,
              g: Math.floor(Math.random() * (255 - 0 + 1)) + 0,
              b: Math.floor(Math.random() * (255 - 0 + 1)) + 0
          }
      } else if (typeof color.value == "string") {
          this.color = color;
          this.color.rgb = hexToRgb(this.color.value)
      }
      this.opacity = (pJS.particles.opacity.random ? Math.random() : 1) * pJS.particles.opacity.value;
      if (pJS.particles.opacity.anim.enable) {
          this.opacity_status = false;
          this.vo = pJS.particles.opacity.anim.speed / 100;
          if (!pJS.particles.opacity.anim.sync) {
              this.vo = this.vo * Math.random()
          }
      }
      var velbase = {};
      switch (pJS.particles.move.direction) {
          case "top":
              velbase = {
                  x: 0,
                  y: -1
              };
              break;
          case "top-right":
              velbase = {
                  x: .5,
                  y: -.5
              };
              break;
          case "right":
              velbase = {
                  x: 1,
                  y: -0
              };
              break;
          case "bottom-right":
              velbase = {
                  x: .5,
                  y: .5
              };
              break;
          case "bottom":
              velbase = {
                  x: 0,
                  y: 1
              };
              break;
          case "bottom-left":
              velbase = {
                  x: -.5,
                  y: 1
              };
              break;
          case "left":
              velbase = {
                  x: -1,
                  y: 0
              };
              break;
          case "top-left":
              velbase = {
                  x: -.5,
                  y: -.5
              };
              break;
          default:
              velbase = {
                  x: 0,
                  y: 0
              };
              break
      }
      if (pJS.particles.move.straight) {
          this.vx = velbase.x;
          this.vy = velbase.y;
          if (pJS.particles.move.random) {
              this.vx = this.vx * Math.random();
              this.vy = this.vy * Math.random()
          }
      } else {
          this.vx = velbase.x + Math.random() - .5;
          this.vy = velbase.y + Math.random() - .5
      }
      this.vx_i = this.vx;
      this.vy_i = this.vy;
      var shape_type = pJS.particles.shape.type;
      if (typeof shape_type == "object") {
          if (shape_type instanceof Array) {
              var shape_selected = shape_type[Math.floor(Math.random() * shape_type.length)];
              this.shape = shape_selected
          }
      } else {
          this.shape = shape_type
      }
      if (this.shape == "image") {
          var sh = pJS.particles.shape;
          this.img = {
              src: sh.image.src,
              ratio: sh.image.width / sh.image.height
          };
          if (!this.img.ratio) this.img.ratio = 1;
          if (pJS.tmp.img_type == "svg" && pJS.tmp.source_svg != undefined) {
              pJS.fn.vendors.createSvgImg(this);
              if (pJS.tmp.pushing) {
                  this.img.loaded = false
              }
          }
      }
  };
  pJS.fn.particle.prototype.draw = function() {
      var p = this;
      if (p.radius_bubble != undefined) {
          var radius = p.radius_bubble
      } else {
          var radius = p.radius
      }
      if (p.opacity_bubble != undefined) {
          var opacity = p.opacity_bubble
      } else {
          var opacity = p.opacity
      }
      if (p.color.rgb) {
          var color_value = "rgba(" + p.color.rgb.r + "," + p.color.rgb.g + "," + p.color.rgb.b + "," + opacity + ")"
      } else {
          var color_value = "hsla(" + p.color.hsl.h + "," + p.color.hsl.s + "%," + p.color.hsl.l + "%," + opacity + ")"
      }
      pJS.canvas.ctx.fillStyle = color_value;
      pJS.canvas.ctx.beginPath();
      switch (p.shape) {
          case "circle":
              pJS.canvas.ctx.arc(p.x, p.y, radius, 0, Math.PI * 2, false);
              break;
          case "edge":
              pJS.canvas.ctx.rect(p.x - radius, p.y - radius, radius * 2, radius * 2);
              break;
          case "triangle":
              pJS.fn.vendors.drawShape(pJS.canvas.ctx, p.x - radius, p.y + radius / 1.66, radius * 2, 3, 2);
              break;
          case "polygon":
              pJS.fn.vendors.drawShape(pJS.canvas.ctx, p.x - radius / (pJS.particles.shape.polygon.nb_sides / 3.5), p.y - radius / (2.66 / 3.5), radius * 2.66 / (pJS.particles.shape.polygon.nb_sides / 3), pJS.particles.shape.polygon.nb_sides, 1);
              break;
          case "star":
              pJS.fn.vendors.drawShape(pJS.canvas.ctx, p.x - radius * 2 / (pJS.particles.shape.polygon.nb_sides / 4), p.y - radius / (2 * 2.66 / 3.5), radius * 2 * 2.66 / (pJS.particles.shape.polygon.nb_sides / 3), pJS.particles.shape.polygon.nb_sides, 2);
              break;
          case "image":
              function draw() {
                  pJS.canvas.ctx.drawImage(img_obj, p.x - radius, p.y - radius, radius * 2, radius * 2 / p.img.ratio)
              }
              if (pJS.tmp.img_type == "svg") {
                  var img_obj = p.img.obj
              } else {
                  var img_obj = pJS.tmp.img_obj
              }
              if (img_obj) {
                  draw()
              }
              break
      }
      pJS.canvas.ctx.closePath();
      if (pJS.particles.shape.stroke.width > 0) {
          pJS.canvas.ctx.strokeStyle = pJS.particles.shape.stroke.color;
          pJS.canvas.ctx.lineWidth = pJS.particles.shape.stroke.width;
          pJS.canvas.ctx.stroke()
      }
      pJS.canvas.ctx.fill()
  };
  pJS.fn.particlesCreate = function() {
      for (var i = 0; i < pJS.particles.number.value; i++) {
          pJS.particles.array.push(new pJS.fn.particle(pJS.particles.color, pJS.particles.opacity.value))
      }
  };
  pJS.fn.particlesUpdate = function() {
      for (var i = 0; i < pJS.particles.array.length; i++) {
          var p = pJS.particles.array[i];
          if (pJS.particles.move.enable) {
              var ms = pJS.particles.move.speed / 2;
              p.x += p.vx * ms;
              p.y += p.vy * ms
          }
          if (pJS.particles.opacity.anim.enable) {
              if (p.opacity_status == true) {
                  if (p.opacity >= pJS.particles.opacity.value) p.opacity_status = false;
                  p.opacity += p.vo
              } else {
                  if (p.opacity <= pJS.particles.opacity.anim.opacity_min) p.opacity_status = true;
                  p.opacity -= p.vo
              }
              if (p.opacity < 0) p.opacity = 0
          }
          if (pJS.particles.size.anim.enable) {
              if (p.size_status == true) {
                  if (p.radius >= pJS.particles.size.value) p.size_status = false;
                  p.radius += p.vs
              } else {
                  if (p.radius <= pJS.particles.size.anim.size_min) p.size_status = true;
                  p.radius -= p.vs
              }
              if (p.radius < 0) p.radius = 0
          }
          if (pJS.particles.move.out_mode == "bounce") {
              var new_pos = {
                  x_left: p.radius,
                  x_right: pJS.canvas.w,
                  y_top: p.radius,
                  y_bottom: pJS.canvas.h
              }
          } else {
              var new_pos = {
                  x_left: -p.radius,
                  x_right: pJS.canvas.w + p.radius,
                  y_top: -p.radius,
                  y_bottom: pJS.canvas.h + p.radius
              }
          }
          if (p.x - p.radius > pJS.canvas.w) {
              p.x = new_pos.x_left;
              p.y = Math.random() * pJS.canvas.h
          } else if (p.x + p.radius < 0) {
              p.x = new_pos.x_right;
              p.y = Math.random() * pJS.canvas.h
          }
          if (p.y - p.radius > pJS.canvas.h) {
              p.y = new_pos.y_top;
              p.x = Math.random() * pJS.canvas.w
          } else if (p.y + p.radius < 0) {
              p.y = new_pos.y_bottom;
              p.x = Math.random() * pJS.canvas.w
          }
          switch (pJS.particles.move.out_mode) {
              case "bounce":
                  if (p.x + p.radius > pJS.canvas.w) p.vx = -p.vx;
                  else if (p.x - p.radius < 0) p.vx = -p.vx;
                  if (p.y + p.radius > pJS.canvas.h) p.vy = -p.vy;
                  else if (p.y - p.radius < 0) p.vy = -p.vy;
                  break
          }
          if (isInArray("grab", pJS.interactivity.events.onhover.mode)) {
              pJS.fn.modes.grabParticle(p)
          }
          if (isInArray("bubble", pJS.interactivity.events.onhover.mode) || isInArray("bubble", pJS.interactivity.events.onclick.mode)) {
              pJS.fn.modes.bubbleParticle(p)
          }
          if (isInArray("repulse", pJS.interactivity.events.onhover.mode) || isInArray("repulse", pJS.interactivity.events.onclick.mode)) {
              pJS.fn.modes.repulseParticle(p)
          }
          if (pJS.particles.line_linked.enable || pJS.particles.move.attract.enable) {
              for (var j = i + 1; j < pJS.particles.array.length; j++) {
                  var p2 = pJS.particles.array[j];
                  if (pJS.particles.line_linked.enable) {
                      pJS.fn.interact.linkParticles(p, p2)
                  }
                  if (pJS.particles.move.attract.enable) {
                      pJS.fn.interact.attractParticles(p, p2)
                  }
                  if (pJS.particles.move.bounce) {
                      pJS.fn.interact.bounceParticles(p, p2)
                  }
              }
          }
      }
  };
  pJS.fn.particlesDraw = function() {
      pJS.canvas.ctx.clearRect(0, 0, pJS.canvas.w, pJS.canvas.h);
      pJS.fn.particlesUpdate();
      for (var i = 0; i < pJS.particles.array.length; i++) {
          var p = pJS.particles.array[i];
          p.draw()
      }
  };
  pJS.fn.particlesEmpty = function() {
      pJS.particles.array = []
  };
  pJS.fn.particlesRefresh = function() {
      cancelRequestAnimFrame(pJS.fn.checkAnimFrame);
      cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
      pJS.tmp.source_svg = undefined;
      pJS.tmp.img_obj = undefined;
      pJS.tmp.count_svg = 0;
      pJS.fn.particlesEmpty();
      pJS.fn.canvasClear();
      pJS.fn.vendors.start()
  };
  pJS.fn.interact.linkParticles = function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y,
          dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= pJS.particles.line_linked.distance) {
          var opacity_line = pJS.particles.line_linked.opacity - dist / (1 / pJS.particles.line_linked.opacity) / pJS.particles.line_linked.distance;
          if (opacity_line > 0) {
              var color_line = pJS.particles.line_linked.color_rgb_line;
              pJS.canvas.ctx.strokeStyle = "rgba(" + color_line.r + "," + color_line.g + "," + color_line.b + "," + opacity_line + ")";
              pJS.canvas.ctx.lineWidth = pJS.particles.line_linked.width;
              pJS.canvas.ctx.beginPath();
              pJS.canvas.ctx.moveTo(p1.x, p1.y);
              pJS.canvas.ctx.lineTo(p2.x, p2.y);
              pJS.canvas.ctx.stroke();
              pJS.canvas.ctx.closePath()
          }
      }
  };
  pJS.fn.interact.attractParticles = function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y,
          dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= pJS.particles.line_linked.distance) {
          var ax = dx / (pJS.particles.move.attract.rotateX * 1e3),
              ay = dy / (pJS.particles.move.attract.rotateY * 1e3);
          p1.vx -= ax;
          p1.vy -= ay;
          p2.vx += ax;
          p2.vy += ay
      }
  };
  pJS.fn.interact.bounceParticles = function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y,
          dist = Math.sqrt(dx * dx + dy * dy),
          dist_p = p1.radius + p2.radius;
      if (dist <= dist_p) {
          p1.vx = -p1.vx;
          p1.vy = -p1.vy;
          p2.vx = -p2.vx;
          p2.vy = -p2.vy
      }
  };
  pJS.fn.modes.pushParticles = function(nb, pos) {
      pJS.tmp.pushing = true;
      for (var i = 0; i < nb; i++) {
          pJS.particles.array.push(new pJS.fn.particle(pJS.particles.color, pJS.particles.opacity.value, {
              x: pos ? pos.pos_x : Math.random() * pJS.canvas.w,
              y: pos ? pos.pos_y : Math.random() * pJS.canvas.h
          }));
          if (i == nb - 1) {
              if (!pJS.particles.move.enable) {
                  pJS.fn.particlesDraw()
              }
              pJS.tmp.pushing = false
          }
      }
  };
  pJS.fn.modes.removeParticles = function(nb) {
      pJS.particles.array.splice(0, nb);
      if (!pJS.particles.move.enable) {
          pJS.fn.particlesDraw()
      }
  };
  pJS.fn.modes.bubbleParticle = function(p) {
      if (pJS.interactivity.events.onhover.enable && isInArray("bubble", pJS.interactivity.events.onhover.mode)) {
          var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
              dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
              dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse),
              ratio = 1 - dist_mouse / pJS.interactivity.modes.bubble.distance;

          function init() {
              p.opacity_bubble = p.opacity;
              p.radius_bubble = p.radius
          }
          if (dist_mouse <= pJS.interactivity.modes.bubble.distance) {
              if (ratio >= 0 && pJS.interactivity.status == "mousemove") {
                  if (pJS.interactivity.modes.bubble.size != pJS.particles.size.value) {
                      if (pJS.interactivity.modes.bubble.size > pJS.particles.size.value) {
                          var size = p.radius + pJS.interactivity.modes.bubble.size * ratio;
                          if (size >= 0) {
                              p.radius_bubble = size
                          }
                      } else {
                          var dif = p.radius - pJS.interactivity.modes.bubble.size,
                              size = p.radius - dif * ratio;
                          if (size > 0) {
                              p.radius_bubble = size
                          } else {
                              p.radius_bubble = 0
                          }
                      }
                  }
                  if (pJS.interactivity.modes.bubble.opacity != pJS.particles.opacity.value) {
                      if (pJS.interactivity.modes.bubble.opacity > pJS.particles.opacity.value) {
                          var opacity = pJS.interactivity.modes.bubble.opacity * ratio;
                          if (opacity > p.opacity && opacity <= pJS.interactivity.modes.bubble.opacity) {
                              p.opacity_bubble = opacity
                          }
                      } else {
                          var opacity = p.opacity - (pJS.particles.opacity.value - pJS.interactivity.modes.bubble.opacity) * ratio;
                          if (opacity < p.opacity && opacity >= pJS.interactivity.modes.bubble.opacity) {
                              p.opacity_bubble = opacity
                          }
                      }
                  }
              }
          } else {
              init()
          }
          if (pJS.interactivity.status == "mouseleave") {
              init()
          }
      } else if (pJS.interactivity.events.onclick.enable && isInArray("bubble", pJS.interactivity.events.onclick.mode)) {
          if (pJS.tmp.bubble_clicking) {
              var dx_mouse = p.x - pJS.interactivity.mouse.click_pos_x,
                  dy_mouse = p.y - pJS.interactivity.mouse.click_pos_y,
                  dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse),
                  time_spent = ((new Date).getTime() - pJS.interactivity.mouse.click_time) / 1e3;
              if (time_spent > pJS.interactivity.modes.bubble.duration) {
                  pJS.tmp.bubble_duration_end = true
              }
              if (time_spent > pJS.interactivity.modes.bubble.duration * 2) {
                  pJS.tmp.bubble_clicking = false;
                  pJS.tmp.bubble_duration_end = false
              }
          }

          function process(bubble_param, particles_param, p_obj_bubble, p_obj, id) {
              if (bubble_param != particles_param) {
                  if (!pJS.tmp.bubble_duration_end) {
                      if (dist_mouse <= pJS.interactivity.modes.bubble.distance) {
                          if (p_obj_bubble != undefined) var obj = p_obj_bubble;
                          else var obj = p_obj;
                          if (obj != bubble_param) {
                              var value = p_obj - time_spent * (p_obj - bubble_param) / pJS.interactivity.modes.bubble.duration;
                              if (id == "size") p.radius_bubble = value;
                              if (id == "opacity") p.opacity_bubble = value
                          }
                      } else {
                          if (id == "size") p.radius_bubble = undefined;
                          if (id == "opacity") p.opacity_bubble = undefined
                      }
                  } else {
                      if (p_obj_bubble != undefined) {
                          var value_tmp = p_obj - time_spent * (p_obj - bubble_param) / pJS.interactivity.modes.bubble.duration,
                              dif = bubble_param - value_tmp;
                          value = bubble_param + dif;
                          if (id == "size") p.radius_bubble = value;
                          if (id == "opacity") p.opacity_bubble = value
                      }
                  }
              }
          }
          if (pJS.tmp.bubble_clicking) {
              process(pJS.interactivity.modes.bubble.size, pJS.particles.size.value, p.radius_bubble, p.radius, "size");
              process(pJS.interactivity.modes.bubble.opacity, pJS.particles.opacity.value, p.opacity_bubble, p.opacity, "opacity")
          }
      }
  };
  pJS.fn.modes.repulseParticle = function(p) {
      if (pJS.interactivity.events.onhover.enable && isInArray("repulse", pJS.interactivity.events.onhover.mode) && pJS.interactivity.status == "mousemove") {
          var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
              dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
              dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
          var normVec = {
                  x: dx_mouse / dist_mouse,
                  y: dy_mouse / dist_mouse
              },
              repulseRadius = pJS.interactivity.modes.repulse.distance,
              velocity = 100,
              repulseFactor = clamp(1 / repulseRadius * (-1 * Math.pow(dist_mouse / repulseRadius, 2) + 1) * repulseRadius * velocity, 0, 50);
          var pos = {
              x: p.x + normVec.x * repulseFactor,
              y: p.y + normVec.y * repulseFactor
          };
          if (pJS.particles.move.out_mode == "bounce") {
              if (pos.x - p.radius > 0 && pos.x + p.radius < pJS.canvas.w) p.x = pos.x;
              if (pos.y - p.radius > 0 && pos.y + p.radius < pJS.canvas.h) p.y = pos.y
          } else {
              p.x = pos.x;
              p.y = pos.y
          }
      } else if (pJS.interactivity.events.onclick.enable && isInArray("repulse", pJS.interactivity.events.onclick.mode)) {
          if (!pJS.tmp.repulse_finish) {
              pJS.tmp.repulse_count++;
              if (pJS.tmp.repulse_count == pJS.particles.array.length) {
                  pJS.tmp.repulse_finish = true
              }
          }
          if (pJS.tmp.repulse_clicking) {
              var repulseRadius = Math.pow(pJS.interactivity.modes.repulse.distance / 6, 3);
              var dx = pJS.interactivity.mouse.click_pos_x - p.x,
                  dy = pJS.interactivity.mouse.click_pos_y - p.y,
                  d = dx * dx + dy * dy;
              var force = -repulseRadius / d * 1;

              function process() {
                  var f = Math.atan2(dy, dx);
                  p.vx = force * Math.cos(f);
                  p.vy = force * Math.sin(f);
                  if (pJS.particles.move.out_mode == "bounce") {
                      var pos = {
                          x: p.x + p.vx,
                          y: p.y + p.vy
                      };
                      if (pos.x + p.radius > pJS.canvas.w) p.vx = -p.vx;
                      else if (pos.x - p.radius < 0) p.vx = -p.vx;
                      if (pos.y + p.radius > pJS.canvas.h) p.vy = -p.vy;
                      else if (pos.y - p.radius < 0) p.vy = -p.vy
                  }
              }
              if (d <= repulseRadius) {
                  process()
              }
          } else {
              if (pJS.tmp.repulse_clicking == false) {
                  p.vx = p.vx_i;
                  p.vy = p.vy_i
              }
          }
      }
  };
  pJS.fn.modes.grabParticle = function(p) {
      if (pJS.interactivity.events.onhover.enable && pJS.interactivity.status == "mousemove") {
          var dx_mouse = p.x - pJS.interactivity.mouse.pos_x,
              dy_mouse = p.y - pJS.interactivity.mouse.pos_y,
              dist_mouse = Math.sqrt(dx_mouse * dx_mouse + dy_mouse * dy_mouse);
          if (dist_mouse <= pJS.interactivity.modes.grab.distance) {
              var opacity_line = pJS.interactivity.modes.grab.line_linked.opacity - dist_mouse / (1 / pJS.interactivity.modes.grab.line_linked.opacity) / pJS.interactivity.modes.grab.distance;
              if (opacity_line > 0) {
                  var color_line = pJS.particles.line_linked.color_rgb_line;
                  pJS.canvas.ctx.strokeStyle = "rgba(" + color_line.r + "," + color_line.g + "," + color_line.b + "," + opacity_line + ")";
                  pJS.canvas.ctx.lineWidth = pJS.particles.line_linked.width;
                  pJS.canvas.ctx.beginPath();
                  pJS.canvas.ctx.moveTo(p.x, p.y);
                  pJS.canvas.ctx.lineTo(pJS.interactivity.mouse.pos_x, pJS.interactivity.mouse.pos_y);
                  pJS.canvas.ctx.stroke();
                  pJS.canvas.ctx.closePath()
              }
          }
      }
  };
  pJS.fn.vendors.eventsListeners = function() {
      if (pJS.interactivity.detect_on == "window") {
          pJS.interactivity.el = window
      } else {
          pJS.interactivity.el = pJS.canvas.el
      }
      if (pJS.interactivity.events.onhover.enable || pJS.interactivity.events.onclick.enable) {
          pJS.interactivity.el.addEventListener("mousemove", function(e) {
              if (pJS.interactivity.el == window) {
                  var pos_x = e.clientX,
                      pos_y = e.clientY
              } else {
                  var pos_x = e.offsetX || e.clientX,
                      pos_y = e.offsetY || e.clientY
              }
              pJS.interactivity.mouse.pos_x = pos_x;
              pJS.interactivity.mouse.pos_y = pos_y;
              if (pJS.tmp.retina) {
                  pJS.interactivity.mouse.pos_x *= pJS.canvas.pxratio;
                  pJS.interactivity.mouse.pos_y *= pJS.canvas.pxratio
              }
              pJS.interactivity.status = "mousemove"
          });
          pJS.interactivity.el.addEventListener("mouseleave", function(e) {
              pJS.interactivity.mouse.pos_x = null;
              pJS.interactivity.mouse.pos_y = null;
              pJS.interactivity.status = "mouseleave"
          })
      }
      if (pJS.interactivity.events.onclick.enable) {
          pJS.interactivity.el.addEventListener("click", function() {
              pJS.interactivity.mouse.click_pos_x = pJS.interactivity.mouse.pos_x;
              pJS.interactivity.mouse.click_pos_y = pJS.interactivity.mouse.pos_y;
              pJS.interactivity.mouse.click_time = (new Date).getTime();
              if (pJS.interactivity.events.onclick.enable) {
                  switch (pJS.interactivity.events.onclick.mode) {
                      case "push":
                          if (pJS.particles.move.enable) {
                              pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb, pJS.interactivity.mouse)
                          } else {
                              if (pJS.interactivity.modes.push.particles_nb == 1) {
                                  pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb, pJS.interactivity.mouse)
                              } else if (pJS.interactivity.modes.push.particles_nb > 1) {
                                  pJS.fn.modes.pushParticles(pJS.interactivity.modes.push.particles_nb)
                              }
                          }
                          break;
                      case "remove":
                          pJS.fn.modes.removeParticles(pJS.interactivity.modes.remove.particles_nb);
                          break;
                      case "bubble":
                          pJS.tmp.bubble_clicking = true;
                          break;
                      case "repulse":
                          pJS.tmp.repulse_clicking = true;
                          pJS.tmp.repulse_count = 0;
                          pJS.tmp.repulse_finish = false;
                          setTimeout(function() {
                              pJS.tmp.repulse_clicking = false
                          }, pJS.interactivity.modes.repulse.duration * 1e3);
                          break
                  }
              }
          })
      }
  };
  pJS.fn.vendors.densityAutoParticles = function() {
      if (pJS.particles.number.density.enable) {
          var area = pJS.canvas.el.width * pJS.canvas.el.height / 1e3;
          if (pJS.tmp.retina) {
              area = area / (pJS.canvas.pxratio * 2)
          }
          var nb_particles = area * pJS.particles.number.value / pJS.particles.number.density.value_area;
          var missing_particles = pJS.particles.array.length - nb_particles;
          if (missing_particles < 0) pJS.fn.modes.pushParticles(Math.abs(missing_particles));
          else pJS.fn.modes.removeParticles(missing_particles)
      }
  };
  pJS.fn.vendors.checkOverlap = function(p1, position) {
      for (var i = 0; i < pJS.particles.array.length; i++) {
          var p2 = pJS.particles.array[i];
          var dx = p1.x - p2.x,
              dy = p1.y - p2.y,
              dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= p1.radius + p2.radius) {
              p1.x = position ? position.x : Math.random() * pJS.canvas.w;
              p1.y = position ? position.y : Math.random() * pJS.canvas.h;
              pJS.fn.vendors.checkOverlap(p1)
          }
      }
  };
  pJS.fn.vendors.createSvgImg = function(p) {
      var svgXml = pJS.tmp.source_svg,
          rgbHex = /#([0-9A-F]{3,6})/gi,
          coloredSvgXml = svgXml.replace(rgbHex, function(m, r, g, b) {
              if (p.color.rgb) {
                  var color_value = "rgba(" + p.color.rgb.r + "," + p.color.rgb.g + "," + p.color.rgb.b + "," + p.opacity + ")"
              } else {
                  var color_value = "hsla(" + p.color.hsl.h + "," + p.color.hsl.s + "%," + p.color.hsl.l + "%," + p.opacity + ")"
              }
              return color_value
          });
      var svg = new Blob([coloredSvgXml], {
              type: "image/svg+xml;charset=utf-8"
          }),
          DOMURL = window.URL || window.webkitURL || window,
          url = DOMURL.createObjectURL(svg);
      var img = new Image;
      img.addEventListener("load", function() {
          p.img.obj = img;
          p.img.loaded = true;
          DOMURL.revokeObjectURL(url);
          pJS.tmp.count_svg++
      });
      img.src = url
  };
  pJS.fn.vendors.destroypJS = function() {
      cancelAnimationFrame(pJS.fn.drawAnimFrame);
      canvas_el.remove();
      pJSDom = null
  };
  pJS.fn.vendors.drawShape = function(c, startX, startY, sideLength, sideCountNumerator, sideCountDenominator) {
      var sideCount = sideCountNumerator * sideCountDenominator;
      var decimalSides = sideCountNumerator / sideCountDenominator;
      var interiorAngleDegrees = 180 * (decimalSides - 2) / decimalSides;
      var interiorAngle = Math.PI - Math.PI * interiorAngleDegrees / 180;
      c.save();
      c.beginPath();
      c.translate(startX, startY);
      c.moveTo(0, 0);
      for (var i = 0; i < sideCount; i++) {
          c.lineTo(sideLength, 0);
          c.translate(sideLength, 0);
          c.rotate(interiorAngle)
      }
      c.fill();
      c.restore()
  };
  pJS.fn.vendors.exportImg = function() {
      window.open(pJS.canvas.el.toDataURL("image/png"), "_blank")
  };
  pJS.fn.vendors.loadImg = function(type) {
      pJS.tmp.img_error = undefined;
      if (pJS.particles.shape.image.src != "") {
          if (type == "svg") {
              var xhr = new XMLHttpRequest;
              xhr.open("GET", pJS.particles.shape.image.src);
              xhr.onreadystatechange = function(data) {
                  if (xhr.readyState == 4) {
                      if (xhr.status == 200) {
                          pJS.tmp.source_svg = data.currentTarget.response;
                          pJS.fn.vendors.checkBeforeDraw()
                      } else {
                          console.log("Error pJS - Image not found");
                          pJS.tmp.img_error = true
                      }
                  }
              };
              xhr.send()
          } else {
              var img = new Image;
              img.addEventListener("load", function() {
                  pJS.tmp.img_obj = img;
                  pJS.fn.vendors.checkBeforeDraw()
              });
              img.src = pJS.particles.shape.image.src
          }
      } else {
          console.log("Error pJS - No image.src");
          pJS.tmp.img_error = true
      }
  };
  pJS.fn.vendors.draw = function() {
      if (pJS.particles.shape.type == "image") {
          if (pJS.tmp.img_type == "svg") {
              if (pJS.tmp.count_svg >= pJS.particles.number.value) {
                  pJS.fn.particlesDraw();
                  if (!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
                  else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw)
              } else {
                  if (!pJS.tmp.img_error) pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw)
              }
          } else {
              if (pJS.tmp.img_obj != undefined) {
                  pJS.fn.particlesDraw();
                  if (!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
                  else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw)
              } else {
                  if (!pJS.tmp.img_error) pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw)
              }
          }
      } else {
          pJS.fn.particlesDraw();
          if (!pJS.particles.move.enable) cancelRequestAnimFrame(pJS.fn.drawAnimFrame);
          else pJS.fn.drawAnimFrame = requestAnimFrame(pJS.fn.vendors.draw)
      }
  };
  pJS.fn.vendors.checkBeforeDraw = function() {
      if (pJS.particles.shape.type == "image") {
          if (pJS.tmp.img_type == "svg" && pJS.tmp.source_svg == undefined) {
              pJS.tmp.checkAnimFrame = requestAnimFrame(check)
          } else {
              cancelRequestAnimFrame(pJS.tmp.checkAnimFrame);
              if (!pJS.tmp.img_error) {
                  pJS.fn.vendors.init();
                  pJS.fn.vendors.draw()
              }
          }
      } else {
          pJS.fn.vendors.init();
          pJS.fn.vendors.draw()
      }
  };
  pJS.fn.vendors.init = function() {
      pJS.fn.retinaInit();
      pJS.fn.canvasInit();
      pJS.fn.canvasSize();
      pJS.fn.canvasPaint();
      pJS.fn.particlesCreate();
      pJS.fn.vendors.densityAutoParticles();
      pJS.particles.line_linked.color_rgb_line = hexToRgb(pJS.particles.line_linked.color)
  };
  pJS.fn.vendors.start = function() {
      if (isInArray("image", pJS.particles.shape.type)) {
          pJS.tmp.img_type = pJS.particles.shape.image.src.substr(pJS.particles.shape.image.src.length - 3);
          pJS.fn.vendors.loadImg(pJS.tmp.img_type)
      } else {
          pJS.fn.vendors.checkBeforeDraw()
      }
  };
  pJS.fn.vendors.eventsListeners();
  pJS.fn.vendors.start()
};
Object.deepExtend = function(destination, source) {
  for (var property in source) {
      if (source[property] && source[property].constructor && source[property].constructor === Object) {
          destination[property] = destination[property] || {};
          arguments.callee(destination[property], source[property])
      } else {
          destination[property] = source[property]
      }
  }
  return destination
};
window.requestAnimFrame = function() {
  return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      window.setTimeout(callback, 1e3 / 60)
  }
}();
window.cancelRequestAnimFrame = function() {
  return window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout
}();

function hexToRgb(hex) {
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
      return r + r + g + g + b + b
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
  } : null
}

function clamp(number, min, max) {
  return Math.min(Math.max(number, min), max)
}

function isInArray(value, array) {
  return array.indexOf(value) > -1
}
window.pJSDom = [];
window.particlesJS = function(tag_id, params) {
  if (typeof tag_id != "string") {
      params = tag_id;
      tag_id = "particles-js"
  }
  if (!tag_id) {
      tag_id = "particles-js"
  }
  var pJS_tag = document.getElementById(tag_id),
      pJS_canvas_class = "particles-js-canvas-el",
      exist_canvas = pJS_tag.getElementsByClassName(pJS_canvas_class);
  if (exist_canvas.length) {
      while (exist_canvas.length > 0) {
          pJS_tag.removeChild(exist_canvas[0])
      }
  }
  var canvas_el = document.createElement("canvas");
  canvas_el.className = pJS_canvas_class;
  canvas_el.style.width = "100%";
  canvas_el.style.height = "100%";
  var canvas = document.getElementById(tag_id).appendChild(canvas_el);
  if (canvas != null) {
      pJSDom.push(new pJS(tag_id, params))
  }
};
window.particlesJS.load = function(tag_id, path_config_json, callback) {
  var xhr = new XMLHttpRequest;
  xhr.open("GET", path_config_json);
  xhr.onreadystatechange = function(data) {
      if (xhr.readyState == 4) {
          if (xhr.status == 200) {
              var params = JSON.parse(data.currentTarget.response);
              window.particlesJS(tag_id, params);
              if (callback) callback()
          } else {
              console.log("Error pJS - XMLHttpRequest status: " + xhr.status);
              console.log("Error pJS - File config not found")
          }
      }
  };
  xhr.send()
};
! function() {
  function a() {}

  function b(a) {
      return f.retinaImageSuffix + a
  }

  function c(a, c) {
      if (this.path = a || "", "undefined" != typeof c && null !== c) this.at_2x_path = c, this.perform_check = !1;
      else {
          if (void 0 !== document.createElement) {
              var d = document.createElement("a");
              d.href = this.path, d.pathname = d.pathname.replace(g, b), this.at_2x_path = d.href
          } else {
              var e = this.path.split("?");
              e[0] = e[0].replace(g, b), this.at_2x_path = e.join("?")
          }
          this.perform_check = !0
      }
  }

  function d(a) {
      this.el = a, this.path = new c(this.el.getAttribute("src"), this.el.getAttribute("data-at2x"));
      var b = this;
      this.path.check_2x_variant(function(a) {
          a && b.swap()
      })
  }
  var e = "undefined" == typeof exports ? window : exports,
      f = {
          retinaImageSuffix: "@2x",
          check_mime_type: !0,
          force_original_dimensions: !0
      };
  e.Retina = a, a.configure = function(a) {
      null === a && (a = {});
      for (var b in a) a.hasOwnProperty(b) && (f[b] = a[b])
  }, a.init = function(a) {
      null === a && (a = e);
      var b = a.onload || function() {};
      a.onload = function() {
          var a, c, e = document.getElementsByTagName("img"),
              f = [];
          for (a = 0; a < e.length; a += 1) c = e[a], c.getAttributeNode("data-no-retina") || f.push(new d(c));
          b()
      }
  }, a.isRetina = function() {
      var a = "(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)";
      return e.devicePixelRatio > 1 ? !0 : e.matchMedia && e.matchMedia(a).matches ? !0 : !1
  };
  var g = /\.\w+$/;
  e.RetinaImagePath = c, c.confirmed_paths = [], c.prototype.is_external = function() {
      return !(!this.path.match(/^https?\:/i) || this.path.match("//" + document.domain))
  }, c.prototype.check_2x_variant = function(a) {
      var b, d = this;
      return this.is_external() ? a(!1) : this.perform_check || "undefined" == typeof this.at_2x_path || null === this.at_2x_path ? this.at_2x_path in c.confirmed_paths ? a(!0) : (b = new XMLHttpRequest, b.open("HEAD", this.at_2x_path), b.onreadystatechange = function() {
          if (4 !== b.readyState) return a(!1);
          if (b.status >= 200 && b.status <= 399) {
              if (f.check_mime_type) {
                  var e = b.getResponseHeader("Content-Type");
                  if (null === e || !e.match(/^image/i)) return a(!1)
              }
              return c.confirmed_paths.push(d.at_2x_path), a(!0)
          }
          return a(!1)
      }, b.send(), void 0) : a(!0)
  }, e.RetinaImage = d, d.prototype.swap = function(a) {
      function b() {
          c.el.complete ? (f.force_original_dimensions && (c.el.setAttribute("width", c.el.offsetWidth), c.el.setAttribute("height", c.el.offsetHeight)), c.el.setAttribute("src", a)) : setTimeout(b, 5)
      }
      "undefined" == typeof a && (a = this.path.at_2x_path);
      var c = this;
      b()
  }, a.isRetina() && a.init(e)
}();
(function(window, document, undefined) {
  "use strict";
  var skrollr = {
      get: function() {
          return _instance
      },
      init: function(options) {
          return _instance || new Skrollr(options)
      },
      VERSION: "0.6.30"
  };
  var hasProp = Object.prototype.hasOwnProperty;
  var Math = window.Math;
  var getStyle = window.getComputedStyle;
  var documentElement;
  var body;
  var EVENT_TOUCHSTART = "touchstart";
  var EVENT_TOUCHMOVE = "touchmove";
  var EVENT_TOUCHCANCEL = "touchcancel";
  var EVENT_TOUCHEND = "touchend";
  var SKROLLABLE_CLASS = "skrollable";
  var SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + "-before";
  var SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + "-between";
  var SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + "-after";
  var SKROLLR_CLASS = "skrollr";
  var NO_SKROLLR_CLASS = "no-" + SKROLLR_CLASS;
  var SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + "-desktop";
  var SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + "-mobile";
  var DEFAULT_EASING = "linear";
  var DEFAULT_DURATION = 1e3;
  var DEFAULT_MOBILE_DECELERATION = .004;
  var DEFAULT_SKROLLRBODY = "skrollr-body";
  var DEFAULT_SMOOTH_SCROLLING_DURATION = 200;
  var ANCHOR_START = "start";
  var ANCHOR_END = "end";
  var ANCHOR_CENTER = "center";
  var ANCHOR_BOTTOM = "bottom";
  var SKROLLABLE_ID_DOM_PROPERTY = "___skrollable_id";
  var rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;
  var rxTrim = /^\s+|\s+$/g;
  var rxKeyframeAttribute = /^data(?:-(_\w+))?(?:-?(-?\d*\.?\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;
  var rxPropValue = /\s*(@?[\w\-\[\]]+)\s*:\s*(.+?)\s*(?:;|$)/gi;
  var rxPropEasing = /^(@?[a-z\-]+)\[(\w+)\]$/;
  var rxCamelCase = /-([a-z0-9_])/g;
  var rxCamelCaseFn = function(str, letter) {
      return letter.toUpperCase()
  };
  var rxNumericValue = /[\-+]?[\d]*\.?[\d]+/g;
  var rxInterpolateString = /\{\?\}/g;
  var rxRGBAIntegerColor = /rgba?\(\s*-?\d+\s*,\s*-?\d+\s*,\s*-?\d+/g;
  var rxGradient = /[a-z\-]+-gradient/g;
  var theCSSPrefix = "";
  var theDashedCSSPrefix = "";
  var detectCSSPrefix = function() {
      var rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;
      if (!getStyle) {
          return
      }
      var style = getStyle(body, null);
      for (var k in style) {
          theCSSPrefix = k.match(rxPrefixes) || +k == k && style[k].match(rxPrefixes);
          if (theCSSPrefix) {
              break
          }
      }
      if (!theCSSPrefix) {
          theCSSPrefix = theDashedCSSPrefix = "";
          return
      }
      theCSSPrefix = theCSSPrefix[0];
      if (theCSSPrefix.slice(0, 1) === "-") {
          theDashedCSSPrefix = theCSSPrefix;
          theCSSPrefix = {
              "-webkit-": "webkit",
              "-moz-": "Moz",
              "-ms-": "ms",
              "-o-": "O"
          } [theCSSPrefix]
      } else {
          theDashedCSSPrefix = "-" + theCSSPrefix.toLowerCase() + "-"
      }
  };
  var polyfillRAF = function() {
      var requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + "RequestAnimationFrame"];
      var lastTime = _now();
      if (_isMobile || !requestAnimFrame) {
          requestAnimFrame = function(callback) {
              var deltaTime = _now() - lastTime;
              var delay = Math.max(0, 1e3 / 60 - deltaTime);
              return window.setTimeout(function() {
                  lastTime = _now();
                  callback()
              }, delay)
          }
      }
      return requestAnimFrame
  };
  var polyfillCAF = function() {
      var cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + "CancelAnimationFrame"];
      if (_isMobile || !cancelAnimFrame) {
          cancelAnimFrame = function(timeout) {
              return window.clearTimeout(timeout)
          }
      }
      return cancelAnimFrame
  };
  var easings = {
      begin: function() {
          return 0
      },
      end: function() {
          return 1
      },
      linear: function(p) {
          return p
      },
      quadratic: function(p) {
          return p * p
      },
      cubic: function(p) {
          return p * p * p
      },
      swing: function(p) {
          return -Math.cos(p * Math.PI) / 2 + .5
      },
      sqrt: function(p) {
          return Math.sqrt(p)
      },
      outCubic: function(p) {
          return Math.pow(p - 1, 3) + 1
      },
      bounce: function(p) {
          var a;
          if (p <= .5083) {
              a = 3
          } else if (p <= .8489) {
              a = 9
          } else if (p <= .96208) {
              a = 27
          } else if (p <= .99981) {
              a = 91
          } else {
              return 1
          }
          return 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a)
      }
  };

  function Skrollr(options) {
      documentElement = document.documentElement;
      body = document.body;
      detectCSSPrefix();
      _instance = this;
      options = options || {};
      _constants = options.constants || {};
      if (options.easing) {
          for (var e in options.easing) {
              easings[e] = options.easing[e]
          }
      }
      _edgeStrategy = options.edgeStrategy || "set";
      _listeners = {
          beforerender: options.beforerender,
          render: options.render,
          keyframe: options.keyframe
      };
      _forceHeight = options.forceHeight !== false;
      if (_forceHeight) {
          _scale = options.scale || 1
      }
      _mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;
      _smoothScrollingEnabled = options.smoothScrolling !== false;
      _smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION;
      _smoothScrolling = {
          targetTop: _instance.getScrollTop()
      };
      _isMobile = (options.mobileCheck || function() {
          return /Android|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent || navigator.vendor || window.opera)
      })();
      if (_isMobile) {
          _skrollrBody = document.getElementById(options.skrollrBody || DEFAULT_SKROLLRBODY);
          if (_skrollrBody) {
              _detect3DTransforms()
          }
          _initMobile();
          _updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS])
      } else {
          _updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS])
      }
      _instance.refresh();
      _addEvent(window, "resize orientationchange", function() {
          var width = documentElement.clientWidth;
          var height = documentElement.clientHeight;
          if (height !== _lastViewportHeight || width !== _lastViewportWidth) {
              _lastViewportHeight = height;
              _lastViewportWidth = width;
              _requestReflow = true
          }
      });
      var requestAnimFrame = polyfillRAF();
      (function animloop() {
          _render();
          _animFrame = requestAnimFrame(animloop)
      })();
      return _instance
  }
  Skrollr.prototype.refresh = function(elements) {
      var elementIndex;
      var elementsLength;
      var ignoreID = false;
      if (elements === undefined) {
          ignoreID = true;
          _skrollables = [];
          _skrollableIdCounter = 0;
          elements = document.getElementsByTagName("*")
      } else if (elements.length === undefined) {
          elements = [elements]
      }
      elementIndex = 0;
      elementsLength = elements.length;
      for (; elementIndex < elementsLength; elementIndex++) {
          var el = elements[elementIndex];
          var anchorTarget = el;
          var keyFrames = [];
          var smoothScrollThis = _smoothScrollingEnabled;
          var edgeStrategy = _edgeStrategy;
          var emitEvents = false;
          if (ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {
              delete el[SKROLLABLE_ID_DOM_PROPERTY]
          }
          if (!el.attributes) {
              continue
          }
          var attributeIndex = 0;
          var attributesLength = el.attributes.length;
          for (; attributeIndex < attributesLength; attributeIndex++) {
              var attr = el.attributes[attributeIndex];
              if (attr.name === "data-anchor-target") {
                  anchorTarget = document.querySelector(attr.value);
                  if (anchorTarget === null) {
                      throw 'Unable to find anchor target "' + attr.value + '"'
                  }
                  continue
              }
              if (attr.name === "data-smooth-scrolling") {
                  smoothScrollThis = attr.value !== "off";
                  continue
              }
              if (attr.name === "data-edge-strategy") {
                  edgeStrategy = attr.value;
                  continue
              }
              if (attr.name === "data-emit-events") {
                  emitEvents = true;
                  continue
              }
              var match = attr.name.match(rxKeyframeAttribute);
              if (match === null) {
                  continue
              }
              var kf = {
                  props: attr.value,
                  element: el,
                  eventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)
              };
              keyFrames.push(kf);
              var constant = match[1];
              if (constant) {
                  kf.constant = constant.substr(1)
              }
              var offset = match[2];
              if (/p$/.test(offset)) {
                  kf.isPercentage = true;
                  kf.offset = (offset.slice(0, -1) | 0) / 100
              } else {
                  kf.offset = offset | 0
              }
              var anchor1 = match[3];
              var anchor2 = match[4] || anchor1;
              if (!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {
                  kf.mode = "absolute";
                  if (anchor1 === ANCHOR_END) {
                      kf.isEnd = true
                  } else if (!kf.isPercentage) {
                      kf.offset = kf.offset * _scale
                  }
              } else {
                  kf.mode = "relative";
                  kf.anchors = [anchor1, anchor2]
              }
          }
          if (!keyFrames.length) {
              continue
          }
          var styleAttr, classAttr;
          var id;
          if (!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {
              id = el[SKROLLABLE_ID_DOM_PROPERTY];
              styleAttr = _skrollables[id].styleAttr;
              classAttr = _skrollables[id].classAttr
          } else {
              id = el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++;
              styleAttr = el.style.cssText;
              classAttr = _getClass(el)
          }
          _skrollables[id] = {
              element: el,
              styleAttr: styleAttr,
              classAttr: classAttr,
              anchorTarget: anchorTarget,
              keyFrames: keyFrames,
              smoothScrolling: smoothScrollThis,
              edgeStrategy: edgeStrategy,
              emitEvents: emitEvents,
              lastFrameIndex: -1
          };
          _updateClass(el, [SKROLLABLE_CLASS], [])
      }
      _reflow();
      elementIndex = 0;
      elementsLength = elements.length;
      for (; elementIndex < elementsLength; elementIndex++) {
          var sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];
          if (sk === undefined) {
              continue
          }
          _parseProps(sk);
          _fillProps(sk)
      }
      return _instance
  };
  Skrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {
      var viewportHeight = documentElement.clientHeight;
      var box = element.getBoundingClientRect();
      var absolute = box.top;
      var boxHeight = box.bottom - box.top;
      if (viewportAnchor === ANCHOR_BOTTOM) {
          absolute -= viewportHeight
      } else if (viewportAnchor === ANCHOR_CENTER) {
          absolute -= viewportHeight / 2
      }
      if (elementAnchor === ANCHOR_BOTTOM) {
          absolute += boxHeight
      } else if (elementAnchor === ANCHOR_CENTER) {
          absolute += boxHeight / 2
      }
      absolute += _instance.getScrollTop();
      return absolute + .5 | 0
  };
  Skrollr.prototype.animateTo = function(top, options) {
      options = options || {};
      var now = _now();
      var scrollTop = _instance.getScrollTop();
      var duration = options.duration === undefined ? DEFAULT_DURATION : options.duration;
      _scrollAnimation = {
          startTop: scrollTop,
          topDiff: top - scrollTop,
          targetTop: top,
          duration: duration,
          startTime: now,
          endTime: now + duration,
          easing: easings[options.easing || DEFAULT_EASING],
          done: options.done
      };
      if (!_scrollAnimation.topDiff) {
          if (_scrollAnimation.done) {
              _scrollAnimation.done.call(_instance, false)
          }
          _scrollAnimation = undefined
      }
      return _instance
  };
  Skrollr.prototype.stopAnimateTo = function() {
      if (_scrollAnimation && _scrollAnimation.done) {
          _scrollAnimation.done.call(_instance, true)
      }
      _scrollAnimation = undefined
  };
  Skrollr.prototype.isAnimatingTo = function() {
      return !!_scrollAnimation
  };
  Skrollr.prototype.isMobile = function() {
      return _isMobile
  };
  Skrollr.prototype.setScrollTop = function(top, force) {
      _forceRender = force === true;
      if (_isMobile) {
          _mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame)
      } else {
          window.scrollTo(0, top)
      }
      return _instance
  };
  Skrollr.prototype.getScrollTop = function() {
      if (_isMobile) {
          return _mobileOffset
      } else {
          return window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0
      }
  };
  Skrollr.prototype.getMaxScrollTop = function() {
      return _maxKeyFrame
  };
  Skrollr.prototype.on = function(name, fn) {
      _listeners[name] = fn;
      return _instance
  };
  Skrollr.prototype.off = function(name) {
      delete _listeners[name];
      return _instance
  };
  Skrollr.prototype.destroy = function() {
      var cancelAnimFrame = polyfillCAF();
      cancelAnimFrame(_animFrame);
      _removeAllEvents();
      _updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);
      var skrollableIndex = 0;
      var skrollablesLength = _skrollables.length;
      for (; skrollableIndex < skrollablesLength; skrollableIndex++) {
          _reset(_skrollables[skrollableIndex].element)
      }
      documentElement.style.overflow = body.style.overflow = "";
      documentElement.style.height = body.style.height = "";
      if (_skrollrBody) {
          skrollr.setStyle(_skrollrBody, "transform", "none")
      }
      _instance = undefined;
      _skrollrBody = undefined;
      _listeners = undefined;
      _forceHeight = undefined;
      _maxKeyFrame = 0;
      _scale = 1;
      _constants = undefined;
      _mobileDeceleration = undefined;
      _direction = "down";
      _lastTop = -1;
      _lastViewportWidth = 0;
      _lastViewportHeight = 0;
      _requestReflow = false;
      _scrollAnimation = undefined;
      _smoothScrollingEnabled = undefined;
      _smoothScrollingDuration = undefined;
      _smoothScrolling = undefined;
      _forceRender = undefined;
      _skrollableIdCounter = 0;
      _edgeStrategy = undefined;
      _isMobile = false;
      _mobileOffset = 0;
      _translateZ = undefined
  };
  var _initMobile = function() {
      var initialElement;
      var initialTouchY;
      var initialTouchX;
      var currentElement;
      var currentTouchY;
      var currentTouchX;
      var lastTouchY;
      var deltaY;
      var initialTouchTime;
      var currentTouchTime;
      var lastTouchTime;
      var deltaTime;
      _addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(" "), function(e) {
          var touch = e.changedTouches[0];
          currentElement = e.target;
          while (currentElement.nodeType === 3) {
              currentElement = currentElement.parentNode
          }
          currentTouchY = touch.clientY;
          currentTouchX = touch.clientX;
          currentTouchTime = e.timeStamp;
          if (!rxTouchIgnoreTags.test(currentElement.tagName)) {
              e.preventDefault()
          }
          switch (e.type) {
              case EVENT_TOUCHSTART:
                  if (initialElement) {
                      initialElement.blur()
                  }
                  _instance.stopAnimateTo();
                  initialElement = currentElement;
                  initialTouchY = lastTouchY = currentTouchY;
                  initialTouchX = currentTouchX;
                  initialTouchTime = currentTouchTime;
                  break;
              case EVENT_TOUCHMOVE:
                  if (rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {
                      e.preventDefault()
                  }
                  deltaY = currentTouchY - lastTouchY;
                  deltaTime = currentTouchTime - lastTouchTime;
                  _instance.setScrollTop(_mobileOffset - deltaY, true);
                  lastTouchY = currentTouchY;
                  lastTouchTime = currentTouchTime;
                  break;
              default:
              case EVENT_TOUCHCANCEL:
              case EVENT_TOUCHEND:
                  var distanceY = initialTouchY - currentTouchY;
                  var distanceX = initialTouchX - currentTouchX;
                  var distance2 = distanceX * distanceX + distanceY * distanceY;
                  if (distance2 < 49) {
                      if (!rxTouchIgnoreTags.test(initialElement.tagName)) {
                          initialElement.focus();
                          var clickEvent = document.createEvent("MouseEvents");
                          clickEvent.initMouseEvent("click", true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
                          initialElement.dispatchEvent(clickEvent)
                      }
                      return
                  }
                  initialElement = undefined;
                  var speed = deltaY / deltaTime;
                  speed = Math.max(Math.min(speed, 3), -3);
                  var duration = Math.abs(speed / _mobileDeceleration);
                  var targetOffset = speed * duration + .5 * _mobileDeceleration * duration * duration;
                  var targetTop = _instance.getScrollTop() - targetOffset;
                  var targetRatio = 0;
                  if (targetTop > _maxKeyFrame) {
                      targetRatio = (_maxKeyFrame - targetTop) / targetOffset;
                      targetTop = _maxKeyFrame
                  } else if (targetTop < 0) {
                      targetRatio = -targetTop / targetOffset;
                      targetTop = 0
                  }
                  duration = duration * (1 - targetRatio);
                  _instance.animateTo(targetTop + .5 | 0, {
                      easing: "outCubic",
                      duration: duration
                  });
                  break
          }
      });
      window.scrollTo(0, 0);
      documentElement.style.overflow = body.style.overflow = "hidden"
  };
  var _updateDependentKeyFrames = function() {
      var viewportHeight = documentElement.clientHeight;
      var processedConstants = _processConstants();
      var skrollable;
      var element;
      var anchorTarget;
      var keyFrames;
      var keyFrameIndex;
      var keyFramesLength;
      var kf;
      var skrollableIndex;
      var skrollablesLength;
      var offset;
      var constantValue;
      skrollableIndex = 0;
      skrollablesLength = _skrollables.length;
      for (; skrollableIndex < skrollablesLength; skrollableIndex++) {
          skrollable = _skrollables[skrollableIndex];
          element = skrollable.element;
          anchorTarget = skrollable.anchorTarget;
          keyFrames = skrollable.keyFrames;
          keyFrameIndex = 0;
          keyFramesLength = keyFrames.length;
          for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
              kf = keyFrames[keyFrameIndex];
              offset = kf.offset;
              constantValue = processedConstants[kf.constant] || 0;
              kf.frame = offset;
              if (kf.isPercentage) {
                  offset = offset * viewportHeight;
                  kf.frame = offset
              }
              if (kf.mode === "relative") {
                  _reset(element);
                  kf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;
                  _reset(element, true)
              }
              kf.frame += constantValue;
              if (_forceHeight) {
                  if (!kf.isEnd && kf.frame > _maxKeyFrame) {
                      _maxKeyFrame = kf.frame
                  }
              }
          }
      }
      _maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight());
      skrollableIndex = 0;
      skrollablesLength = _skrollables.length;
      for (; skrollableIndex < skrollablesLength; skrollableIndex++) {
          skrollable = _skrollables[skrollableIndex];
          keyFrames = skrollable.keyFrames;
          keyFrameIndex = 0;
          keyFramesLength = keyFrames.length;
          for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
              kf = keyFrames[keyFrameIndex];
              constantValue = processedConstants[kf.constant] || 0;
              if (kf.isEnd) {
                  kf.frame = _maxKeyFrame - kf.offset + constantValue
              }
          }
          skrollable.keyFrames.sort(_keyFrameComparator)
      }
  };
  var _calcSteps = function(fakeFrame, actualFrame) {
      var skrollableIndex = 0;
      var skrollablesLength = _skrollables.length;
      for (; skrollableIndex < skrollablesLength; skrollableIndex++) {
          var skrollable = _skrollables[skrollableIndex];
          var element = skrollable.element;
          var frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;
          var frames = skrollable.keyFrames;
          var framesLength = frames.length;
          var firstFrame = frames[0];
          var lastFrame = frames[frames.length - 1];
          var beforeFirst = frame < firstFrame.frame;
          var afterLast = frame > lastFrame.frame;
          var firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;
          var emitEvents = skrollable.emitEvents;
          var lastFrameIndex = skrollable.lastFrameIndex;
          var key;
          var value;
          if (beforeFirst || afterLast) {
              if (beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {
                  continue
              }
              if (beforeFirst) {
                  _updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]);
                  if (emitEvents && lastFrameIndex > -1) {
                      _emitEvent(element, firstFrame.eventType, _direction);
                      skrollable.lastFrameIndex = -1
                  }
              } else {
                  _updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]);
                  if (emitEvents && lastFrameIndex < framesLength) {
                      _emitEvent(element, lastFrame.eventType, _direction);
                      skrollable.lastFrameIndex = framesLength
                  }
              }
              skrollable.edge = beforeFirst ? -1 : 1;
              switch (skrollable.edgeStrategy) {
                  case "reset":
                      _reset(element);
                      continue;
                  case "ease":
                      frame = firstOrLastFrame.frame;
                      break;
                  default:
                  case "set":
                      var props = firstOrLastFrame.props;
                      for (key in props) {
                          if (hasProp.call(props, key)) {
                              value = _interpolateString(props[key].value);
                              if (key.indexOf("@") === 0) {
                                  element.setAttribute(key.substr(1), value)
                              } else {
                                  skrollr.setStyle(element, key, value)
                              }
                          }
                      }
                      continue
              }
          } else {
              if (skrollable.edge !== 0) {
                  _updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);
                  skrollable.edge = 0
              }
          }
          var keyFrameIndex = 0;
          for (; keyFrameIndex < framesLength - 1; keyFrameIndex++) {
              if (frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {
                  var left = frames[keyFrameIndex];
                  var right = frames[keyFrameIndex + 1];
                  for (key in left.props) {
                      if (hasProp.call(left.props, key)) {
                          var progress = (frame - left.frame) / (right.frame - left.frame);
                          progress = left.props[key].easing(progress);
                          value = _calcInterpolation(left.props[key].value, right.props[key].value, progress);
                          value = _interpolateString(value);
                          if (key.indexOf("@") === 0) {
                              element.setAttribute(key.substr(1), value)
                          } else {
                              skrollr.setStyle(element, key, value)
                          }
                      }
                  }
                  if (emitEvents) {
                      if (lastFrameIndex !== keyFrameIndex) {
                          if (_direction === "down") {
                              _emitEvent(element, left.eventType, _direction)
                          } else {
                              _emitEvent(element, right.eventType, _direction)
                          }
                          skrollable.lastFrameIndex = keyFrameIndex
                      }
                  }
                  break
              }
          }
      }
  };
  var _render = function() {
      if (_requestReflow) {
          _requestReflow = false;
          _reflow()
      }
      var renderTop = _instance.getScrollTop();
      var afterAnimationCallback;
      var now = _now();
      var progress;
      if (_scrollAnimation) {
          if (now >= _scrollAnimation.endTime) {
              renderTop = _scrollAnimation.targetTop;
              afterAnimationCallback = _scrollAnimation.done;
              _scrollAnimation = undefined
          } else {
              progress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);
              renderTop = _scrollAnimation.startTop + progress * _scrollAnimation.topDiff | 0
          }
          _instance.setScrollTop(renderTop, true)
      } else if (!_forceRender) {
          var smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;
          if (smoothScrollingDiff) {
              _smoothScrolling = {
                  startTop: _lastTop,
                  topDiff: renderTop - _lastTop,
                  targetTop: renderTop,
                  startTime: _lastRenderCall,
                  endTime: _lastRenderCall + _smoothScrollingDuration
              }
          }
          if (now <= _smoothScrolling.endTime) {
              progress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);
              renderTop = _smoothScrolling.startTop + progress * _smoothScrolling.topDiff | 0
          }
      }
      if (_forceRender || _lastTop !== renderTop) {
          _direction = renderTop > _lastTop ? "down" : renderTop < _lastTop ? "up" : _direction;
          _forceRender = false;
          var listenerParams = {
              curTop: renderTop,
              lastTop: _lastTop,
              maxTop: _maxKeyFrame,
              direction: _direction
          };
          var continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams);
          if (continueRendering !== false) {
              _calcSteps(renderTop, _instance.getScrollTop());
              if (_isMobile && _skrollrBody) {
                  skrollr.setStyle(_skrollrBody, "transform", "translate(0, " + -_mobileOffset + "px) " + _translateZ)
              }
              _lastTop = renderTop;
              if (_listeners.render) {
                  _listeners.render.call(_instance, listenerParams)
              }
          }
          if (afterAnimationCallback) {
              afterAnimationCallback.call(_instance, false)
          }
      }
      _lastRenderCall = now
  };
  var _parseProps = function(skrollable) {
      var keyFrameIndex = 0;
      var keyFramesLength = skrollable.keyFrames.length;
      for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
          var frame = skrollable.keyFrames[keyFrameIndex];
          var easing;
          var value;
          var prop;
          var props = {};
          var match;
          while ((match = rxPropValue.exec(frame.props)) !== null) {
              prop = match[1];
              value = match[2];
              easing = prop.match(rxPropEasing);
              if (easing !== null) {
                  prop = easing[1];
                  easing = easing[2]
              } else {
                  easing = DEFAULT_EASING
              }
              value = value.indexOf("!") ? _parseProp(value) : [value.slice(1)];
              props[prop] = {
                  value: value,
                  easing: easings[easing]
              }
          }
          frame.props = props
      }
  };
  var _parseProp = function(val) {
      var numbers = [];
      rxRGBAIntegerColor.lastIndex = 0;
      val = val.replace(rxRGBAIntegerColor, function(rgba) {
          return rgba.replace(rxNumericValue, function(n) {
              return n / 255 * 100 + "%"
          })
      });
      if (theDashedCSSPrefix) {
          rxGradient.lastIndex = 0;
          val = val.replace(rxGradient, function(s) {
              return theDashedCSSPrefix + s
          })
      }
      val = val.replace(rxNumericValue, function(n) {
          numbers.push(+n);
          return "{?}"
      });
      numbers.unshift(val);
      return numbers
  };
  var _fillProps = function(sk) {
      var propList = {};
      var keyFrameIndex;
      var keyFramesLength;
      keyFrameIndex = 0;
      keyFramesLength = sk.keyFrames.length;
      for (; keyFrameIndex < keyFramesLength; keyFrameIndex++) {
          _fillPropForFrame(sk.keyFrames[keyFrameIndex], propList)
      }
      propList = {};
      keyFrameIndex = sk.keyFrames.length - 1;
      for (; keyFrameIndex >= 0; keyFrameIndex--) {
          _fillPropForFrame(sk.keyFrames[keyFrameIndex], propList)
      }
  };
  var _fillPropForFrame = function(frame, propList) {
      var key;
      for (key in propList) {
          if (!hasProp.call(frame.props, key)) {
              frame.props[key] = propList[key]
          }
      }
      for (key in frame.props) {
          propList[key] = frame.props[key]
      }
  };
  var _calcInterpolation = function(val1, val2, progress) {
      var valueIndex;
      var val1Length = val1.length;
      if (val1Length !== val2.length) {
          throw "Can't interpolate between \"" + val1[0] + '" and "' + val2[0] + '"'
      }
      var interpolated = [val1[0]];
      valueIndex = 1;
      for (; valueIndex < val1Length; valueIndex++) {
          interpolated[valueIndex] = val1[valueIndex] + (val2[valueIndex] - val1[valueIndex]) * progress
      }
      return interpolated
  };
  var _interpolateString = function(val) {
      var valueIndex = 1;
      rxInterpolateString.lastIndex = 0;
      return val[0].replace(rxInterpolateString, function() {
          return val[valueIndex++]
      })
  };
  var _reset = function(elements, undo) {
      elements = [].concat(elements);
      var skrollable;
      var element;
      var elementsIndex = 0;
      var elementsLength = elements.length;
      for (; elementsIndex < elementsLength; elementsIndex++) {
          element = elements[elementsIndex];
          skrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]];
          if (!skrollable) {
              continue
          }
          if (undo) {
              element.style.cssText = skrollable.dirtyStyleAttr;
              _updateClass(element, skrollable.dirtyClassAttr)
          } else {
              skrollable.dirtyStyleAttr = element.style.cssText;
              skrollable.dirtyClassAttr = _getClass(element);
              element.style.cssText = skrollable.styleAttr;
              _updateClass(element, skrollable.classAttr)
          }
      }
  };
  var _detect3DTransforms = function() {
      _translateZ = "translateZ(0)";
      skrollr.setStyle(_skrollrBody, "transform", _translateZ);
      var computedStyle = getStyle(_skrollrBody);
      var computedTransform = computedStyle.getPropertyValue("transform");
      var computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + "transform");
      var has3D = computedTransform && computedTransform !== "none" || computedTransformWithPrefix && computedTransformWithPrefix !== "none";
      if (!has3D) {
          _translateZ = ""
      }
  };
  skrollr.setStyle = function(el, prop, val) {
      var style = el.style;
      prop = prop.replace(rxCamelCase, rxCamelCaseFn).replace("-", "");
      if (prop === "zIndex") {
          if (isNaN(val)) {
              style[prop] = val
          } else {
              style[prop] = "" + (val | 0)
          }
      } else if (prop === "float") {
          style.styleFloat = style.cssFloat = val
      } else {
          try {
              if (theCSSPrefix) {
                  style[theCSSPrefix + prop.slice(0, 1).toUpperCase() + prop.slice(1)] = val
              }
              style[prop] = val
          } catch (ignore) {}
      }
  };
  var _addEvent = skrollr.addEvent = function(element, names, callback) {
      var intermediate = function(e) {
          e = e || window.event;
          if (!e.target) {
              e.target = e.srcElement
          }
          if (!e.preventDefault) {
              e.preventDefault = function() {
                  e.returnValue = false;
                  e.defaultPrevented = true
              }
          }
          return callback.call(this, e)
      };
      names = names.split(" ");
      var name;
      var nameCounter = 0;
      var namesLength = names.length;
      for (; nameCounter < namesLength; nameCounter++) {
          name = names[nameCounter];
          if (element.addEventListener) {
              element.addEventListener(name, callback, false)
          } else {
              element.attachEvent("on" + name, intermediate)
          }
          _registeredEvents.push({
              element: element,
              name: name,
              listener: callback
          })
      }
  };
  var _removeEvent = skrollr.removeEvent = function(element, names, callback) {
      names = names.split(" ");
      var nameCounter = 0;
      var namesLength = names.length;
      for (; nameCounter < namesLength; nameCounter++) {
          if (element.removeEventListener) {
              element.removeEventListener(names[nameCounter], callback, false)
          } else {
              element.detachEvent("on" + names[nameCounter], callback)
          }
      }
  };
  var _removeAllEvents = function() {
      var eventData;
      var eventCounter = 0;
      var eventsLength = _registeredEvents.length;
      for (; eventCounter < eventsLength; eventCounter++) {
          eventData = _registeredEvents[eventCounter];
          _removeEvent(eventData.element, eventData.name, eventData.listener)
      }
      _registeredEvents = []
  };
  var _emitEvent = function(element, name, direction) {
      if (_listeners.keyframe) {
          _listeners.keyframe.call(_instance, element, name, direction)
      }
  };
  var _reflow = function() {
      var pos = _instance.getScrollTop();
      _maxKeyFrame = 0;
      if (_forceHeight && !_isMobile) {
          body.style.height = ""
      }
      _updateDependentKeyFrames();
      if (_forceHeight && !_isMobile) {
          body.style.height = _maxKeyFrame + documentElement.clientHeight + "px"
      }
      if (_isMobile) {
          _instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame))
      } else {
          _instance.setScrollTop(pos, true)
      }
      _forceRender = true
  };
  var _processConstants = function() {
      var viewportHeight = documentElement.clientHeight;
      var copy = {};
      var prop;
      var value;
      for (prop in _constants) {
          value = _constants[prop];
          if (typeof value === "function") {
              value = value.call(_instance)
          } else if (/p$/.test(value)) {
              value = value.slice(0, -1) / 100 * viewportHeight
          }
          copy[prop] = value
      }
      return copy
  };
  var _getDocumentHeight = function() {
      var skrollrBodyHeight = 0;
      var bodyHeight;
      if (_skrollrBody) {
          skrollrBodyHeight = Math.max(_skrollrBody.offsetHeight, _skrollrBody.scrollHeight)
      }
      bodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);
      return bodyHeight - documentElement.clientHeight
  };
  var _getClass = function(element) {
      var prop = "className";
      if (window.SVGElement && element instanceof window.SVGElement) {
          element = element[prop];
          prop = "baseVal"
      }
      return element[prop]
  };
  var _updateClass = function(element, add, remove) {
      var prop = "className";
      if (window.SVGElement && element instanceof window.SVGElement) {
          element = element[prop];
          prop = "baseVal"
      }
      if (remove === undefined) {
          element[prop] = add;
          return
      }
      var val = element[prop];
      var classRemoveIndex = 0;
      var removeLength = remove.length;
      for (; classRemoveIndex < removeLength; classRemoveIndex++) {
          val = _untrim(val).replace(_untrim(remove[classRemoveIndex]), " ")
      }
      val = _trim(val);
      var classAddIndex = 0;
      var addLength = add.length;
      for (; classAddIndex < addLength; classAddIndex++) {
          if (_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {
              val += " " + add[classAddIndex]
          }
      }
      element[prop] = _trim(val)
  };
  var _trim = function(a) {
      return a.replace(rxTrim, "")
  };
  var _untrim = function(a) {
      return " " + a + " "
  };
  var _now = Date.now || function() {
      return +new Date
  };
  var _keyFrameComparator = function(a, b) {
      return a.frame - b.frame
  };
  var _instance;
  var _skrollables;
  var _skrollrBody;
  var _listeners;
  var _forceHeight;
  var _maxKeyFrame = 0;
  var _scale = 1;
  var _constants;
  var _mobileDeceleration;
  var _direction = "down";
  var _lastTop = -1;
  var _lastRenderCall = _now();
  var _lastViewportWidth = 0;
  var _lastViewportHeight = 0;
  var _requestReflow = false;
  var _scrollAnimation;
  var _smoothScrollingEnabled;
  var _smoothScrollingDuration;
  var _smoothScrolling;
  var _forceRender;
  var _skrollableIdCounter = 0;
  var _edgeStrategy;
  var _isMobile = false;
  var _mobileOffset = 0;
  var _translateZ;
  var _registeredEvents = [];
  var _animFrame;
  if (typeof define === "function" && define.amd) {
      define([], function() {
          return skrollr
      })
  } else if (typeof module !== "undefined" && module.exports) {
      module.exports = skrollr
  } else {
      window.skrollr = skrollr
  }
})(window, document);
(function(factory) {
  if (typeof define === "function" && define.amd) {
      define(["jquery"], factory)
  } else if (typeof module === "object" && module.exports) {
      factory(require("jquery"))
  } else {
      factory(jQuery)
  }
})(function($) {
  var version = "2.2.0";
  var optionOverrides = {};
  var defaults = {
      exclude: [],
      excludeWithin: [],
      offset: 0,
      direction: "top",
      delegateSelector: null,
      scrollElement: null,
      scrollTarget: null,
      autoFocus: false,
      beforeScroll: function() {},
      afterScroll: function() {},
      easing: "swing",
      speed: 400,
      autoCoefficient: 2,
      preventDefault: true
  };
  var getScrollable = function(opts) {
      var scrollable = [];
      var scrolled = false;
      var dir = opts.dir && opts.dir === "left" ? "scrollLeft" : "scrollTop";
      this.each(function() {
          var el = $(this);
          if (this === document || this === window) {
              return
          }
          if (document.scrollingElement && (this === document.documentElement || this === document.body)) {
              scrollable.push(document.scrollingElement);
              return false
          }
          if (el[dir]() > 0) {
              scrollable.push(this)
          } else {
              el[dir](1);
              scrolled = el[dir]() > 0;
              if (scrolled) {
                  scrollable.push(this)
              }
              el[dir](0)
          }
      });
      if (!scrollable.length) {
          this.each(function() {
              if (this === document.documentElement && $(this).css("scrollBehavior") === "smooth") {
                  scrollable = [this]
              }
              if (!scrollable.length && this.nodeName === "BODY") {
                  scrollable = [this]
              }
          })
      }
      if (opts.el === "first" && scrollable.length > 1) {
          scrollable = [scrollable[0]]
      }
      return scrollable
  };
  var rRelative = /^([\-\+]=)(\d+)/;
  $.fn.extend({
      scrollable: function(dir) {
          var scrl = getScrollable.call(this, {
              dir: dir
          });
          return this.pushStack(scrl)
      },
      firstScrollable: function(dir) {
          var scrl = getScrollable.call(this, {
              el: "first",
              dir: dir
          });
          return this.pushStack(scrl)
      },
      smoothScroll: function(options, extra) {
          options = options || {};
          if (options === "options") {
              if (!extra) {
                  return this.first().data("ssOpts")
              }
              return this.each(function() {
                  var $this = $(this);
                  var opts = $.extend($this.data("ssOpts") || {}, extra);
                  $(this).data("ssOpts", opts)
              })
          }
          var opts = $.extend({}, $.fn.smoothScroll.defaults, options);
          var clickHandler = function(event) {
              var escapeSelector = function(str) {
                  return str.replace(/(:|\.|\/)/g, "\\$1")
              };
              var link = this;
              var $link = $(this);
              var thisOpts = $.extend({}, opts, $link.data("ssOpts") || {});
              var exclude = opts.exclude;
              var excludeWithin = thisOpts.excludeWithin;
              var elCounter = 0;
              var ewlCounter = 0;
              var include = true;
              var clickOpts = {};
              var locationPath = $.smoothScroll.filterPath(location.pathname);
              var linkPath = $.smoothScroll.filterPath(link.pathname);
              var hostMatch = location.hostname === link.hostname || !link.hostname;
              var pathMatch = thisOpts.scrollTarget || linkPath === locationPath;
              var thisHash = escapeSelector(link.hash);
              if (thisHash && !$(thisHash).length) {
                  include = false
              }
              if (!thisOpts.scrollTarget && (!hostMatch || !pathMatch || !thisHash)) {
                  include = false
              } else {
                  while (include && elCounter < exclude.length) {
                      if ($link.is(escapeSelector(exclude[elCounter++]))) {
                          include = false
                      }
                  }
                  while (include && ewlCounter < excludeWithin.length) {
                      if ($link.closest(excludeWithin[ewlCounter++]).length) {
                          include = false
                      }
                  }
              }
              if (include) {
                  if (thisOpts.preventDefault) {
                      event.preventDefault()
                  }
                  $.extend(clickOpts, thisOpts, {
                      scrollTarget: thisOpts.scrollTarget || thisHash,
                      link: link
                  });
                  $.smoothScroll(clickOpts)
              }
          };
          if (options.delegateSelector !== null) {
              this.off("click.smoothscroll", options.delegateSelector).on("click.smoothscroll", options.delegateSelector, clickHandler)
          } else {
              this.off("click.smoothscroll").on("click.smoothscroll", clickHandler)
          }
          return this
      }
  });
  var getExplicitOffset = function(val) {
      var explicit = {
          relative: ""
      };
      var parts = typeof val === "string" && rRelative.exec(val);
      if (typeof val === "number") {
          explicit.px = val
      } else if (parts) {
          explicit.relative = parts[1];
          explicit.px = parseFloat(parts[2]) || 0
      }
      return explicit
  };
  var onAfterScroll = function(opts) {
      var $tgt = $(opts.scrollTarget);
      if (opts.autoFocus && $tgt.length) {
          $tgt[0].focus();
          if (!$tgt.is(document.activeElement)) {
              $tgt.prop({
                  tabIndex: -1
              });
              $tgt[0].focus()
          }
      }
      opts.afterScroll.call(opts.link, opts)
  };
  $.smoothScroll = function(options, px) {
      if (options === "options" && typeof px === "object") {
          return $.extend(optionOverrides, px)
      }
      var opts, $scroller, speed, delta;
      var explicitOffset = getExplicitOffset(options);
      var scrollTargetOffset = {};
      var scrollerOffset = 0;
      var offPos = "offset";
      var scrollDir = "scrollTop";
      var aniProps = {};
      var aniOpts = {};
      if (explicitOffset.px) {
          opts = $.extend({
              link: null
          }, $.fn.smoothScroll.defaults, optionOverrides)
      } else {
          opts = $.extend({
              link: null
          }, $.fn.smoothScroll.defaults, options || {}, optionOverrides);
          if (opts.scrollElement) {
              offPos = "position";
              if (opts.scrollElement.css("position") === "static") {
                  opts.scrollElement.css("position", "relative")
              }
          }
          if (px) {
              explicitOffset = getExplicitOffset(px)
          }
      }
      scrollDir = opts.direction === "left" ? "scrollLeft" : scrollDir;
      if (opts.scrollElement) {
          $scroller = opts.scrollElement;
          if (!explicitOffset.px && !/^(?:HTML|BODY)$/.test($scroller[0].nodeName)) {
              scrollerOffset = $scroller[scrollDir]()
          }
      } else {
          $scroller = $("html, body").firstScrollable(opts.direction)
      }
      opts.beforeScroll.call($scroller, opts);
      scrollTargetOffset = explicitOffset.px ? explicitOffset : {
          relative: "",
          px: $(opts.scrollTarget)[offPos]() && $(opts.scrollTarget)[offPos]()[opts.direction] || 0
      };
      aniProps[scrollDir] = scrollTargetOffset.relative + (scrollTargetOffset.px + scrollerOffset + opts.offset);
      speed = opts.speed;
      if (speed === "auto") {
          delta = Math.abs(aniProps[scrollDir] - $scroller[scrollDir]());
          speed = delta / opts.autoCoefficient
      }
      aniOpts = {
          duration: speed,
          easing: opts.easing,
          complete: function() {
              onAfterScroll(opts)
          }
      };
      if (opts.step) {
          aniOpts.step = opts.step
      }
      if ($scroller.length) {
          $scroller.stop().animate(aniProps, aniOpts)
      } else {
          onAfterScroll(opts)
      }
  };
  $.smoothScroll.version = version;
  $.smoothScroll.filterPath = function(string) {
      string = string || "";
      return string.replace(/^\//, "").replace(/(?:index|default).[a-zA-Z]{3,4}$/, "").replace(/\/$/, "")
  };
  $.fn.smoothScroll.defaults = defaults
});
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.Splitting = factory()
})(this, function() {
  "use strict";
  var root = document;
  var createText = root.createTextNode.bind(root);

  function setProperty(el, varName, value) {
      el.style.setProperty(varName, value)
  }

  function appendChild(el, child) {
      return el.appendChild(child)
  }

  function createElement(parent, key, text, whitespace) {
      var el = root.createElement("span");
      key && (el.className = key);
      if (text) {
          !whitespace && el.setAttribute("data-" + key, text);
          el.textContent = text
      }
      return parent && appendChild(parent, el) || el
  }

  function getData(el, key) {
      return el.getAttribute("data-" + key)
  }

  function $(e, parent) {
      return !e || e.length == 0 ? [] : e.nodeName ? [e] : [].slice.call(e[0].nodeName ? e : (parent || root).querySelectorAll(e))
  }

  function Array2D(len) {
      var a = [];
      for (; len--;) {
          a[len] = []
      }
      return a
  }

  function each(items, consumer) {
      items && items.some(consumer)
  }

  function selectFrom(obj) {
      return function(key) {
          return obj[key]
      }
  }

  function index(element, key, items) {
      var prefix = "--" + key;
      var cssVar = prefix + "-index";
      each(items, function(items, i) {
          if (Array.isArray(items)) {
              each(items, function(item) {
                  setProperty(item, cssVar, i)
              })
          } else {
              setProperty(items, cssVar, i)
          }
      });
      setProperty(element, prefix + "-total", items.length)
  }
  var plugins = {};

  function resolvePlugins(by, parent, deps) {
      var index = deps.indexOf(by);
      if (index == -1) {
          deps.unshift(by);
          var plugin = plugins[by];
          if (!plugin) {
              throw new Error("plugin not loaded: " + by)
          }
          each(plugin.depends, function(p) {
              resolvePlugins(p, by, deps)
          })
      } else {
          var indexOfParent = deps.indexOf(parent);
          deps.splice(index, 1);
          deps.splice(indexOfParent, 0, by)
      }
      return deps
  }

  function createPlugin(by, depends, key, split) {
      return {
          by: by,
          depends: depends,
          key: key,
          split: split
      }
  }

  function resolve(by) {
      return resolvePlugins(by, 0, []).map(selectFrom(plugins))
  }

  function add(opts) {
      plugins[opts.by] = opts
  }

  function splitText(el, key, splitOn, includePrevious, preserveWhitespace) {
      el.normalize();
      var elements = [];
      var F = document.createDocumentFragment();
      if (includePrevious) {
          elements.push(el.previousSibling)
      }
      var allElements = [];
      $(el.childNodes).some(function(next) {
          if (next.tagName && !next.hasChildNodes()) {
              allElements.push(next);
              return
          }
          if (next.childNodes && next.childNodes.length) {
              allElements.push(next);
              elements.push.apply(elements, splitText(next, key, splitOn, includePrevious, preserveWhitespace));
              return
          }
          var wholeText = next.wholeText || "";
          var contents = wholeText.trim();
          if (contents.length) {
              if (wholeText[0] === " ") {
                  allElements.push(createText("      "))
              }
              each(contents.split(splitOn), function(splitText, i) {
                  if (i && preserveWhitespace) {
                      allElements.push(createElement(F, "whitespace", " ", preserveWhitespace))
                  }
                  var splitEl = createElement(F, key, splitText);
                  elements.push(splitEl);
                  allElements.push(splitEl)
              });
              if (wholeText[wholeText.length - 1] === " ") {
                  allElements.push(createText(" "))
              }
          }
      });
      each(allElements, function(el) {
          appendChild(F, el)
      });
      el.innerHTML = "";
      appendChild(el, F);
      return elements
  }
  var _ = 0;

  function copy(dest, src) {
      for (var k in src) {
          dest[k] = src[k]
      }
      return dest
  }
  var WORDS = "words";
  var wordPlugin = createPlugin(WORDS, _, "word", function(el) {
      return splitText(el, "word", /\s+/, 0, 1)
  });
  var CHARS = "chars";
  var charPlugin = createPlugin(CHARS, [WORDS], "char", function(el, options, ctx) {
      var results = [];
      each(ctx[WORDS], function(word, i) {
          results.push.apply(results, splitText(word, "char", "", options.whitespace && i))
      });
      return results
  });

  function Splitting(opts) {
      opts = opts || {};
      var key = opts.key;
      return $(opts.target || "[data-splitting]").map(function(el) {
          var ctx = el[""];
          if (!opts.force && ctx) {
              return ctx
          }
          ctx = el[""] = {
              el: el
          };
          var by = opts.by || getData(el, "splitting");
          if (!by || by == "true") {
              by = CHARS
          }
          var items = resolve(by);
          var opts2 = copy({}, opts);
          each(items, function(plugin) {
              if (plugin.split) {
                  var pluginBy = plugin.by;
                  var key2 = (key ? "-" + key : "") + plugin.key;
                  var results = plugin.split(el, opts2, ctx);
                  key2 && index(el, key2, results);
                  ctx[pluginBy] = results;
                  el.classList.add(pluginBy)
              }
          });
          el.classList.add("splitting");
          return ctx
      })
  }

  function html(opts) {
      opts = opts || {};
      var parent = opts.target = createElement();
      parent.innerHTML = opts.content;
      Splitting(opts);
      return parent.outerHTML
  }
  Splitting.html = html;
  Splitting.add = add;

  function detectGrid(el, options, side) {
      var items = $(options.matching || el.children, el);
      var c = {};
      each(items, function(w) {
          var val = Math.round(w[side]);
          (c[val] || (c[val] = [])).push(w)
      });
      return Object.keys(c).map(Number).sort(byNumber).map(selectFrom(c))
  }

  function byNumber(a, b) {
      return a - b
  }
  var linePlugin = createPlugin("lines", [WORDS], "line", function(el, options, ctx) {
      return detectGrid(el, {
          matching: ctx[WORDS]
      }, "offsetTop")
  });
  var itemPlugin = createPlugin("items", _, "item", function(el, options) {
      return $(options.matching || el.children, el)
  });
  var rowPlugin = createPlugin("rows", _, "row", function(el, options) {
      return detectGrid(el, options, "offsetTop")
  });
  var columnPlugin = createPlugin("cols", _, "col", function(el, options) {
      return detectGrid(el, options, "offsetLeft")
  });
  var gridPlugin = createPlugin("grid", ["rows", "cols"]);
  var LAYOUT = "layout";
  var layoutPlugin = createPlugin(LAYOUT, _, _, function(el, opts) {
      var rows = opts.rows = +(opts.rows || getData(el, "rows") || 1);
      var columns = opts.columns = +(opts.columns || getData(el, "columns") || 1);
      opts.image = opts.image || getData(el, "image") || el.currentSrc || el.src;
      if (opts.image) {
          var img = $("img", el)[0];
          opts.image = img && (img.currentSrc || img.src)
      }
      if (opts.image) {
          setProperty(el, "background-image", "url(" + opts.image + ")")
      }
      var totalCells = rows * columns;
      var elements = [];
      var container = createElement(_, "cell-grid");
      while (totalCells--) {
          var cell = createElement(container, "cell");
          createElement(cell, "cell-inner");
          elements.push(cell)
      }
      appendChild(el, container);
      return elements
  });
  var cellRowPlugin = createPlugin("cellRows", [LAYOUT], "row", function(el, opts, ctx) {
      var rowCount = opts.rows;
      var result = Array2D(rowCount);
      each(ctx[LAYOUT], function(cell, i, src) {
          result[Math.floor(i / (src.length / rowCount))].push(cell)
      });
      return result
  });
  var cellColumnPlugin = createPlugin("cellColumns", [LAYOUT], "col", function(el, opts, ctx) {
      var columnCount = opts.columns;
      var result = Array2D(columnCount);
      each(ctx[LAYOUT], function(cell, i) {
          result[i % columnCount].push(cell)
      });
      return result
  });
  var cellPlugin = createPlugin("cells", ["cellRows", "cellColumns"], "cell", function(el, opt, ctx) {
      return ctx[LAYOUT]
  });
  add(wordPlugin);
  add(charPlugin);
  add(linePlugin);
  add(itemPlugin);
  add(rowPlugin);
  add(columnPlugin);
  add(gridPlugin);
  add(layoutPlugin);
  add(cellRowPlugin);
  add(cellColumnPlugin);
  add(cellPlugin);
  return Splitting
});
(function() {
  var $, win;
  $ = window.jQuery;
  win = $(window);
  $.fn.stick_in_parent = function(opts) {
      var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, outer_width, parent_selector, recalc_every, sticky_class;
      if (opts == null) {
          opts = {}
      }
      sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
      if (offset_top == null) {
          offset_top = 0
      }
      if (parent_selector == null) {
          parent_selector = void 0
      }
      if (inner_scrolling == null) {
          inner_scrolling = true
      }
      if (sticky_class == null) {
          sticky_class = "is_stuck"
      }
      doc = $(document);
      if (enable_bottoming == null) {
          enable_bottoming = true
      }
      outer_width = function(el) {
          var _el, computed, w;
          if (window.getComputedStyle) {
              _el = el[0];
              computed = window.getComputedStyle(el[0]);
              w = parseFloat(computed.getPropertyValue("width")) + parseFloat(computed.getPropertyValue("margin-left")) + parseFloat(computed.getPropertyValue("margin-right"));
              if (computed.getPropertyValue("box-sizing") !== "border-box") {
                  w += parseFloat(computed.getPropertyValue("border-left-width")) + parseFloat(computed.getPropertyValue("border-right-width")) + parseFloat(computed.getPropertyValue("padding-left")) + parseFloat(computed.getPropertyValue("padding-right"))
              }
              return w
          } else {
              return el.outerWidth(true)
          }
      };
      fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
          var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
          if (elm.data("sticky_kit")) {
              return
          }
          elm.data("sticky_kit", true);
          last_scroll_height = doc.height();
          parent = elm.parent();
          if (parent_selector != null) {
              parent = parent.closest(parent_selector)
          }
          if (!parent.length) {
              throw "failed to find stick parent"
          }
          fixed = false;
          bottomed = false;
          spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
          if (spacer) {
              spacer.css("position", elm.css("position"))
          }
          recalc = function() {
              var border_top, padding_top, restore;
              if (detached) {
                  return
              }
              last_scroll_height = doc.height();
              border_top = parseInt(parent.css("border-top-width"), 10);
              padding_top = parseInt(parent.css("padding-top"), 10);
              padding_bottom = parseInt(parent.css("padding-bottom"), 10);
              parent_top = parent.offset().top + border_top + padding_top;
              parent_height = parent.height();
              if (fixed) {
                  fixed = false;
                  bottomed = false;
                  if (manual_spacer == null) {
                      elm.insertAfter(spacer);
                      spacer.detach()
                  }
                  elm.css({
                      position: "",
                      top: "",
                      width: "",
                      bottom: ""
                  }).removeClass(sticky_class);
                  restore = true
              }
              top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
              height = elm.outerHeight(true);
              el_float = elm.css("float");
              if (spacer) {
                  spacer.css({
                      width: outer_width(elm),
                      height: height,
                      display: elm.css("display"),
                      "vertical-align": elm.css("vertical-align"),
                      "float": el_float
                  })
              }
              if (restore) {
                  return tick()
              }
          };
          recalc();
          if (height === parent_height) {
              return
          }
          last_pos = void 0;
          offset = offset_top;
          recalc_counter = recalc_every;
          tick = function() {
              var css, delta, recalced, scroll, will_bottom, win_height;
              if (detached) {
                  return
              }
              recalced = false;
              if (recalc_counter != null) {
                  recalc_counter -= 1;
                  if (recalc_counter <= 0) {
                      recalc_counter = recalc_every;
                      recalc();
                      recalced = true
                  }
              }
              if (!recalced && doc.height() !== last_scroll_height) {
                  recalc();
                  recalced = true
              }
              scroll = win.scrollTop();
              if (last_pos != null) {
                  delta = scroll - last_pos
              }
              last_pos = scroll;
              if (fixed) {
                  if (enable_bottoming) {
                      will_bottom = scroll + height + offset > parent_height + parent_top;
                      if (bottomed && !will_bottom) {
                          bottomed = false;
                          elm.css({
                              position: "fixed",
                              bottom: "",
                              top: offset
                          }).trigger("sticky_kit:unbottom")
                      }
                  }
                  if (scroll < top) {
                      fixed = false;
                      offset = offset_top;
                      if (manual_spacer == null) {
                          if (el_float === "left" || el_float === "right") {
                              elm.insertAfter(spacer)
                          }
                          spacer.detach()
                      }
                      css = {
                          position: "",
                          width: "",
                          top: ""
                      };
                      elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick")
                  }
                  if (inner_scrolling) {
                      win_height = win.height();
                      if (height + offset_top > win_height) {
                          if (!bottomed) {
                              offset -= delta;
                              offset = Math.max(win_height - height, offset);
                              offset = Math.min(offset_top, offset);
                              if (fixed) {
                                  elm.css({
                                      top: offset + "px"
                                  })
                              }
                          }
                      }
                  }
              } else {
                  if (scroll > top) {
                      fixed = true;
                      css = {
                          position: "fixed",
                          top: offset
                      };
                      css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
                      elm.css(css).addClass(sticky_class);
                      if (manual_spacer == null) {
                          elm.after(spacer);
                          if (el_float === "left" || el_float === "right") {
                              spacer.append(elm)
                          }
                      }
                      elm.trigger("sticky_kit:stick")
                  }
              }
              if (fixed && enable_bottoming) {
                  if (will_bottom == null) {
                      will_bottom = scroll + height + offset > parent_height + parent_top
                  }
                  if (!bottomed && will_bottom) {
                      bottomed = true;
                      if (parent.css("position") === "static") {
                          parent.css({
                              position: "relative"
                          })
                      }
                      return elm.css({
                          position: "absolute",
                          bottom: padding_bottom,
                          top: "auto"
                      }).trigger("sticky_kit:bottom")
                  }
              }
          };
          recalc_and_tick = function() {
              recalc();
              return tick()
          };
          detach = function() {
              detached = true;
              win.off("touchmove", tick);
              win.off("scroll", tick);
              win.off("resize", recalc_and_tick);
              $(document.body).off("sticky_kit:recalc", recalc_and_tick);
              elm.off("sticky_kit:detach", detach);
              elm.removeData("sticky_kit");
              elm.css({
                  position: "",
                  bottom: "",
                  top: "",
                  width: ""
              });
              parent.position("position", "");
              if (fixed) {
                  if (manual_spacer == null) {
                      if (el_float === "left" || el_float === "right") {
                          elm.insertAfter(spacer)
                      }
                      spacer.remove()
                  }
                  return elm.removeClass(sticky_class)
              }
          };
          win.on("touchmove", tick);
          win.on("scroll", tick);
          win.on("resize", recalc_and_tick);
          $(document.body).on("sticky_kit:recalc", recalc_and_tick);
          elm.on("sticky_kit:detach", detach);
          return setTimeout(tick, 0)
      };
      for (i = 0, len = this.length; i < len; i++) {
          elm = this[i];
          fn($(elm))
      }
      return this
  }
}).call(this);
var Swiper = function() {
  "use strict";

  function isObject$1(obj) {
      return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object
  }

  function extend$1(target, src) {
      if (target === void 0) {
          target = {}
      }
      if (src === void 0) {
          src = {}
      }
      Object.keys(src).forEach(key => {
          if (typeof target[key] === "undefined") target[key] = src[key];
          else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
              extend$1(target[key], src[key])
          }
      })
  }
  const ssrDocument = {
      body: {},
      addEventListener() {},
      removeEventListener() {},
      activeElement: {
          blur() {},
          nodeName: ""
      },
      querySelector() {
          return null
      },
      querySelectorAll() {
          return []
      },
      getElementById() {
          return null
      },
      createEvent() {
          return {
              initEvent() {}
          }
      },
      createElement() {
          return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute() {},
              getElementsByTagName() {
                  return []
              }
          }
      },
      createElementNS() {
          return {}
      },
      importNode() {
          return null
      },
      location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
      }
  };

  function getDocument() {
      const doc = typeof document !== "undefined" ? document : {};
      extend$1(doc, ssrDocument);
      return doc
  }
  const ssrWindow = {
      document: ssrDocument,
      navigator: {
          userAgent: ""
      },
      location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: ""
      },
      history: {
          replaceState() {},
          pushState() {},
          go() {},
          back() {}
      },
      CustomEvent: function CustomEvent() {
          return this
      },
      addEventListener() {},
      removeEventListener() {},
      getComputedStyle() {
          return {
              getPropertyValue() {
                  return ""
              }
          }
      },
      Image() {},
      Date() {},
      screen: {},
      setTimeout() {},
      clearTimeout() {},
      matchMedia() {
          return {}
      },
      requestAnimationFrame(callback) {
          if (typeof setTimeout === "undefined") {
              callback();
              return null
          }
          return setTimeout(callback, 0)
      },
      cancelAnimationFrame(id) {
          if (typeof setTimeout === "undefined") {
              return
          }
          clearTimeout(id)
      }
  };

  function getWindow() {
      const win = typeof window !== "undefined" ? window : {};
      extend$1(win, ssrWindow);
      return win
  }

  function classesToTokens(classes) {
      if (classes === void 0) {
          classes = ""
      }
      return classes.trim().split(" ").filter(c => !!c.trim())
  }

  function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach(key => {
          try {
              object[key] = null
          } catch (e) {}
          try {
              delete object[key]
          } catch (e) {}
      })
  }

  function nextTick(callback, delay) {
      if (delay === void 0) {
          delay = 0
      }
      return setTimeout(callback, delay)
  }

  function now() {
      return Date.now()
  }

  function getComputedStyle$1(el) {
      const window = getWindow();
      let style;
      if (window.getComputedStyle) {
          style = window.getComputedStyle(el, null)
      }
      if (!style && el.currentStyle) {
          style = el.currentStyle
      }
      if (!style) {
          style = el.style
      }
      return style
  }

  function getTranslate(el, axis) {
      if (axis === void 0) {
          axis = "x"
      }
      const window = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el);
      if (window.WebKitCSSMatrix) {
          curTransform = curStyle.transform || curStyle.webkitTransform;
          if (curTransform.split(",").length > 6) {
              curTransform = curTransform.split(", ").map(a => a.replace(",", ".")).join(", ")
          }
          transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform)
      } else {
          transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
          matrix = transformMatrix.toString().split(",")
      }
      if (axis === "x") {
          if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
          else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
          else curTransform = parseFloat(matrix[4])
      }
      if (axis === "y") {
          if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
          else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
          else curTransform = parseFloat(matrix[5])
      }
      return curTransform || 0
  }

  function isObject(o) {
      return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object"
  }

  function isNode(node) {
      if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
          return node instanceof HTMLElement
      }
      return node && (node.nodeType === 1 || node.nodeType === 11)
  }

  function extend() {
      const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      const noExtend = ["__proto__", "constructor", "prototype"];
      for (let i = 1; i < arguments.length; i += 1) {
          const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
          if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
              const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
              for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                  const nextKey = keysArray[nextIndex];
                  const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                  if (desc !== undefined && desc.enumerable) {
                      if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                          if (nextSource[nextKey].__swiper__) {
                              to[nextKey] = nextSource[nextKey]
                          } else {
                              extend(to[nextKey], nextSource[nextKey])
                          }
                      } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                          to[nextKey] = {};
                          if (nextSource[nextKey].__swiper__) {
                              to[nextKey] = nextSource[nextKey]
                          } else {
                              extend(to[nextKey], nextSource[nextKey])
                          }
                      } else {
                          to[nextKey] = nextSource[nextKey]
                      }
                  }
              }
          }
      }
      return to
  }

  function setCSSProperty(el, varName, varValue) {
      el.style.setProperty(varName, varValue)
  }

  function animateCSSModeScroll(_ref) {
      let {
          swiper,
          targetPosition,
          side
      } = _ref;
      const window = getWindow();
      const startPosition = -swiper.translate;
      let startTime = null;
      let time;
      const duration = swiper.params.speed;
      swiper.wrapperEl.style.scrollSnapType = "none";
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      const dir = targetPosition > startPosition ? "next" : "prev";
      const isOutOfBound = (current, target) => {
          return dir === "next" && current >= target || dir === "prev" && current <= target
      };
      const animate = () => {
          time = (new Date).getTime();
          if (startTime === null) {
              startTime = time
          }
          const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
          const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
          let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
          if (isOutOfBound(currentPosition, targetPosition)) {
              currentPosition = targetPosition
          }
          swiper.wrapperEl.scrollTo({
              [side]: currentPosition
          });
          if (isOutOfBound(currentPosition, targetPosition)) {
              swiper.wrapperEl.style.overflow = "hidden";
              swiper.wrapperEl.style.scrollSnapType = "";
              setTimeout(() => {
                  swiper.wrapperEl.style.overflow = "";
                  swiper.wrapperEl.scrollTo({
                      [side]: currentPosition
                  })
              });
              window.cancelAnimationFrame(swiper.cssModeFrameID);
              return
          }
          swiper.cssModeFrameID = window.requestAnimationFrame(animate)
      };
      animate()
  }

  function getSlideTransformEl(slideEl) {
      return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl
  }

  function elementChildren(element, selector) {
      if (selector === void 0) {
          selector = ""
      }
      return [...element.children].filter(el => el.matches(selector))
  }

  function showWarning(text) {
      try {
          console.warn(text);
          return
      } catch (err) {}
  }

  function createElement(tag, classes) {
      if (classes === void 0) {
          classes = []
      }
      const el = document.createElement(tag);
      el.classList.add(...Array.isArray(classes) ? classes : classesToTokens(classes));
      return el
  }

  function elementOffset(el) {
      const window = getWindow();
      const document = getDocument();
      const box = el.getBoundingClientRect();
      const body = document.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === window ? window.scrollY : el.scrollTop;
      const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
      return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
      }
  }

  function elementPrevAll(el, selector) {
      const prevEls = [];
      while (el.previousElementSibling) {
          const prev = el.previousElementSibling;
          if (selector) {
              if (prev.matches(selector)) prevEls.push(prev)
          } else prevEls.push(prev);
          el = prev
      }
      return prevEls
  }

  function elementNextAll(el, selector) {
      const nextEls = [];
      while (el.nextElementSibling) {
          const next = el.nextElementSibling;
          if (selector) {
              if (next.matches(selector)) nextEls.push(next)
          } else nextEls.push(next);
          el = next
      }
      return nextEls
  }

  function elementStyle(el, prop) {
      const window = getWindow();
      return window.getComputedStyle(el, null).getPropertyValue(prop)
  }

  function elementIndex(el) {
      let child = el;
      let i;
      if (child) {
          i = 0;
          while ((child = child.previousSibling) !== null) {
              if (child.nodeType === 1) i += 1
          }
          return i
      }
      return undefined
  }

  function elementParents(el, selector) {
      const parents = [];
      let parent = el.parentElement;
      while (parent) {
          if (selector) {
              if (parent.matches(selector)) parents.push(parent)
          } else {
              parents.push(parent)
          }
          parent = parent.parentElement
      }
      return parents
  }

  function elementTransitionEnd(el, callback) {
      function fireCallBack(e) {
          if (e.target !== el) return;
          callback.call(el, e);
          el.removeEventListener("transitionend", fireCallBack)
      }
      if (callback) {
          el.addEventListener("transitionend", fireCallBack)
      }
  }

  function elementOuterSize(el, size, includeMargins) {
      const window = getWindow();
      if (includeMargins) {
          return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"))
      }
      return el.offsetWidth
  }
  let support;

  function calcSupport() {
      const window = getWindow();
      const document = getDocument();
      return {
          smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
          touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
      }
  }

  function getSupport() {
      if (!support) {
          support = calcSupport()
      }
      return support
  }
  let deviceCached;

  function calcDevice(_temp) {
      let {
          userAgent
      } = _temp === void 0 ? {} : _temp;
      const support = getSupport();
      const window = getWindow();
      const platform = window.navigator.platform;
      const ua = userAgent || window.navigator.userAgent;
      const device = {
          ios: false,
          android: false
      };
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === "Win32";
      let macos = platform === "MacIntel";
      const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
      if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
          ipad = ua.match(/(Version)\/([\d.]+)/);
          if (!ipad) ipad = [0, 1, "13_0_0"];
          macos = false
      }
      if (android && !windows) {
          device.os = "android";
          device.android = true
      }
      if (ipad || iphone || ipod) {
          device.os = "ios";
          device.ios = true
      }
      return device
  }

  function getDevice(overrides) {
      if (overrides === void 0) {
          overrides = {}
      }
      if (!deviceCached) {
          deviceCached = calcDevice(overrides)
      }
      return deviceCached
  }
  let browser;

  function calcBrowser() {
      const window = getWindow();
      let needPerspectiveFix = false;

      function isSafari() {
          const ua = window.navigator.userAgent.toLowerCase();
          return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0
      }
      if (isSafari()) {
          const ua = String(window.navigator.userAgent);
          if (ua.includes("Version/")) {
              const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map(num => Number(num));
              needPerspectiveFix = major < 16 || major === 16 && minor < 2
          }
      }
      return {
          isSafari: needPerspectiveFix || isSafari(),
          needPerspectiveFix: needPerspectiveFix,
          isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      }
  }

  function getBrowser() {
      if (!browser) {
          browser = calcBrowser()
      }
      return browser
  }

  function Resize(_ref) {
      let {
          swiper,
          on,
          emit
      } = _ref;
      const window = getWindow();
      let observer = null;
      let animationFrame = null;
      const resizeHandler = () => {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          emit("beforeResize");
          emit("resize")
      };
      const createObserver = () => {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          observer = new ResizeObserver(entries => {
              animationFrame = window.requestAnimationFrame(() => {
                  const {
                      width,
                      height
                  } = swiper;
                  let newWidth = width;
                  let newHeight = height;
                  entries.forEach(_ref2 => {
                      let {
                          contentBoxSize,
                          contentRect,
                          target
                      } = _ref2;
                      if (target && target !== swiper.el) return;
                      newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                      newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize
                  });
                  if (newWidth !== width || newHeight !== height) {
                      resizeHandler()
                  }
              })
          });
          observer.observe(swiper.el)
      };
      const removeObserver = () => {
          if (animationFrame) {
              window.cancelAnimationFrame(animationFrame)
          }
          if (observer && observer.unobserve && swiper.el) {
              observer.unobserve(swiper.el);
              observer = null
          }
      };
      const orientationChangeHandler = () => {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          emit("orientationchange")
      };
      on("init", () => {
          if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
              createObserver();
              return
          }
          window.addEventListener("resize", resizeHandler);
          window.addEventListener("orientationchange", orientationChangeHandler)
      });
      on("destroy", () => {
          removeObserver();
          window.removeEventListener("resize", resizeHandler);
          window.removeEventListener("orientationchange", orientationChangeHandler)
      })
  }

  function Observer(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const observers = [];
      const window = getWindow();
      const attach = function(target, options) {
          if (options === void 0) {
              options = {}
          }
          const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
          const observer = new ObserverFunc(mutations => {
              if (swiper.__preventObserver__) return;
              if (mutations.length === 1) {
                  emit("observerUpdate", mutations[0]);
                  return
              }
              const observerUpdate = function observerUpdate() {
                  emit("observerUpdate", mutations[0])
              };
              if (window.requestAnimationFrame) {
                  window.requestAnimationFrame(observerUpdate)
              } else {
                  window.setTimeout(observerUpdate, 0)
              }
          });
          observer.observe(target, {
              attributes: typeof options.attributes === "undefined" ? true : options.attributes,
              childList: typeof options.childList === "undefined" ? true : options.childList,
              characterData: typeof options.characterData === "undefined" ? true : options.characterData
          });
          observers.push(observer)
      };
      const init = () => {
          if (!swiper.params.observer) return;
          if (swiper.params.observeParents) {
              const containerParents = elementParents(swiper.hostEl);
              for (let i = 0; i < containerParents.length; i += 1) {
                  attach(containerParents[i])
              }
          }
          attach(swiper.hostEl, {
              childList: swiper.params.observeSlideChildren
          });
          attach(swiper.wrapperEl, {
              attributes: false
          })
      };
      const destroy = () => {
          observers.forEach(observer => {
              observer.disconnect()
          });
          observers.splice(0, observers.length)
      };
      extendParams({
          observer: false,
          observeParents: false,
          observeSlideChildren: false
      });
      on("init", init);
      on("destroy", destroy)
  }
  var eventsEmitter = {
      on(events, handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (typeof handler !== "function") return self;
          const method = priority ? "unshift" : "push";
          events.split(" ").forEach(event => {
              if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
              self.eventsListeners[event][method](handler)
          });
          return self
      },
      once(events, handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (typeof handler !== "function") return self;

          function onceHandler() {
              self.off(events, onceHandler);
              if (onceHandler.__emitterProxy) {
                  delete onceHandler.__emitterProxy
              }
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key]
              }
              handler.apply(self, args)
          }
          onceHandler.__emitterProxy = handler;
          return self.on(events, onceHandler, priority)
      },
      onAny(handler, priority) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (typeof handler !== "function") return self;
          const method = priority ? "unshift" : "push";
          if (self.eventsAnyListeners.indexOf(handler) < 0) {
              self.eventsAnyListeners[method](handler)
          }
          return self
      },
      offAny(handler) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (!self.eventsAnyListeners) return self;
          const index = self.eventsAnyListeners.indexOf(handler);
          if (index >= 0) {
              self.eventsAnyListeners.splice(index, 1)
          }
          return self
      },
      off(events, handler) {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (!self.eventsListeners) return self;
          events.split(" ").forEach(event => {
              if (typeof handler === "undefined") {
                  self.eventsListeners[event] = []
              } else if (self.eventsListeners[event]) {
                  self.eventsListeners[event].forEach((eventHandler, index) => {
                      if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                          self.eventsListeners[event].splice(index, 1)
                      }
                  })
              }
          });
          return self
      },
      emit() {
          const self = this;
          if (!self.eventsListeners || self.destroyed) return self;
          if (!self.eventsListeners) return self;
          let events;
          let data;
          let context;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2]
          }
          if (typeof args[0] === "string" || Array.isArray(args[0])) {
              events = args[0];
              data = args.slice(1, args.length);
              context = self
          } else {
              events = args[0].events;
              data = args[0].data;
              context = args[0].context || self
          }
          data.unshift(context);
          const eventsArray = Array.isArray(events) ? events : events.split(" ");
          eventsArray.forEach(event => {
              if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                  self.eventsAnyListeners.forEach(eventHandler => {
                      eventHandler.apply(context, [event, ...data])
                  })
              }
              if (self.eventsListeners && self.eventsListeners[event]) {
                  self.eventsListeners[event].forEach(eventHandler => {
                      eventHandler.apply(context, data)
                  })
              }
          });
          return self
      }
  };

  function updateSize() {
      const swiper = this;
      let width;
      let height;
      const el = swiper.el;
      if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
          width = swiper.params.width
      } else {
          width = el.clientWidth
      }
      if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
          height = swiper.params.height
      } else {
          height = el.clientHeight
      }
      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
          return
      }
      width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
      height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      Object.assign(swiper, {
          width: width,
          height: height,
          size: swiper.isHorizontal() ? width : height
      })
  }

  function updateSlides() {
      const swiper = this;

      function getDirectionPropertyValue(node, label) {
          return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0)
      }
      const params = swiper.params;
      const {
          wrapperEl,
          slidesEl,
          size: swiperSize,
          rtlTranslate: rtl,
          wrongRTL
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === "function") {
          offsetBefore = params.slidesOffsetBefore.call(swiper)
      }
      let offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === "function") {
          offsetAfter = params.slidesOffsetAfter.call(swiper)
      }
      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;
      if (typeof swiperSize === "undefined") {
          return
      }
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
          spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize
      } else if (typeof spaceBetween === "string") {
          spaceBetween = parseFloat(spaceBetween)
      }
      swiper.virtualSize = -spaceBetween;
      slides.forEach(slideEl => {
          if (rtl) {
              slideEl.style.marginLeft = ""
          } else {
              slideEl.style.marginRight = ""
          }
          slideEl.style.marginBottom = "";
          slideEl.style.marginTop = ""
      });
      if (params.centeredSlides && params.cssMode) {
          setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
          setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "")
      }
      const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
      if (gridEnabled) {
          swiper.grid.initSlides(slides)
      } else if (swiper.grid) {
          swiper.grid.unsetSlides()
      }
      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
          return typeof params.breakpoints[key].slidesPerView !== "undefined"
      }).length > 0;
      for (let i = 0; i < slidesLength; i += 1) {
          slideSize = 0;
          let slide;
          if (slides[i]) slide = slides[i];
          if (gridEnabled) {
              swiper.grid.updateSlide(i, slide, slides)
          }
          if (slides[i] && elementStyle(slide, "display") === "none") continue;
          if (params.slidesPerView === "auto") {
              if (shouldResetSlideSize) {
                  slides[i].style[swiper.getDirectionLabel("width")] = ``
              }
              const slideStyles = getComputedStyle(slide);
              const currentTransform = slide.style.transform;
              const currentWebKitTransform = slide.style.webkitTransform;
              if (currentTransform) {
                  slide.style.transform = "none"
              }
              if (currentWebKitTransform) {
                  slide.style.webkitTransform = "none"
              }
              if (params.roundLengths) {
                  slideSize = swiper.isHorizontal() ? elementOuterSize(slide, "width", true) : elementOuterSize(slide, "height", true)
              } else {
                  const width = getDirectionPropertyValue(slideStyles, "width");
                  const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                  const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                  const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                  const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                  const boxSizing = slideStyles.getPropertyValue("box-sizing");
                  if (boxSizing && boxSizing === "border-box") {
                      slideSize = width + marginLeft + marginRight
                  } else {
                      const {
                          clientWidth,
                          offsetWidth
                      } = slide;
                      slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth)
                  }
              }
              if (currentTransform) {
                  slide.style.transform = currentTransform
              }
              if (currentWebKitTransform) {
                  slide.style.webkitTransform = currentWebKitTransform
              }
              if (params.roundLengths) slideSize = Math.floor(slideSize)
          } else {
              slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
              if (params.roundLengths) slideSize = Math.floor(slideSize);
              if (slides[i]) {
                  slides[i].style[swiper.getDirectionLabel("width")] = `${slideSize}px`
              }
          }
          if (slides[i]) {
              slides[i].swiperSlideSize = slideSize
          }
          slidesSizesGrid.push(slideSize);
          if (params.centeredSlides) {
              slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
              if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
              if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
              if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
              if (params.roundLengths) slidePosition = Math.floor(slidePosition);
              if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
              slidesGrid.push(slidePosition)
          } else {
              if (params.roundLengths) slidePosition = Math.floor(slidePosition);
              if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
              slidesGrid.push(slidePosition);
              slidePosition = slidePosition + slideSize + spaceBetween
          }
          swiper.virtualSize += slideSize + spaceBetween;
          prevSlideSize = slideSize;
          index += 1
      }
      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
          wrapperEl.style.width = `${swiper.virtualSize+spaceBetween}px`
      }
      if (params.setWrapperSize) {
          wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize+spaceBetween}px`
      }
      if (gridEnabled) {
          swiper.grid.updateWrapperSize(slideSize, snapGrid)
      }
      if (!params.centeredSlides) {
          const newSlidesGrid = [];
          for (let i = 0; i < snapGrid.length; i += 1) {
              let slidesGridItem = snapGrid[i];
              if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
              if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                  newSlidesGrid.push(slidesGridItem)
              }
          }
          snapGrid = newSlidesGrid;
          if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
              snapGrid.push(swiper.virtualSize - swiperSize)
          }
      }
      if (isVirtual && params.loop) {
          const size = slidesSizesGrid[0] + spaceBetween;
          if (params.slidesPerGroup > 1) {
              const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
              const groupSize = size * params.slidesPerGroup;
              for (let i = 0; i < groups; i += 1) {
                  snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize)
              }
          }
          for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
              if (params.slidesPerGroup === 1) {
                  snapGrid.push(snapGrid[snapGrid.length - 1] + size)
              }
              slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
              swiper.virtualSize += size
          }
      }
      if (snapGrid.length === 0) snapGrid = [0];
      if (spaceBetween !== 0) {
          const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
          slides.filter((_, slideIndex) => {
              if (!params.cssMode || params.loop) return true;
              if (slideIndex === slides.length - 1) {
                  return false
              }
              return true
          }).forEach(slideEl => {
              slideEl.style[key] = `${spaceBetween}px`
          })
      }
      if (params.centeredSlides && params.centeredSlidesBounds) {
          let allSlidesSize = 0;
          slidesSizesGrid.forEach(slideSizeValue => {
              allSlidesSize += slideSizeValue + (spaceBetween || 0)
          });
          allSlidesSize -= spaceBetween;
          const maxSnap = allSlidesSize - swiperSize;
          snapGrid = snapGrid.map(snap => {
              if (snap <= 0) return -offsetBefore;
              if (snap > maxSnap) return maxSnap + offsetAfter;
              return snap
          })
      }
      if (params.centerInsufficientSlides) {
          let allSlidesSize = 0;
          slidesSizesGrid.forEach(slideSizeValue => {
              allSlidesSize += slideSizeValue + (spaceBetween || 0)
          });
          allSlidesSize -= spaceBetween;
          if (allSlidesSize < swiperSize) {
              const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
              snapGrid.forEach((snap, snapIndex) => {
                  snapGrid[snapIndex] = snap - allSlidesOffset
              });
              slidesGrid.forEach((snap, snapIndex) => {
                  slidesGrid[snapIndex] = snap + allSlidesOffset
              })
          }
      }
      Object.assign(swiper, {
          slides: slides,
          snapGrid: snapGrid,
          slidesGrid: slidesGrid,
          slidesSizesGrid: slidesSizesGrid
      });
      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
          setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
          setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size/2-slidesSizesGrid[slidesSizesGrid.length-1]/2}px`);
          const addToSnapGrid = -swiper.snapGrid[0];
          const addToSlidesGrid = -swiper.slidesGrid[0];
          swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
          swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid)
      }
      if (slidesLength !== previousSlidesLength) {
          swiper.emit("slidesLengthChange")
      }
      if (snapGrid.length !== previousSnapGridLength) {
          if (swiper.params.watchOverflow) swiper.checkOverflow();
          swiper.emit("snapGridLengthChange")
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
          swiper.emit("slidesGridLengthChange")
      }
      if (params.watchSlidesProgress) {
          swiper.updateSlidesOffset()
      }
      swiper.emit("slidesUpdated");
      if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
          const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
          const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
          if (slidesLength <= params.maxBackfaceHiddenSlides) {
              if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass)
          } else if (hasClassBackfaceClassAdded) {
              swiper.el.classList.remove(backFaceHiddenClass)
          }
      }
  }

  function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let newHeight = 0;
      let i;
      if (typeof speed === "number") {
          swiper.setTransition(speed)
      } else if (speed === true) {
          swiper.setTransition(swiper.params.speed)
      }
      const getSlideByIndex = index => {
          if (isVirtual) {
              return swiper.slides[swiper.getSlideIndexByData(index)]
          }
          return swiper.slides[index]
      };
      if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
          if (swiper.params.centeredSlides) {
              (swiper.visibleSlides || []).forEach(slide => {
                  activeSlides.push(slide)
              })
          } else {
              for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                  const index = swiper.activeIndex + i;
                  if (index > swiper.slides.length && !isVirtual) break;
                  activeSlides.push(getSlideByIndex(index))
              }
          }
      } else {
          activeSlides.push(getSlideByIndex(swiper.activeIndex))
      }
      for (i = 0; i < activeSlides.length; i += 1) {
          if (typeof activeSlides[i] !== "undefined") {
              const height = activeSlides[i].offsetHeight;
              newHeight = height > newHeight ? height : newHeight
          }
      }
      if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`
  }

  function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;
      const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
      for (let i = 0; i < slides.length; i += 1) {
          slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment()
      }
  }

  function updateSlidesProgress(translate) {
      if (translate === void 0) {
          translate = this && this.translate || 0
      }
      const swiper = this;
      const params = swiper.params;
      const {
          slides,
          rtlTranslate: rtl,
          snapGrid
      } = swiper;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate;
      slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass)
      });
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];
      let spaceBetween = params.spaceBetween;
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
          spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size
      } else if (typeof spaceBetween === "string") {
          spaceBetween = parseFloat(spaceBetween)
      }
      for (let i = 0; i < slides.length; i += 1) {
          const slide = slides[i];
          let slideOffset = slide.swiperSlideOffset;
          if (params.cssMode && params.centeredSlides) {
              slideOffset -= slides[0].swiperSlideOffset
          }
          const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
          const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
          const slideBefore = -(offsetCenter - slideOffset);
          const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
          const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
          if (isVisible) {
              swiper.visibleSlides.push(slide);
              swiper.visibleSlidesIndexes.push(i);
              slides[i].classList.add(params.slideVisibleClass)
          }
          if (isFullyVisible) {
              slides[i].classList.add(params.slideFullyVisibleClass)
          }
          slide.progress = rtl ? -slideProgress : slideProgress;
          slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress
      }
  }

  function updateProgress(translate) {
      const swiper = this;
      if (typeof translate === "undefined") {
          const multiplier = swiper.rtlTranslate ? -1 : 1;
          translate = swiper && swiper.translate && swiper.translate * multiplier || 0
      }
      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let {
          progress,
          isBeginning,
          isEnd,
          progressLoop
      } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;
      if (translatesDiff === 0) {
          progress = 0;
          isBeginning = true;
          isEnd = true
      } else {
          progress = (translate - swiper.minTranslate()) / translatesDiff;
          const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
          const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
          isBeginning = isBeginningRounded || progress <= 0;
          isEnd = isEndRounded || progress >= 1;
          if (isBeginningRounded) progress = 0;
          if (isEndRounded) progress = 1
      }
      if (params.loop) {
          const firstSlideIndex = swiper.getSlideIndexByData(0);
          const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
          const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
          const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
          const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
          const translateAbs = Math.abs(translate);
          if (translateAbs >= firstSlideTranslate) {
              progressLoop = (translateAbs - firstSlideTranslate) / translateMax
          } else {
              progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax
          }
          if (progressLoop > 1) progressLoop -= 1
      }
      Object.assign(swiper, {
          progress: progress,
          progressLoop: progressLoop,
          isBeginning: isBeginning,
          isEnd: isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
      if (isBeginning && !wasBeginning) {
          swiper.emit("reachBeginning toEdge")
      }
      if (isEnd && !wasEnd) {
          swiper.emit("reachEnd toEdge")
      }
      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
          swiper.emit("fromEdge")
      }
      swiper.emit("progress", progress)
  }

  function updateSlidesClasses() {
      const swiper = this;
      const {
          slides,
          params,
          slidesEl,
          activeIndex
      } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
      const getFilteredSlide = selector => {
          return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0]
      };
      slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass)
      });
      let activeSlide;
      let prevSlide;
      let nextSlide;
      if (isVirtual) {
          if (params.loop) {
              let slideIndex = activeIndex - swiper.virtual.slidesBefore;
              if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
              if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
              activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`)
          } else {
              activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`)
          }
      } else {
          if (gridEnabled) {
              activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
              nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
              prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0]
          } else {
              activeSlide = slides[activeIndex]
          }
      }
      if (activeSlide) {
          activeSlide.classList.add(params.slideActiveClass);
          if (gridEnabled) {
              if (nextSlide) {
                  nextSlide.classList.add(params.slideNextClass)
              }
              if (prevSlide) {
                  prevSlide.classList.add(params.slidePrevClass)
              }
          } else {
              nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
              if (params.loop && !nextSlide) {
                  nextSlide = slides[0]
              }
              if (nextSlide) {
                  nextSlide.classList.add(params.slideNextClass)
              }
              prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
              if (params.loop && !prevSlide === 0) {
                  prevSlide = slides[slides.length - 1]
              }
              if (prevSlide) {
                  prevSlide.classList.add(params.slidePrevClass)
              }
          }
      }
      swiper.emitSlidesClasses()
  }
  const processLazyPreloader = (swiper, imageEl) => {
      if (!swiper || swiper.destroyed || !swiper.params) return;
      const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
      const slideEl = imageEl.closest(slideSelector());
      if (slideEl) {
          let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
          if (!lazyEl && swiper.isElement) {
              if (slideEl.shadowRoot) {
                  lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`)
              } else {
                  requestAnimationFrame(() => {
                      if (slideEl.shadowRoot) {
                          lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                          if (lazyEl) lazyEl.remove()
                      }
                  })
              }
          }
          if (lazyEl) lazyEl.remove()
      }
  };
  const unlazy = (swiper, index) => {
      if (!swiper.slides[index]) return;
      const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
      if (imageEl) imageEl.removeAttribute("loading")
  };
  const preload = swiper => {
      if (!swiper || swiper.destroyed || !swiper.params) return;
      let amount = swiper.params.lazyPreloadPrevNext;
      const len = swiper.slides.length;
      if (!len || !amount || amount < 0) return;
      amount = Math.min(amount, len);
      const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
      const activeIndex = swiper.activeIndex;
      if (swiper.params.grid && swiper.params.grid.rows > 1) {
          const activeColumn = activeIndex;
          const preloadColumns = [activeColumn - amount];
          preloadColumns.push(...Array.from({
              length: amount
          }).map((_, i) => {
              return activeColumn + slidesPerView + i
          }));
          swiper.slides.forEach((slideEl, i) => {
              if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i)
          });
          return
      }
      const slideIndexLastInView = activeIndex + slidesPerView - 1;
      if (swiper.params.rewind || swiper.params.loop) {
          for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
              const realIndex = (i % len + len) % len;
              if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex)
          }
      } else {
          for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
              if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
                  unlazy(swiper, i)
              }
          }
      }
  };

  function getActiveIndexByTranslate(swiper) {
      const {
          slidesGrid,
          params
      } = swiper;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      let activeIndex;
      for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== "undefined") {
              if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
                  activeIndex = i
              } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
                  activeIndex = i + 1
              }
          } else if (translate >= slidesGrid[i]) {
              activeIndex = i
          }
      }
      if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0
      }
      return activeIndex
  }

  function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const {
          snapGrid,
          params,
          activeIndex: previousIndex,
          realIndex: previousRealIndex,
          snapIndex: previousSnapIndex
      } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;
      const getVirtualRealIndex = aIndex => {
          let realIndex = aIndex - swiper.virtual.slidesBefore;
          if (realIndex < 0) {
              realIndex = swiper.virtual.slides.length + realIndex
          }
          if (realIndex >= swiper.virtual.slides.length) {
              realIndex -= swiper.virtual.slides.length
          }
          return realIndex
      };
      if (typeof activeIndex === "undefined") {
          activeIndex = getActiveIndexByTranslate(swiper)
      }
      if (snapGrid.indexOf(translate) >= 0) {
          snapIndex = snapGrid.indexOf(translate)
      } else {
          const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
          snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup)
      }
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex && !swiper.params.loop) {
          if (snapIndex !== previousSnapIndex) {
              swiper.snapIndex = snapIndex;
              swiper.emit("snapIndexChange")
          }
          return
      }
      if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
          swiper.realIndex = getVirtualRealIndex(activeIndex);
          return
      }
      const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
      let realIndex;
      if (swiper.virtual && params.virtual.enabled && params.loop) {
          realIndex = getVirtualRealIndex(activeIndex)
      } else if (gridEnabled) {
          const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
          let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
          if (Number.isNaN(activeSlideIndex)) {
              activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0)
          }
          realIndex = Math.floor(activeSlideIndex / params.grid.rows)
      } else if (swiper.slides[activeIndex]) {
          const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
          if (slideIndex) {
              realIndex = parseInt(slideIndex, 10)
          } else {
              realIndex = activeIndex
          }
      } else {
          realIndex = activeIndex
      }
      Object.assign(swiper, {
          previousSnapIndex: previousSnapIndex,
          snapIndex: snapIndex,
          previousRealIndex: previousRealIndex,
          realIndex: realIndex,
          previousIndex: previousIndex,
          activeIndex: activeIndex
      });
      if (swiper.initialized) {
          preload(swiper)
      }
      swiper.emit("activeIndexChange");
      swiper.emit("snapIndexChange");
      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
          if (previousRealIndex !== realIndex) {
              swiper.emit("realIndexChange")
          }
          swiper.emit("slideChange")
      }
  }

  function updateClickedSlide(el, path) {
      const swiper = this;
      const params = swiper.params;
      let slide = el.closest(`.${params.slideClass}, swiper-slide`);
      if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
          [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
              if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
                  slide = pathEl
              }
          })
      }
      let slideFound = false;
      let slideIndex;
      if (slide) {
          for (let i = 0; i < swiper.slides.length; i += 1) {
              if (swiper.slides[i] === slide) {
                  slideFound = true;
                  slideIndex = i;
                  break
              }
          }
      }
      if (slide && slideFound) {
          swiper.clickedSlide = slide;
          if (swiper.virtual && swiper.params.virtual.enabled) {
              swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10)
          } else {
              swiper.clickedIndex = slideIndex
          }
      } else {
          swiper.clickedSlide = undefined;
          swiper.clickedIndex = undefined;
          return
      }
      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
          swiper.slideToClickedSlide()
      }
  }
  var update = {
      updateSize: updateSize,
      updateSlides: updateSlides,
      updateAutoHeight: updateAutoHeight,
      updateSlidesOffset: updateSlidesOffset,
      updateSlidesProgress: updateSlidesProgress,
      updateProgress: updateProgress,
      updateSlidesClasses: updateSlidesClasses,
      updateActiveIndex: updateActiveIndex,
      updateClickedSlide: updateClickedSlide
  };

  function getSwiperTranslate(axis) {
      if (axis === void 0) {
          axis = this.isHorizontal() ? "x" : "y"
      }
      const swiper = this;
      const {
          params,
          rtlTranslate: rtl,
          translate,
          wrapperEl
      } = swiper;
      if (params.virtualTranslate) {
          return rtl ? -translate : translate
      }
      if (params.cssMode) {
          return translate
      }
      let currentTranslate = getTranslate(wrapperEl, axis);
      currentTranslate += swiper.cssOverflowAdjustment();
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0
  }

  function setTranslate(translate, byController) {
      const swiper = this;
      const {
          rtlTranslate: rtl,
          params,
          wrapperEl,
          progress
      } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;
      if (swiper.isHorizontal()) {
          x = rtl ? -translate : translate
      } else {
          y = translate
      }
      if (params.roundLengths) {
          x = Math.floor(x);
          y = Math.floor(y)
      }
      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y;
      if (params.cssMode) {
          wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y
      } else if (!params.virtualTranslate) {
          if (swiper.isHorizontal()) {
              x -= swiper.cssOverflowAdjustment()
          } else {
              y -= swiper.cssOverflowAdjustment()
          }
          wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`
      }
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
          newProgress = 0
      } else {
          newProgress = (translate - swiper.minTranslate()) / translatesDiff
      }
      if (newProgress !== progress) {
          swiper.updateProgress(translate)
      }
      swiper.emit("setTranslate", swiper.translate, byController)
  }

  function minTranslate() {
      return -this.snapGrid[0]
  }

  function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1]
  }

  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
          translate = 0
      }
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      if (translateBounds === void 0) {
          translateBounds = true
      }
      const swiper = this;
      const {
          params,
          wrapperEl
      } = swiper;
      if (swiper.animating && params.preventInteractionOnTransition) {
          return false
      }
      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
      else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
      else newTranslate = translate;
      swiper.updateProgress(newTranslate);
      if (params.cssMode) {
          const isH = swiper.isHorizontal();
          if (speed === 0) {
              wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate
          } else {
              if (!swiper.support.smoothScroll) {
                  animateCSSModeScroll({
                      swiper: swiper,
                      targetPosition: -newTranslate,
                      side: isH ? "left" : "top"
                  });
                  return true
              }
              wrapperEl.scrollTo({
                  [isH ? "left" : "top"]: -newTranslate,
                  behavior: "smooth"
              })
          }
          return true
      }
      if (speed === 0) {
          swiper.setTransition(0);
          swiper.setTranslate(newTranslate);
          if (runCallbacks) {
              swiper.emit("beforeTransitionStart", speed, internal);
              swiper.emit("transitionEnd")
          }
      } else {
          swiper.setTransition(speed);
          swiper.setTranslate(newTranslate);
          if (runCallbacks) {
              swiper.emit("beforeTransitionStart", speed, internal);
              swiper.emit("transitionStart")
          }
          if (!swiper.animating) {
              swiper.animating = true;
              if (!swiper.onTranslateToWrapperTransitionEnd) {
                  swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                      if (!swiper || swiper.destroyed) return;
                      if (e.target !== this) return;
                      swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                      swiper.onTranslateToWrapperTransitionEnd = null;
                      delete swiper.onTranslateToWrapperTransitionEnd;
                      if (runCallbacks) {
                          swiper.emit("transitionEnd")
                      }
                  }
              }
              swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd)
          }
      }
      return true
  }
  var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate,
      minTranslate: minTranslate,
      maxTranslate: maxTranslate,
      translateTo: translateTo
  };

  function setTransition(duration, byController) {
      const swiper = this;
      if (!swiper.params.cssMode) {
          swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
          swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : ""
      }
      swiper.emit("setTransition", duration, byController)
  }

  function transitionEmit(_ref) {
      let {
          swiper,
          runCallbacks,
          direction,
          step
      } = _ref;
      const {
          activeIndex,
          previousIndex
      } = swiper;
      let dir = direction;
      if (!dir) {
          if (activeIndex > previousIndex) dir = "next";
          else if (activeIndex < previousIndex) dir = "prev";
          else dir = "reset"
      }
      swiper.emit(`transition${step}`);
      if (runCallbacks && activeIndex !== previousIndex) {
          if (dir === "reset") {
              swiper.emit(`slideResetTransition${step}`);
              return
          }
          swiper.emit(`slideChangeTransition${step}`);
          if (dir === "next") {
              swiper.emit(`slideNextTransition${step}`)
          } else {
              swiper.emit(`slidePrevTransition${step}`)
          }
      }
  }

  function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      const swiper = this;
      const {
          params
      } = swiper;
      if (params.cssMode) return;
      if (params.autoHeight) {
          swiper.updateAutoHeight()
      }
      transitionEmit({
          swiper: swiper,
          runCallbacks: runCallbacks,
          direction: direction,
          step: "Start"
      })
  }

  function transitionEnd(runCallbacks, direction) {
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      const swiper = this;
      const {
          params
      } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      transitionEmit({
          swiper: swiper,
          runCallbacks: runCallbacks,
          direction: direction,
          step: "End"
      })
  }
  var transition = {
      setTransition: setTransition,
      transitionStart: transitionStart,
      transitionEnd: transitionEnd
  };

  function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
          index = 0
      }
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      if (typeof index === "string") {
          index = parseInt(index, 10)
      }
      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      const {
          params,
          snapGrid,
          slidesGrid,
          previousIndex,
          activeIndex,
          rtlTranslate: rtl,
          wrapperEl,
          enabled
      } = swiper;
      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
          return false
      }
      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      const translate = -snapGrid[snapIndex];
      if (params.normalizeSlideIndex) {
          for (let i = 0; i < slidesGrid.length; i += 1) {
              const normalizedTranslate = -Math.floor(translate * 100);
              const normalizedGrid = Math.floor(slidesGrid[i] * 100);
              const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
              if (typeof slidesGrid[i + 1] !== "undefined") {
                  if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                      slideIndex = i
                  } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                      slideIndex = i + 1
                  }
              } else if (normalizedTranslate >= normalizedGrid) {
                  slideIndex = i
              }
          }
      }
      if (swiper.initialized && slideIndex !== activeIndex) {
          if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
              return false
          }
          if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
              if ((activeIndex || 0) !== slideIndex) {
                  return false
              }
          }
      }
      if (slideIndex !== (previousIndex || 0) && runCallbacks) {
          swiper.emit("beforeSlideChangeStart")
      }
      swiper.updateProgress(translate);
      let direction;
      if (slideIndex > activeIndex) direction = "next";
      else if (slideIndex < activeIndex) direction = "prev";
      else direction = "reset";
      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
          swiper.updateActiveIndex(slideIndex);
          if (params.autoHeight) {
              swiper.updateAutoHeight()
          }
          swiper.updateSlidesClasses();
          if (params.effect !== "slide") {
              swiper.setTranslate(translate)
          }
          if (direction !== "reset") {
              swiper.transitionStart(runCallbacks, direction);
              swiper.transitionEnd(runCallbacks, direction)
          }
          return false
      }
      if (params.cssMode) {
          const isH = swiper.isHorizontal();
          const t = rtl ? translate : -translate;
          if (speed === 0) {
              const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
              if (isVirtual) {
                  swiper.wrapperEl.style.scrollSnapType = "none";
                  swiper._immediateVirtual = true
              }
              if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                  swiper._cssModeVirtualInitialSet = true;
                  requestAnimationFrame(() => {
                      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t
                  })
              } else {
                  wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t
              }
              if (isVirtual) {
                  requestAnimationFrame(() => {
                      swiper.wrapperEl.style.scrollSnapType = "";
                      swiper._immediateVirtual = false
                  })
              }
          } else {
              if (!swiper.support.smoothScroll) {
                  animateCSSModeScroll({
                      swiper: swiper,
                      targetPosition: t,
                      side: isH ? "left" : "top"
                  });
                  return true
              }
              wrapperEl.scrollTo({
                  [isH ? "left" : "top"]: t,
                  behavior: "smooth"
              })
          }
          return true
      }
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      if (speed === 0) {
          swiper.transitionEnd(runCallbacks, direction)
      } else if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onSlideToWrapperTransitionEnd) {
              swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                  if (!swiper || swiper.destroyed) return;
                  if (e.target !== this) return;
                  swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                  swiper.onSlideToWrapperTransitionEnd = null;
                  delete swiper.onSlideToWrapperTransitionEnd;
                  swiper.transitionEnd(runCallbacks, direction)
              }
          }
          swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd)
      }
      return true
  }

  function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
          index = 0
      }
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      if (typeof index === "string") {
          const indexAsNumber = parseInt(index, 10);
          index = indexAsNumber
      }
      const swiper = this;
      const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
      let newIndex = index;
      if (swiper.params.loop) {
          if (swiper.virtual && swiper.params.virtual.enabled) {
              newIndex = newIndex + swiper.virtual.slidesBefore
          } else {
              let targetSlideIndex;
              if (gridEnabled) {
                  const slideIndex = newIndex * swiper.params.grid.rows;
                  targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column
              } else {
                  targetSlideIndex = swiper.getSlideIndexByData(newIndex)
              }
              const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
              const {
                  centeredSlides
              } = swiper.params;
              let slidesPerView = swiper.params.slidesPerView;
              if (slidesPerView === "auto") {
                  slidesPerView = swiper.slidesPerViewDynamic()
              } else {
                  slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                  if (centeredSlides && slidesPerView % 2 === 0) {
                      slidesPerView = slidesPerView + 1
                  }
              }
              let needLoopFix = cols - targetSlideIndex < slidesPerView;
              if (centeredSlides) {
                  needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2)
              }
              if (needLoopFix) {
                  const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                  swiper.loopFix({
                      direction: direction,
                      slideTo: true,
                      activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                      slideRealIndex: direction === "next" ? swiper.realIndex : undefined
                  })
              }
              if (gridEnabled) {
                  const slideIndex = newIndex * swiper.params.grid.rows;
                  newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column
              } else {
                  newIndex = swiper.getSlideIndexByData(newIndex)
              }
          }
      }
      requestAnimationFrame(() => {
          swiper.slideTo(newIndex, speed, runCallbacks, internal)
      });
      return swiper
  }

  function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      const swiper = this;
      const {
          enabled,
          params,
          animating
      } = swiper;
      if (!enabled) return swiper;
      let perGroup = params.slidesPerGroup;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1)
      }
      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      if (params.loop) {
          if (animating && !isVirtual && params.loopPreventsSliding) return false;
          swiper.loopFix({
              direction: "next"
          });
          swiper._clientLeft = swiper.wrapperEl.clientLeft;
          if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
              requestAnimationFrame(() => {
                  swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal)
              });
              return true
          }
      }
      if (params.rewind && swiper.isEnd) {
          return swiper.slideTo(0, speed, runCallbacks, internal)
      }
      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal)
  }

  function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      const swiper = this;
      const {
          params,
          snapGrid,
          slidesGrid,
          rtlTranslate,
          enabled,
          animating
      } = swiper;
      if (!enabled) return swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      if (params.loop) {
          if (animating && !isVirtual && params.loopPreventsSliding) return false;
          swiper.loopFix({
              direction: "prev"
          });
          swiper._clientLeft = swiper.wrapperEl.clientLeft
      }
      const translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
          if (val < 0) return -Math.floor(Math.abs(val));
          return Math.floor(val)
      }
      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === "undefined" && params.cssMode) {
          let prevSnapIndex;
          snapGrid.forEach((snap, snapIndex) => {
              if (normalizedTranslate >= snap) {
                  prevSnapIndex = snapIndex
              }
          });
          if (typeof prevSnapIndex !== "undefined") {
              prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex]
          }
      }
      let prevIndex = 0;
      if (typeof prevSnap !== "undefined") {
          prevIndex = slidesGrid.indexOf(prevSnap);
          if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
          if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
              prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
              prevIndex = Math.max(prevIndex, 0)
          }
      }
      if (params.rewind && swiper.isBeginning) {
          const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
          return swiper.slideTo(lastIndex, speed, runCallbacks, internal)
      } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
          requestAnimationFrame(() => {
              swiper.slideTo(prevIndex, speed, runCallbacks, internal)
          });
          return true
      }
      return swiper.slideTo(prevIndex, speed, runCallbacks, internal)
  }

  function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal)
  }

  function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
          speed = this.params.speed
      }
      if (runCallbacks === void 0) {
          runCallbacks = true
      }
      if (threshold === void 0) {
          threshold = .5
      }
      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      if (translate >= swiper.snapGrid[snapIndex]) {
          const currentSnap = swiper.snapGrid[snapIndex];
          const nextSnap = swiper.snapGrid[snapIndex + 1];
          if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
              index += swiper.params.slidesPerGroup
          }
      } else {
          const prevSnap = swiper.snapGrid[snapIndex - 1];
          const currentSnap = swiper.snapGrid[snapIndex];
          if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
              index -= swiper.params.slidesPerGroup
          }
      }
      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal)
  }

  function slideToClickedSlide() {
      const swiper = this;
      const {
          params,
          slidesEl
      } = swiper;
      const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;
      const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
      if (params.loop) {
          if (swiper.animating) return;
          realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
          if (params.centeredSlides) {
              if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                  swiper.loopFix();
                  slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                  nextTick(() => {
                      swiper.slideTo(slideToIndex)
                  })
              } else {
                  swiper.slideTo(slideToIndex)
              }
          } else if (slideToIndex > swiper.slides.length - slidesPerView) {
              swiper.loopFix();
              slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
              nextTick(() => {
                  swiper.slideTo(slideToIndex)
              })
          } else {
              swiper.slideTo(slideToIndex)
          }
      } else {
          swiper.slideTo(slideToIndex)
      }
  }
  var slide = {
      slideTo: slideTo,
      slideToLoop: slideToLoop,
      slideNext: slideNext,
      slidePrev: slidePrev,
      slideReset: slideReset,
      slideToClosest: slideToClosest,
      slideToClickedSlide: slideToClickedSlide
  };

  function loopCreate(slideRealIndex) {
      const swiper = this;
      const {
          params,
          slidesEl
      } = swiper;
      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
      const initSlides = () => {
          const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
          slides.forEach((el, index) => {
              el.setAttribute("data-swiper-slide-index", index)
          })
      };
      const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
      const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
      const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
      const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
      const addBlankSlides = amountOfSlides => {
          for (let i = 0; i < amountOfSlides; i += 1) {
              const slideEl = swiper.isElement ? createElement("swiper-slide", [params.slideBlankClass]) : createElement("div", [params.slideClass, params.slideBlankClass]);
              swiper.slidesEl.append(slideEl)
          }
      };
      if (shouldFillGroup) {
          if (params.loopAddBlankSlides) {
              const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
              addBlankSlides(slidesToAdd);
              swiper.recalcSlides();
              swiper.updateSlides()
          } else {
              showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)")
          }
          initSlides()
      } else if (shouldFillGrid) {
          if (params.loopAddBlankSlides) {
              const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
              addBlankSlides(slidesToAdd);
              swiper.recalcSlides();
              swiper.updateSlides()
          } else {
              showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)")
          }
          initSlides()
      } else {
          initSlides()
      }
      swiper.loopFix({
          slideRealIndex: slideRealIndex,
          direction: params.centeredSlides ? undefined : "next"
      })
  }

  function loopFix(_temp) {
      let {
          slideRealIndex,
          slideTo = true,
          direction,
          setTranslate,
          activeSlideIndex,
          byController,
          byMousewheel
      } = _temp === void 0 ? {} : _temp;
      const swiper = this;
      if (!swiper.params.loop) return;
      swiper.emit("beforeLoopFix");
      const {
          slides,
          allowSlidePrev,
          allowSlideNext,
          slidesEl,
          params
      } = swiper;
      const {
          centeredSlides
      } = params;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      if (swiper.virtual && params.virtual.enabled) {
          if (slideTo) {
              if (!params.centeredSlides && swiper.snapIndex === 0) {
                  swiper.slideTo(swiper.virtual.slides.length, 0, false, true)
              } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
                  swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true)
              } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                  swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true)
              }
          }
          swiper.allowSlidePrev = allowSlidePrev;
          swiper.allowSlideNext = allowSlideNext;
          swiper.emit("loopFix");
          return
      }
      let slidesPerView = params.slidesPerView;
      if (slidesPerView === "auto") {
          slidesPerView = swiper.slidesPerViewDynamic()
      } else {
          slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
          if (centeredSlides && slidesPerView % 2 === 0) {
              slidesPerView = slidesPerView + 1
          }
      }
      const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
      let loopedSlides = slidesPerGroup;
      if (loopedSlides % slidesPerGroup !== 0) {
          loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup
      }
      loopedSlides += params.loopAdditionalSlides;
      swiper.loopedSlides = loopedSlides;
      const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
      if (slides.length < slidesPerView + loopedSlides) {
          showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters")
      } else if (gridEnabled && params.grid.fill === "row") {
          showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`")
      }
      const prependSlidesIndexes = [];
      const appendSlidesIndexes = [];
      let activeIndex = swiper.activeIndex;
      if (typeof activeSlideIndex === "undefined") {
          activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0])
      } else {
          activeIndex = activeSlideIndex
      }
      const isNext = direction === "next" || !direction;
      const isPrev = direction === "prev" || !direction;
      let slidesPrepended = 0;
      let slidesAppended = 0;
      const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
      const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
      const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === "undefined" ? -slidesPerView / 2 + .5 : 0);
      if (activeColIndexWithShift < loopedSlides) {
          slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
          for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
              const index = i - Math.floor(i / cols) * cols;
              if (gridEnabled) {
                  const colIndexToPrepend = cols - index - 1;
                  for (let i = slides.length - 1; i >= 0; i -= 1) {
                      if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i)
                  }
              } else {
                  prependSlidesIndexes.push(cols - index - 1)
              }
          }
      } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
          slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
          for (let i = 0; i < slidesAppended; i += 1) {
              const index = i - Math.floor(i / cols) * cols;
              if (gridEnabled) {
                  slides.forEach((slide, slideIndex) => {
                      if (slide.column === index) appendSlidesIndexes.push(slideIndex)
                  })
              } else {
                  appendSlidesIndexes.push(index)
              }
          }
      }
      swiper.__preventObserver__ = true;
      requestAnimationFrame(() => {
          swiper.__preventObserver__ = false
      });
      if (isPrev) {
          prependSlidesIndexes.forEach(index => {
              slides[index].swiperLoopMoveDOM = true;
              slidesEl.prepend(slides[index]);
              slides[index].swiperLoopMoveDOM = false
          })
      }
      if (isNext) {
          appendSlidesIndexes.forEach(index => {
              slides[index].swiperLoopMoveDOM = true;
              slidesEl.append(slides[index]);
              slides[index].swiperLoopMoveDOM = false
          })
      }
      swiper.recalcSlides();
      if (params.slidesPerView === "auto") {
          swiper.updateSlides()
      } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
          swiper.slides.forEach((slide, slideIndex) => {
              swiper.grid.updateSlide(slideIndex, slide, swiper.slides)
          })
      }
      if (params.watchSlidesProgress) {
          swiper.updateSlidesOffset()
      }
      if (slideTo) {
          if (prependSlidesIndexes.length > 0 && isPrev) {
              if (typeof slideRealIndex === "undefined") {
                  const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                  const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                  const diff = newSlideTranslate - currentSlideTranslate;
                  if (byMousewheel) {
                      swiper.setTranslate(swiper.translate - diff)
                  } else {
                      swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                      if (setTranslate) {
                          swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                          swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff
                      }
                  }
              } else {
                  if (setTranslate) {
                      const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                      swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                      swiper.touchEventsData.currentTranslate = swiper.translate
                  }
              }
          } else if (appendSlidesIndexes.length > 0 && isNext) {
              if (typeof slideRealIndex === "undefined") {
                  const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                  const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                  const diff = newSlideTranslate - currentSlideTranslate;
                  if (byMousewheel) {
                      swiper.setTranslate(swiper.translate - diff)
                  } else {
                      swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                      if (setTranslate) {
                          swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                          swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff
                      }
                  }
              } else {
                  const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                  swiper.slideTo(swiper.activeIndex - shift, 0, false, true)
              }
          }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      if (swiper.controller && swiper.controller.control && !byController) {
          const loopParams = {
              slideRealIndex: slideRealIndex,
              direction: direction,
              setTranslate: setTranslate,
              activeSlideIndex: activeSlideIndex,
              byController: true
          };
          if (Array.isArray(swiper.controller.control)) {
              swiper.controller.control.forEach(c => {
                  if (!c.destroyed && c.params.loop) c.loopFix({
                      ...loopParams,
                      slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
                  })
              })
          } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
              swiper.controller.control.loopFix({
                  ...loopParams,
                  slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
              })
          }
      }
      swiper.emit("loopFix")
  }

  function loopDestroy() {
      const swiper = this;
      const {
          params,
          slidesEl
      } = swiper;
      if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
      swiper.recalcSlides();
      const newSlidesOrder = [];
      swiper.slides.forEach(slideEl => {
          const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
          newSlidesOrder[index] = slideEl
      });
      swiper.slides.forEach(slideEl => {
          slideEl.removeAttribute("data-swiper-slide-index")
      });
      newSlidesOrder.forEach(slideEl => {
          slidesEl.append(slideEl)
      });
      swiper.recalcSlides();
      swiper.slideTo(swiper.realIndex, 0)
  }
  var loop = {
      loopCreate: loopCreate,
      loopFix: loopFix,
      loopDestroy: loopDestroy
  };

  function setGrabCursor(moving) {
      const swiper = this;
      if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
      if (swiper.isElement) {
          swiper.__preventObserver__ = true
      }
      el.style.cursor = "move";
      el.style.cursor = moving ? "grabbing" : "grab";
      if (swiper.isElement) {
          requestAnimationFrame(() => {
              swiper.__preventObserver__ = false
          })
      }
  }

  function unsetGrabCursor() {
      const swiper = this;
      if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
          return
      }
      if (swiper.isElement) {
          swiper.__preventObserver__ = true
      }
      swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
      if (swiper.isElement) {
          requestAnimationFrame(() => {
              swiper.__preventObserver__ = false
          })
      }
  }
  var grabCursor = {
      setGrabCursor: setGrabCursor,
      unsetGrabCursor: unsetGrabCursor
  };

  function closestElement(selector, base) {
      if (base === void 0) {
          base = this
      }

      function __closestFrom(el) {
          if (!el || el === getDocument() || el === getWindow()) return null;
          if (el.assignedSlot) el = el.assignedSlot;
          const found = el.closest(selector);
          if (!found && !el.getRootNode) {
              return null
          }
          return found || __closestFrom(el.getRootNode().host)
      }
      return __closestFrom(base)
  }

  function preventEdgeSwipe(swiper, event, startX) {
      const window = getWindow();
      const {
          params
      } = swiper;
      const edgeSwipeDetection = params.edgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold;
      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
          if (edgeSwipeDetection === "prevent") {
              event.preventDefault();
              return true
          }
          return false
      }
      return true
  }

  function onTouchStart(event) {
      const swiper = this;
      const document = getDocument();
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      const data = swiper.touchEventsData;
      if (e.type === "pointerdown") {
          if (data.pointerId !== null && data.pointerId !== e.pointerId) {
              return
          }
          data.pointerId = e.pointerId
      } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
          data.touchId = e.targetTouches[0].identifier
      }
      if (e.type === "touchstart") {
          preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
          return
      }
      const {
          params,
          touches,
          enabled
      } = swiper;
      if (!enabled) return;
      if (!params.simulateTouch && e.pointerType === "mouse") return;
      if (swiper.animating && params.preventInteractionOnTransition) {
          return
      }
      if (!swiper.animating && params.cssMode && params.loop) {
          swiper.loopFix()
      }
      let targetEl = e.target;
      if (params.touchEventsTarget === "wrapper") {
          if (!swiper.wrapperEl.contains(targetEl)) return
      }
      if ("which" in e && e.which === 3) return;
      if ("button" in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return;
      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
      const eventPath = e.composedPath ? e.composedPath() : e.path;
      if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
          targetEl = eventPath[0]
      }
      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e.target && e.target.shadowRoot);
      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
          swiper.allowClick = true;
          return
      }
      if (params.swipeHandler) {
          if (!targetEl.closest(params.swipeHandler)) return
      }
      touches.currentX = e.pageX;
      touches.currentY = e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY;
      if (!preventEdgeSwipe(swiper, e, startX)) {
          return
      }
      Object.assign(data, {
          isTouched: true,
          isMoved: false,
          allowTouchCallbacks: true,
          isScrolling: undefined,
          startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;
      let preventDefault = true;
      if (targetEl.matches(data.focusableElements)) {
          preventDefault = false;
          if (targetEl.nodeName === "SELECT") {
              data.isTouched = false
          }
      }
      if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
          document.activeElement.blur()
      }
      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
          e.preventDefault()
      }
      if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
          swiper.freeMode.onTouchStart()
      }
      swiper.emit("touchStart", e)
  }

  function onTouchMove(event) {
      const document = getDocument();
      const swiper = this;
      const data = swiper.touchEventsData;
      const {
          params,
          touches,
          rtlTranslate: rtl,
          enabled
      } = swiper;
      if (!enabled) return;
      if (!params.simulateTouch && event.pointerType === "mouse") return;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (e.type === "pointermove") {
          if (data.touchId !== null) return;
          const id = e.pointerId;
          if (id !== data.pointerId) return
      }
      let targetTouch;
      if (e.type === "touchmove") {
          targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
          if (!targetTouch || targetTouch.identifier !== data.touchId) return
      } else {
          targetTouch = e
      }
      if (!data.isTouched) {
          if (data.startMoving && data.isScrolling) {
              swiper.emit("touchMoveOpposite", e)
          }
          return
      }
      const pageX = targetTouch.pageX;
      const pageY = targetTouch.pageY;
      if (e.preventedByNestedSwiper) {
          touches.startX = pageX;
          touches.startY = pageY;
          return
      }
      if (!swiper.allowTouchMove) {
          if (!e.target.matches(data.focusableElements)) {
              swiper.allowClick = false
          }
          if (data.isTouched) {
              Object.assign(touches, {
                  startX: pageX,
                  startY: pageY,
                  currentX: pageX,
                  currentY: pageY
              });
              data.touchStartTime = now()
          }
          return
      }
      if (params.touchReleaseOnEdges && !params.loop) {
          if (swiper.isVertical()) {
              if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                  data.isTouched = false;
                  data.isMoved = false;
                  return
              }
          } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
              return
          }
      }
      if (document.activeElement) {
          if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
              data.isMoved = true;
              swiper.allowClick = false;
              return
          }
      }
      if (data.allowTouchCallbacks) {
          swiper.emit("touchMove", e)
      }
      touches.previousX = touches.currentX;
      touches.previousY = touches.currentY;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
      if (typeof data.isScrolling === "undefined") {
          let touchAngle;
          if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
              data.isScrolling = false
          } else {
              if (diffX * diffX + diffY * diffY >= 25) {
                  touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                  data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle
              }
          }
      }
      if (data.isScrolling) {
          swiper.emit("touchMoveOpposite", e)
      }
      if (typeof data.startMoving === "undefined") {
          if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
              data.startMoving = true
          }
      }
      if (data.isScrolling) {
          data.isTouched = false;
          return
      }
      if (!data.startMoving) {
          return
      }
      swiper.allowClick = false;
      if (!params.cssMode && e.cancelable) {
          e.preventDefault()
      }
      if (params.touchMoveStopPropagation && !params.nested) {
          e.stopPropagation()
      }
      let diff = swiper.isHorizontal() ? diffX : diffY;
      let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
      if (params.oneWayMovement) {
          diff = Math.abs(diff) * (rtl ? 1 : -1);
          touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1)
      }
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) {
          diff = -diff;
          touchesDiff = -touchesDiff
      }
      const prevTouchesDirection = swiper.touchesDirection;
      swiper.swipeDirection = diff > 0 ? "prev" : "next";
      swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
      const isLoop = swiper.params.loop && !params.cssMode;
      const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
      if (!data.isMoved) {
          if (isLoop && allowLoopFix) {
              swiper.loopFix({
                  direction: swiper.swipeDirection
              })
          }
          data.startTranslate = swiper.getTranslate();
          swiper.setTransition(0);
          if (swiper.animating) {
              const evt = new window.CustomEvent("transitionend", {
                  bubbles: true,
                  cancelable: true
              });
              swiper.wrapperEl.dispatchEvent(evt)
          }
          data.allowMomentumBounce = false;
          if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
              swiper.setGrabCursor(true)
          }
          swiper.emit("sliderFirstMove", e)
      }
      let loopFixed;
      (new Date).getTime();
      if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
          Object.assign(touches, {
              startX: pageX,
              startY: pageY,
              currentX: pageX,
              currentY: pageY,
              startTranslate: data.currentTranslate
          });
          data.loopSwapReset = true;
          data.startTranslate = data.currentTranslate;
          return
      }
      swiper.emit("sliderMove", e);
      data.isMoved = true;
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
          resistanceRatio = 0
      }
      if (diff > 0) {
          if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] : swiper.minTranslate())) {
              swiper.loopFix({
                  direction: "prev",
                  setTranslate: true,
                  activeSlideIndex: 0
              })
          }
          if (data.currentTranslate > swiper.minTranslate()) {
              disableParentSwiper = false;
              if (params.resistance) {
                  data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio
              }
          }
      } else if (diff < 0) {
          if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] : swiper.maxTranslate())) {
              swiper.loopFix({
                  direction: "next",
                  setTranslate: true,
                  activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
              })
          }
          if (data.currentTranslate < swiper.maxTranslate()) {
              disableParentSwiper = false;
              if (params.resistance) {
                  data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio
              }
          }
      }
      if (disableParentSwiper) {
          e.preventedByNestedSwiper = true
      }
      if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
          data.currentTranslate = data.startTranslate
      }
      if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
          data.currentTranslate = data.startTranslate
      }
      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
          data.currentTranslate = data.startTranslate
      }
      if (params.threshold > 0) {
          if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
              if (!data.allowThresholdMove) {
                  data.allowThresholdMove = true;
                  touches.startX = touches.currentX;
                  touches.startY = touches.currentY;
                  data.currentTranslate = data.startTranslate;
                  touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                  return
              }
          } else {
              data.currentTranslate = data.startTranslate;
              return
          }
      }
      if (!params.followFinger || params.cssMode) return;
      if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses()
      }
      if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
          swiper.freeMode.onTouchMove()
      }
      swiper.updateProgress(data.currentTranslate);
      swiper.setTranslate(data.currentTranslate)
  }

  function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      let targetTouch;
      const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
      if (!isTouchEvent) {
          if (data.touchId !== null) return;
          if (e.pointerId !== data.pointerId) return;
          targetTouch = e
      } else {
          targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
          if (!targetTouch || targetTouch.identifier !== data.touchId) return
      }
      if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type)) {
          const proceed = ["pointercancel", "contextmenu"].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
          if (!proceed) {
              return
          }
      }
      data.pointerId = null;
      data.touchId = null;
      const {
          params,
          touches,
          rtlTranslate: rtl,
          slidesGrid,
          enabled
      } = swiper;
      if (!enabled) return;
      if (!params.simulateTouch && e.pointerType === "mouse") return;
      if (data.allowTouchCallbacks) {
          swiper.emit("touchEnd", e)
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
          if (data.isMoved && params.grabCursor) {
              swiper.setGrabCursor(false)
          }
          data.isMoved = false;
          data.startMoving = false;
          return
      }
      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(false)
      }
      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;
      if (swiper.allowClick) {
          const pathTree = e.path || e.composedPath && e.composedPath();
          swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
          swiper.emit("tap click", e);
          if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
              swiper.emit("doubleTap doubleClick", e)
          }
      }
      data.lastClickTime = now();
      nextTick(() => {
          if (!swiper.destroyed) swiper.allowClick = true
      });
      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
          data.isTouched = false;
          data.isMoved = false;
          data.startMoving = false;
          return
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;
      if (params.followFinger) {
          currentPos = rtl ? swiper.translate : -swiper.translate
      } else {
          currentPos = -data.currentTranslate
      }
      if (params.cssMode) {
          return
      }
      if (params.freeMode && params.freeMode.enabled) {
          swiper.freeMode.onTouchEnd({
              currentPos: currentPos
          });
          return
      }
      const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];
      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
          const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
          if (typeof slidesGrid[i + increment] !== "undefined") {
              if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                  stopIndex = i;
                  groupSize = slidesGrid[i + increment] - slidesGrid[i]
              }
          } else if (swipeToLast || currentPos >= slidesGrid[i]) {
              stopIndex = i;
              groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2]
          }
      }
      let rewindFirstIndex = null;
      let rewindLastIndex = null;
      if (params.rewind) {
          if (swiper.isBeginning) {
              rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1
          } else if (swiper.isEnd) {
              rewindFirstIndex = 0
          }
      }
      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (timeDiff > params.longSwipesMs) {
          if (!params.longSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return
          }
          if (swiper.swipeDirection === "next") {
              if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
              else swiper.slideTo(stopIndex)
          }
          if (swiper.swipeDirection === "prev") {
              if (ratio > 1 - params.longSwipesRatio) {
                  swiper.slideTo(stopIndex + increment)
              } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                  swiper.slideTo(rewindLastIndex)
              } else {
                  swiper.slideTo(stopIndex)
              }
          }
      } else {
          if (!params.shortSwipes) {
              swiper.slideTo(swiper.activeIndex);
              return
          }
          const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
          if (!isNavButtonTarget) {
              if (swiper.swipeDirection === "next") {
                  swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment)
              }
              if (swiper.swipeDirection === "prev") {
                  swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex)
              }
          } else if (e.target === swiper.navigation.nextEl) {
              swiper.slideTo(stopIndex + increment)
          } else {
              swiper.slideTo(stopIndex)
          }
      }
  }

  function onResize() {
      const swiper = this;
      const {
          params,
          el
      } = swiper;
      if (el && el.offsetWidth === 0) return;
      if (params.breakpoints) {
          swiper.setBreakpoint()
      }
      const {
          allowSlideNext,
          allowSlidePrev,
          snapGrid
      } = swiper;
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();
      const isVirtualLoop = isVirtual && params.loop;
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
          swiper.slideTo(swiper.slides.length - 1, 0, false, true)
      } else {
          if (swiper.params.loop && !isVirtual) {
              swiper.slideToLoop(swiper.realIndex, 0, false, true)
          } else {
              swiper.slideTo(swiper.activeIndex, 0, false, true)
          }
      }
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
          clearTimeout(swiper.autoplay.resizeTimeout);
          swiper.autoplay.resizeTimeout = setTimeout(() => {
              if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                  swiper.autoplay.resume()
              }
          }, 500)
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow()
      }
  }

  function onClick(e) {
      const swiper = this;
      if (!swiper.enabled) return;
      if (!swiper.allowClick) {
          if (swiper.params.preventClicks) e.preventDefault();
          if (swiper.params.preventClicksPropagation && swiper.animating) {
              e.stopPropagation();
              e.stopImmediatePropagation()
          }
      }
  }

  function onScroll() {
      const swiper = this;
      const {
          wrapperEl,
          rtlTranslate,
          enabled
      } = swiper;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;
      if (swiper.isHorizontal()) {
          swiper.translate = -wrapperEl.scrollLeft
      } else {
          swiper.translate = -wrapperEl.scrollTop
      }
      if (swiper.translate === 0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
          newProgress = 0
      } else {
          newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff
      }
      if (newProgress !== swiper.progress) {
          swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate)
      }
      swiper.emit("setTranslate", swiper.translate, false)
  }

  function onLoad(e) {
      const swiper = this;
      processLazyPreloader(swiper, e.target);
      if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
          return
      }
      swiper.update()
  }

  function onDocumentTouchStart() {
      const swiper = this;
      if (swiper.documentTouchHandlerProceeded) return;
      swiper.documentTouchHandlerProceeded = true;
      if (swiper.params.touchReleaseOnEdges) {
          swiper.el.style.touchAction = "auto"
      }
  }
  const events = (swiper, method) => {
      const document = getDocument();
      const {
          params,
          el,
          wrapperEl,
          device
      } = swiper;
      const capture = !!params.nested;
      const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
      const swiperMethod = method;
      document[domMethod]("touchstart", swiper.onDocumentTouchStart, {
          passive: false,
          capture: capture
      });
      el[domMethod]("touchstart", swiper.onTouchStart, {
          passive: false
      });
      el[domMethod]("pointerdown", swiper.onTouchStart, {
          passive: false
      });
      document[domMethod]("touchmove", swiper.onTouchMove, {
          passive: false,
          capture: capture
      });
      document[domMethod]("pointermove", swiper.onTouchMove, {
          passive: false,
          capture: capture
      });
      document[domMethod]("touchend", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("pointerup", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("pointercancel", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("touchcancel", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("pointerout", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("pointerleave", swiper.onTouchEnd, {
          passive: true
      });
      document[domMethod]("contextmenu", swiper.onTouchEnd, {
          passive: true
      });
      if (params.preventClicks || params.preventClicksPropagation) {
          el[domMethod]("click", swiper.onClick, true)
      }
      if (params.cssMode) {
          wrapperEl[domMethod]("scroll", swiper.onScroll)
      }
      if (params.updateOnWindowResize) {
          swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true)
      } else {
          swiper[swiperMethod]("observerUpdate", onResize, true)
      }
      el[domMethod]("load", swiper.onLoad, {
          capture: true
      })
  };

  function attachEvents() {
      const swiper = this;
      const {
          params
      } = swiper;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
      swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
      if (params.cssMode) {
          swiper.onScroll = onScroll.bind(swiper)
      }
      swiper.onClick = onClick.bind(swiper);
      swiper.onLoad = onLoad.bind(swiper);
      events(swiper, "on")
  }

  function detachEvents() {
      const swiper = this;
      events(swiper, "off")
  }
  var events$1 = {
      attachEvents: attachEvents,
      detachEvents: detachEvents
  };
  const isGridEnabled = (swiper, params) => {
      return swiper.grid && params.grid && params.grid.rows > 1
  };

  function setBreakpoint() {
      const swiper = this;
      const {
          realIndex,
          initialized,
          params,
          el
      } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
      const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = isGridEnabled(swiper, params);
      const isMultiRow = isGridEnabled(swiper, breakpointParams);
      const wasEnabled = params.enabled;
      if (wasMultiRow && !isMultiRow) {
          el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
          swiper.emitContainerClasses()
      } else if (!wasMultiRow && isMultiRow) {
          el.classList.add(`${params.containerModifierClass}grid`);
          if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
              el.classList.add(`${params.containerModifierClass}grid-column`)
          }
          swiper.emitContainerClasses()
      } ["navigation", "pagination", "scrollbar"].forEach(prop => {
          if (typeof breakpointParams[prop] === "undefined") return;
          const wasModuleEnabled = params[prop] && params[prop].enabled;
          const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
          if (wasModuleEnabled && !isModuleEnabled) {
              swiper[prop].disable()
          }
          if (!wasModuleEnabled && isModuleEnabled) {
              swiper[prop].enable()
          }
      });
      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
      const wasLoop = params.loop;
      if (directionChanged && initialized) {
          swiper.changeDirection()
      }
      extend(swiper.params, breakpointParams);
      const isEnabled = swiper.params.enabled;
      const hasLoop = swiper.params.loop;
      Object.assign(swiper, {
          allowTouchMove: swiper.params.allowTouchMove,
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev
      });
      if (wasEnabled && !isEnabled) {
          swiper.disable()
      } else if (!wasEnabled && isEnabled) {
          swiper.enable()
      }
      swiper.currentBreakpoint = breakpoint;
      swiper.emit("_beforeBreakpoint", breakpointParams);
      if (initialized) {
          if (needsReLoop) {
              swiper.loopDestroy();
              swiper.loopCreate(realIndex);
              swiper.updateSlides()
          } else if (!wasLoop && hasLoop) {
              swiper.loopCreate(realIndex);
              swiper.updateSlides()
          } else if (wasLoop && !hasLoop) {
              swiper.loopDestroy()
          }
      }
      swiper.emit("breakpoint", breakpointParams)
  }

  function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
          base = "window"
      }
      if (!breakpoints || base === "container" && !containerEl) return undefined;
      let breakpoint = false;
      const window = getWindow();
      const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints).map(point => {
          if (typeof point === "string" && point.indexOf("@") === 0) {
              const minRatio = parseFloat(point.substr(1));
              const value = currentHeight * minRatio;
              return {
                  value: value,
                  point: point
              }
          }
          return {
              value: point,
              point: point
          }
      });
      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
      for (let i = 0; i < points.length; i += 1) {
          const {
              point,
              value
          } = points[i];
          if (base === "window") {
              if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                  breakpoint = point
              }
          } else if (value <= containerEl.clientWidth) {
              breakpoint = point
          }
      }
      return breakpoint || "max"
  }
  var breakpoints = {
      setBreakpoint: setBreakpoint,
      getBreakpoint: getBreakpoint
  };

  function prepareClasses(entries, prefix) {
      const resultClasses = [];
      entries.forEach(item => {
          if (typeof item === "object") {
              Object.keys(item).forEach(classNames => {
                  if (item[classNames]) {
                      resultClasses.push(prefix + classNames)
                  }
              })
          } else if (typeof item === "string") {
              resultClasses.push(prefix + item)
          }
      });
      return resultClasses
  }

  function addClasses() {
      const swiper = this;
      const {
          classNames,
          params,
          rtl,
          el,
          device
      } = swiper;
      const suffixes = prepareClasses(["initialized", params.direction, {
          "free-mode": swiper.params.freeMode && params.freeMode.enabled
      }, {
          autoheight: params.autoHeight
      }, {
          rtl: rtl
      }, {
          grid: params.grid && params.grid.rows > 1
      }, {
          "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
      }, {
          android: device.android
      }, {
          ios: device.ios
      }, {
          "css-mode": params.cssMode
      }, {
          centered: params.cssMode && params.centeredSlides
      }, {
          "watch-progress": params.watchSlidesProgress
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      el.classList.add(...classNames);
      swiper.emitContainerClasses()
  }

  function removeClasses() {
      const swiper = this;
      const {
          el,
          classNames
      } = swiper;
      el.classList.remove(...classNames);
      swiper.emitContainerClasses()
  }
  var classes = {
      addClasses: addClasses,
      removeClasses: removeClasses
  };

  function checkOverflow() {
      const swiper = this;
      const {
          isLocked: wasLocked,
          params
      } = swiper;
      const {
          slidesOffsetBefore
      } = params;
      if (slidesOffsetBefore) {
          const lastSlideIndex = swiper.slides.length - 1;
          const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
          swiper.isLocked = swiper.size > lastSlideRightEdge
      } else {
          swiper.isLocked = swiper.snapGrid.length === 1
      }
      if (params.allowSlideNext === true) {
          swiper.allowSlideNext = !swiper.isLocked
      }
      if (params.allowSlidePrev === true) {
          swiper.allowSlidePrev = !swiper.isLocked
      }
      if (wasLocked && wasLocked !== swiper.isLocked) {
          swiper.isEnd = false
      }
      if (wasLocked !== swiper.isLocked) {
          swiper.emit(swiper.isLocked ? "lock" : "unlock")
      }
  }
  var checkOverflow$1 = {
      checkOverflow: checkOverflow
  };
  var defaults = {
      init: true,
      direction: "horizontal",
      oneWayMovement: false,
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      eventsPrefix: "swiper",
      enabled: true,
      focusableElements: "input, select, option, textarea, button, video, label",
      width: null,
      height: null,
      preventInteractionOnTransition: false,
      userAgent: null,
      url: null,
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      autoHeight: false,
      setWrapperSize: false,
      virtualTranslate: false,
      effect: "slide",
      breakpoints: undefined,
      breakpointsBase: "window",
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      watchOverflow: true,
      roundLengths: false,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: .5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 5,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      uniqueNavElements: true,
      resistance: true,
      resistanceRatio: .85,
      watchSlidesProgress: false,
      grabCursor: false,
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      loop: false,
      loopAddBlankSlides: true,
      loopAdditionalSlides: 0,
      loopPreventsSliding: true,
      rewind: false,
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      noSwiping: true,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: true,
      maxBackfaceHiddenSlides: 10,
      containerModifierClass: "swiper-",
      slideClass: "swiper-slide",
      slideBlankClass: "swiper-slide-blank",
      slideActiveClass: "swiper-slide-active",
      slideVisibleClass: "swiper-slide-visible",
      slideFullyVisibleClass: "swiper-slide-fully-visible",
      slideNextClass: "swiper-slide-next",
      slidePrevClass: "swiper-slide-prev",
      wrapperClass: "swiper-wrapper",
      lazyPreloaderClass: "swiper-lazy-preloader",
      lazyPreloadPrevNext: 0,
      runCallbacksOnInit: true,
      _emitClasses: false
  };

  function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj) {
          if (obj === void 0) {
              obj = {}
          }
          const moduleParamName = Object.keys(obj)[0];
          const moduleParams = obj[moduleParamName];
          if (typeof moduleParams !== "object" || moduleParams === null) {
              extend(allModulesParams, obj);
              return
          }
          if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                  enabled: true
              }
          }
          if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
              params[moduleParamName].auto = true
          }
          if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
              params[moduleParamName].auto = true
          }
          if (!(moduleParamName in params && "enabled" in moduleParams)) {
              extend(allModulesParams, obj);
              return
          }
          if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
              params[moduleParamName].enabled = true
          }
          if (!params[moduleParamName]) params[moduleParamName] = {
              enabled: false
          };
          extend(allModulesParams, obj)
      }
  }
  const prototypes = {
      eventsEmitter: eventsEmitter,
      update: update,
      translate: translate,
      transition: transition,
      slide: slide,
      loop: loop,
      grabCursor: grabCursor,
      events: events$1,
      breakpoints: breakpoints,
      checkOverflow: checkOverflow$1,
      classes: classes
  };
  const extendedDefaults = {};
  class Swiper {
      constructor() {
          let el;
          let params;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key]
          }
          if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
              params = args[0]
          } else {
              [el, params] = args
          }
          if (!params) params = {};
          params = extend({}, params);
          if (el && !params.el) params.el = el;
          const document = getDocument();
          if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
              const swipers = [];
              document.querySelectorAll(params.el).forEach(containerEl => {
                  const newParams = extend({}, params, {
                      el: containerEl
                  });
                  swipers.push(new Swiper(newParams))
              });
              return swipers
          }
          const swiper = this;
          swiper.__swiper__ = true;
          swiper.support = getSupport();
          swiper.device = getDevice({
              userAgent: params.userAgent
          });
          swiper.browser = getBrowser();
          swiper.eventsListeners = {};
          swiper.eventsAnyListeners = [];
          swiper.modules = [...swiper.__modules__];
          if (params.modules && Array.isArray(params.modules)) {
              swiper.modules.push(...params.modules)
          }
          const allModulesParams = {};
          swiper.modules.forEach(mod => {
              mod({
                  params: params,
                  swiper: swiper,
                  extendParams: moduleExtendParams(params, allModulesParams),
                  on: swiper.on.bind(swiper),
                  once: swiper.once.bind(swiper),
                  off: swiper.off.bind(swiper),
                  emit: swiper.emit.bind(swiper)
              })
          });
          const swiperParams = extend({}, defaults, allModulesParams);
          swiper.params = extend({}, swiperParams, extendedDefaults, params);
          swiper.originalParams = extend({}, swiper.params);
          swiper.passedParams = extend({}, params);
          if (swiper.params && swiper.params.on) {
              Object.keys(swiper.params.on).forEach(eventName => {
                  swiper.on(eventName, swiper.params.on[eventName])
              })
          }
          if (swiper.params && swiper.params.onAny) {
              swiper.onAny(swiper.params.onAny)
          }
          Object.assign(swiper, {
              enabled: swiper.params.enabled,
              el: el,
              classNames: [],
              slides: [],
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal() {
                  return swiper.params.direction === "horizontal"
              },
              isVertical() {
                  return swiper.params.direction === "vertical"
              },
              activeIndex: 0,
              realIndex: 0,
              isBeginning: true,
              isEnd: false,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: false,
              cssOverflowAdjustment() {
                  return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
              },
              allowSlideNext: swiper.params.allowSlideNext,
              allowSlidePrev: swiper.params.allowSlidePrev,
              touchEventsData: {
                  isTouched: undefined,
                  isMoved: undefined,
                  allowTouchCallbacks: undefined,
                  touchStartTime: undefined,
                  isScrolling: undefined,
                  currentTranslate: undefined,
                  startTranslate: undefined,
                  allowThresholdMove: undefined,
                  focusableElements: swiper.params.focusableElements,
                  lastClickTime: 0,
                  clickTimeout: undefined,
                  velocities: [],
                  allowMomentumBounce: undefined,
                  startMoving: undefined,
                  pointerId: null,
                  touchId: null
              },
              allowClick: true,
              allowTouchMove: swiper.params.allowTouchMove,
              touches: {
                  startX: 0,
                  startY: 0,
                  currentX: 0,
                  currentY: 0,
                  diff: 0
              },
              imagesToLoad: [],
              imagesLoaded: 0
          });
          swiper.emit("_swiper");
          if (swiper.params.init) {
              swiper.init()
          }
          return swiper
      }
      getDirectionLabel(property) {
          if (this.isHorizontal()) {
              return property
          }
          return {
              width: "height",
              "margin-top": "margin-left",
              "margin-bottom ": "margin-right",
              "margin-left": "margin-top",
              "margin-right": "margin-bottom",
              "padding-left": "padding-top",
              "padding-right": "padding-bottom",
              marginRight: "marginBottom"
          } [property]
      }
      getSlideIndex(slideEl) {
          const {
              slidesEl,
              params
          } = this;
          const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
          const firstSlideIndex = elementIndex(slides[0]);
          return elementIndex(slideEl) - firstSlideIndex
      }
      getSlideIndexByData(index) {
          return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0])
      }
      recalcSlides() {
          const swiper = this;
          const {
              slidesEl,
              params
          } = swiper;
          swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`)
      }
      enable() {
          const swiper = this;
          if (swiper.enabled) return;
          swiper.enabled = true;
          if (swiper.params.grabCursor) {
              swiper.setGrabCursor()
          }
          swiper.emit("enable")
      }
      disable() {
          const swiper = this;
          if (!swiper.enabled) return;
          swiper.enabled = false;
          if (swiper.params.grabCursor) {
              swiper.unsetGrabCursor()
          }
          swiper.emit("disable")
      }
      setProgress(progress, speed) {
          const swiper = this;
          progress = Math.min(Math.max(progress, 0), 1);
          const min = swiper.minTranslate();
          const max = swiper.maxTranslate();
          const current = (max - min) * progress + min;
          swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses()
      }
      emitContainerClasses() {
          const swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          const cls = swiper.el.className.split(" ").filter(className => {
              return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0
          });
          swiper.emit("_containerClasses", cls.join(" "))
      }
      getSlideClasses(slideEl) {
          const swiper = this;
          if (swiper.destroyed) return "";
          return slideEl.className.split(" ").filter(className => {
              return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0
          }).join(" ")
      }
      emitSlidesClasses() {
          const swiper = this;
          if (!swiper.params._emitClasses || !swiper.el) return;
          const updates = [];
          swiper.slides.forEach(slideEl => {
              const classNames = swiper.getSlideClasses(slideEl);
              updates.push({
                  slideEl: slideEl,
                  classNames: classNames
              });
              swiper.emit("_slideClass", slideEl, classNames)
          });
          swiper.emit("_slideClasses", updates)
      }
      slidesPerViewDynamic(view, exact) {
          if (view === void 0) {
              view = "current"
          }
          if (exact === void 0) {
              exact = false
          }
          const swiper = this;
          const {
              params,
              slides,
              slidesGrid,
              slidesSizesGrid,
              size: swiperSize,
              activeIndex
          } = swiper;
          let spv = 1;
          if (typeof params.slidesPerView === "number") return params.slidesPerView;
          if (params.centeredSlides) {
              let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
              let breakLoop;
              for (let i = activeIndex + 1; i < slides.length; i += 1) {
                  if (slides[i] && !breakLoop) {
                      slideSize += slides[i].swiperSlideSize;
                      spv += 1;
                      if (slideSize > swiperSize) breakLoop = true
                  }
              }
              for (let i = activeIndex - 1; i >= 0; i -= 1) {
                  if (slides[i] && !breakLoop) {
                      slideSize += slides[i].swiperSlideSize;
                      spv += 1;
                      if (slideSize > swiperSize) breakLoop = true
                  }
              }
          } else {
              if (view === "current") {
                  for (let i = activeIndex + 1; i < slides.length; i += 1) {
                      const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                      if (slideInView) {
                          spv += 1
                      }
                  }
              } else {
                  for (let i = activeIndex - 1; i >= 0; i -= 1) {
                      const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                      if (slideInView) {
                          spv += 1
                      }
                  }
              }
          }
          return spv
      }
      update() {
          const swiper = this;
          if (!swiper || swiper.destroyed) return;
          const {
              snapGrid,
              params
          } = swiper;
          if (params.breakpoints) {
              swiper.setBreakpoint()
          } [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
              if (imageEl.complete) {
                  processLazyPreloader(swiper, imageEl)
              }
          });
          swiper.updateSize();
          swiper.updateSlides();
          swiper.updateProgress();
          swiper.updateSlidesClasses();

          function setTranslate() {
              const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
              const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
              swiper.setTranslate(newTranslate);
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses()
          }
          let translated;
          if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
              setTranslate();
              if (params.autoHeight) {
                  swiper.updateAutoHeight()
              }
          } else {
              if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                  const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                  translated = swiper.slideTo(slides.length - 1, 0, false, true)
              } else {
                  translated = swiper.slideTo(swiper.activeIndex, 0, false, true)
              }
              if (!translated) {
                  setTranslate()
              }
          }
          if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
              swiper.checkOverflow()
          }
          swiper.emit("update")
      }
      changeDirection(newDirection, needUpdate) {
          if (needUpdate === void 0) {
              needUpdate = true
          }
          const swiper = this;
          const currentDirection = swiper.params.direction;
          if (!newDirection) {
              newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal"
          }
          if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
              return swiper
          }
          swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
          swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
          swiper.emitContainerClasses();
          swiper.params.direction = newDirection;
          swiper.slides.forEach(slideEl => {
              if (newDirection === "vertical") {
                  slideEl.style.width = ""
              } else {
                  slideEl.style.height = ""
              }
          });
          swiper.emit("changeDirection");
          if (needUpdate) swiper.update();
          return swiper
      }
      changeLanguageDirection(direction) {
          const swiper = this;
          if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
          swiper.rtl = direction === "rtl";
          swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
          if (swiper.rtl) {
              swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
              swiper.el.dir = "rtl"
          } else {
              swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
              swiper.el.dir = "ltr"
          }
          swiper.update()
      }
      mount(element) {
          const swiper = this;
          if (swiper.mounted) return true;
          let el = element || swiper.params.el;
          if (typeof el === "string") {
              el = document.querySelector(el)
          }
          if (!el) {
              return false
          }
          el.swiper = swiper;
          if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === "SWIPER-CONTAINER") {
              swiper.isElement = true
          }
          const getWrapperSelector = () => {
              return `.${(swiper.params.wrapperClass||"").trim().split(" ").join(".")}`
          };
          const getWrapper = () => {
              if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                  const res = el.shadowRoot.querySelector(getWrapperSelector());
                  return res
              }
              return elementChildren(el, getWrapperSelector())[0]
          };
          let wrapperEl = getWrapper();
          if (!wrapperEl && swiper.params.createElements) {
              wrapperEl = createElement("div", swiper.params.wrapperClass);
              el.append(wrapperEl);
              elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
                  wrapperEl.append(slideEl)
              })
          }
          Object.assign(swiper, {
              el: el,
              wrapperEl: wrapperEl,
              slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
              hostEl: swiper.isElement ? el.parentNode.host : el,
              mounted: true,
              rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
              rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
              wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
          });
          return true
      }
      init(el) {
          const swiper = this;
          if (swiper.initialized) return swiper;
          const mounted = swiper.mount(el);
          if (mounted === false) return swiper;
          swiper.emit("beforeInit");
          if (swiper.params.breakpoints) {
              swiper.setBreakpoint()
          }
          swiper.addClasses();
          swiper.updateSize();
          swiper.updateSlides();
          if (swiper.params.watchOverflow) {
              swiper.checkOverflow()
          }
          if (swiper.params.grabCursor && swiper.enabled) {
              swiper.setGrabCursor()
          }
          if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
              swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true)
          } else {
              swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true)
          }
          if (swiper.params.loop) {
              swiper.loopCreate()
          }
          swiper.attachEvents();
          const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
          if (swiper.isElement) {
              lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'))
          }
          lazyElements.forEach(imageEl => {
              if (imageEl.complete) {
                  processLazyPreloader(swiper, imageEl)
              } else {
                  imageEl.addEventListener("load", e => {
                      processLazyPreloader(swiper, e.target)
                  })
              }
          });
          preload(swiper);
          swiper.initialized = true;
          preload(swiper);
          swiper.emit("init");
          swiper.emit("afterInit");
          return swiper
      }
      destroy(deleteInstance, cleanStyles) {
          if (deleteInstance === void 0) {
              deleteInstance = true
          }
          if (cleanStyles === void 0) {
              cleanStyles = true
          }
          const swiper = this;
          const {
              params,
              el,
              wrapperEl,
              slides
          } = swiper;
          if (typeof swiper.params === "undefined" || swiper.destroyed) {
              return null
          }
          swiper.emit("beforeDestroy");
          swiper.initialized = false;
          swiper.detachEvents();
          if (params.loop) {
              swiper.loopDestroy()
          }
          if (cleanStyles) {
              swiper.removeClasses();
              el.removeAttribute("style");
              wrapperEl.removeAttribute("style");
              if (slides && slides.length) {
                  slides.forEach(slideEl => {
                      slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                      slideEl.removeAttribute("style");
                      slideEl.removeAttribute("data-swiper-slide-index")
                  })
              }
          }
          swiper.emit("destroy");
          Object.keys(swiper.eventsListeners).forEach(eventName => {
              swiper.off(eventName)
          });
          if (deleteInstance !== false) {
              swiper.el.swiper = null;
              deleteProps(swiper)
          }
          swiper.destroyed = true;
          return null
      }
      static extendDefaults(newDefaults) {
          extend(extendedDefaults, newDefaults)
      }
      static get extendedDefaults() {
          return extendedDefaults
      }
      static get defaults() {
          return defaults
      }
      static installModule(mod) {
          if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
          const modules = Swiper.prototype.__modules__;
          if (typeof mod === "function" && modules.indexOf(mod) < 0) {
              modules.push(mod)
          }
      }
      static use(module) {
          if (Array.isArray(module)) {
              module.forEach(m => Swiper.installModule(m));
              return Swiper
          }
          Swiper.installModule(module);
          return Swiper
      }
  }
  Object.keys(prototypes).forEach(prototypeGroup => {
      Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
          Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod]
      })
  });
  Swiper.use([Resize, Observer]);

  function Virtual(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      extendParams({
          virtual: {
              enabled: false,
              slides: [],
              cache: true,
              renderSlide: null,
              renderExternal: null,
              renderExternalUpdate: true,
              addSlidesBefore: 0,
              addSlidesAfter: 0
          }
      });
      let cssModeTimeout;
      const document = getDocument();
      swiper.virtual = {
          cache: {},
          from: undefined,
          to: undefined,
          slides: [],
          offset: 0,
          slidesGrid: []
      };
      const tempDOM = document.createElement("div");

      function renderSlide(slide, index) {
          const params = swiper.params.virtual;
          if (params.cache && swiper.virtual.cache[index]) {
              return swiper.virtual.cache[index]
          }
          let slideEl;
          if (params.renderSlide) {
              slideEl = params.renderSlide.call(swiper, slide, index);
              if (typeof slideEl === "string") {
                  tempDOM.innerHTML = slideEl;
                  slideEl = tempDOM.children[0]
              }
          } else if (swiper.isElement) {
              slideEl = createElement("swiper-slide")
          } else {
              slideEl = createElement("div", swiper.params.slideClass)
          }
          slideEl.setAttribute("data-swiper-slide-index", index);
          if (!params.renderSlide) {
              slideEl.innerHTML = slide
          }
          if (params.cache) {
              swiper.virtual.cache[index] = slideEl
          }
          return slideEl
      }

      function update(force) {
          const {
              slidesPerView,
              slidesPerGroup,
              centeredSlides,
              loop: isLoop
          } = swiper.params;
          const {
              addSlidesBefore,
              addSlidesAfter
          } = swiper.params.virtual;
          const {
              from: previousFrom,
              to: previousTo,
              slides,
              slidesGrid: previousSlidesGrid,
              offset: previousOffset
          } = swiper.virtual;
          if (!swiper.params.cssMode) {
              swiper.updateActiveIndex()
          }
          const activeIndex = swiper.activeIndex || 0;
          let offsetProp;
          if (swiper.rtlTranslate) offsetProp = "right";
          else offsetProp = swiper.isHorizontal() ? "left" : "top";
          let slidesAfter;
          let slidesBefore;
          if (centeredSlides) {
              slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
              slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore
          } else {
              slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
              slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore
          }
          let from = activeIndex - slidesBefore;
          let to = activeIndex + slidesAfter;
          if (!isLoop) {
              from = Math.max(from, 0);
              to = Math.min(to, slides.length - 1)
          }
          let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
          if (isLoop && activeIndex >= slidesBefore) {
              from -= slidesBefore;
              if (!centeredSlides) offset += swiper.slidesGrid[0]
          } else if (isLoop && activeIndex < slidesBefore) {
              from = -slidesBefore;
              if (centeredSlides) offset += swiper.slidesGrid[0]
          }
          Object.assign(swiper.virtual, {
              from: from,
              to: to,
              offset: offset,
              slidesGrid: swiper.slidesGrid,
              slidesBefore: slidesBefore,
              slidesAfter: slidesAfter
          });

          function onRendered() {
              swiper.updateSlides();
              swiper.updateProgress();
              swiper.updateSlidesClasses();
              emit("virtualUpdate")
          }
          if (previousFrom === from && previousTo === to && !force) {
              if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                  swiper.slides.forEach(slideEl => {
                      slideEl.style[offsetProp] = `${offset-Math.abs(swiper.cssOverflowAdjustment())}px`
                  })
              }
              swiper.updateProgress();
              emit("virtualUpdate");
              return
          }
          if (swiper.params.virtual.renderExternal) {
              swiper.params.virtual.renderExternal.call(swiper, {
                  offset: offset,
                  from: from,
                  to: to,
                  slides: function getSlides() {
                      const slidesToRender = [];
                      for (let i = from; i <= to; i += 1) {
                          slidesToRender.push(slides[i])
                      }
                      return slidesToRender
                  }()
              });
              if (swiper.params.virtual.renderExternalUpdate) {
                  onRendered()
              } else {
                  emit("virtualUpdate")
              }
              return
          }
          const prependIndexes = [];
          const appendIndexes = [];
          const getSlideIndex = index => {
              let slideIndex = index;
              if (index < 0) {
                  slideIndex = slides.length + index
              } else if (slideIndex >= slides.length) {
                  slideIndex = slideIndex - slides.length
              }
              return slideIndex
          };
          if (force) {
              swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach(slideEl => {
                  slideEl.remove()
              })
          } else {
              for (let i = previousFrom; i <= previousTo; i += 1) {
                  if (i < from || i > to) {
                      const slideIndex = getSlideIndex(i);
                      swiper.slides.filter(el => el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach(slideEl => {
                          slideEl.remove()
                      })
                  }
              }
          }
          const loopFrom = isLoop ? -slides.length : 0;
          const loopTo = isLoop ? slides.length * 2 : slides.length;
          for (let i = loopFrom; i < loopTo; i += 1) {
              if (i >= from && i <= to) {
                  const slideIndex = getSlideIndex(i);
                  if (typeof previousTo === "undefined" || force) {
                      appendIndexes.push(slideIndex)
                  } else {
                      if (i > previousTo) appendIndexes.push(slideIndex);
                      if (i < previousFrom) prependIndexes.push(slideIndex)
                  }
              }
          }
          appendIndexes.forEach(index => {
              swiper.slidesEl.append(renderSlide(slides[index], index))
          });
          if (isLoop) {
              for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
                  const index = prependIndexes[i];
                  swiper.slidesEl.prepend(renderSlide(slides[index], index))
              }
          } else {
              prependIndexes.sort((a, b) => b - a);
              prependIndexes.forEach(index => {
                  swiper.slidesEl.prepend(renderSlide(slides[index], index))
              })
          }
          elementChildren(swiper.slidesEl, ".swiper-slide, swiper-slide").forEach(slideEl => {
              slideEl.style[offsetProp] = `${offset-Math.abs(swiper.cssOverflowAdjustment())}px`
          });
          onRendered()
      }

      function appendSlide(slides) {
          if (typeof slides === "object" && "length" in slides) {
              for (let i = 0; i < slides.length; i += 1) {
                  if (slides[i]) swiper.virtual.slides.push(slides[i])
              }
          } else {
              swiper.virtual.slides.push(slides)
          }
          update(true)
      }

      function prependSlide(slides) {
          const activeIndex = swiper.activeIndex;
          let newActiveIndex = activeIndex + 1;
          let numberOfNewSlides = 1;
          if (Array.isArray(slides)) {
              for (let i = 0; i < slides.length; i += 1) {
                  if (slides[i]) swiper.virtual.slides.unshift(slides[i])
              }
              newActiveIndex = activeIndex + slides.length;
              numberOfNewSlides = slides.length
          } else {
              swiper.virtual.slides.unshift(slides)
          }
          if (swiper.params.virtual.cache) {
              const cache = swiper.virtual.cache;
              const newCache = {};
              Object.keys(cache).forEach(cachedIndex => {
                  const cachedEl = cache[cachedIndex];
                  const cachedElIndex = cachedEl.getAttribute("data-swiper-slide-index");
                  if (cachedElIndex) {
                      cachedEl.setAttribute("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides)
                  }
                  newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl
              });
              swiper.virtual.cache = newCache
          }
          update(true);
          swiper.slideTo(newActiveIndex, 0)
      }

      function removeSlide(slidesIndexes) {
          if (typeof slidesIndexes === "undefined" || slidesIndexes === null) return;
          let activeIndex = swiper.activeIndex;
          if (Array.isArray(slidesIndexes)) {
              for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                  if (swiper.params.virtual.cache) {
                      delete swiper.virtual.cache[slidesIndexes[i]];
                      Object.keys(swiper.virtual.cache).forEach(key => {
                          if (key > slidesIndexes) {
                              swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                              swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
                              delete swiper.virtual.cache[key]
                          }
                      })
                  }
                  swiper.virtual.slides.splice(slidesIndexes[i], 1);
                  if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                  activeIndex = Math.max(activeIndex, 0)
              }
          } else {
              if (swiper.params.virtual.cache) {
                  delete swiper.virtual.cache[slidesIndexes];
                  Object.keys(swiper.virtual.cache).forEach(key => {
                      if (key > slidesIndexes) {
                          swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                          swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
                          delete swiper.virtual.cache[key]
                      }
                  })
              }
              swiper.virtual.slides.splice(slidesIndexes, 1);
              if (slidesIndexes < activeIndex) activeIndex -= 1;
              activeIndex = Math.max(activeIndex, 0)
          }
          update(true);
          swiper.slideTo(activeIndex, 0)
      }

      function removeAllSlides() {
          swiper.virtual.slides = [];
          if (swiper.params.virtual.cache) {
              swiper.virtual.cache = {}
          }
          update(true);
          swiper.slideTo(0, 0)
      }
      on("beforeInit", () => {
          if (!swiper.params.virtual.enabled) return;
          let domSlidesAssigned;
          if (typeof swiper.passedParams.virtual.slides === "undefined") {
              const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
              if (slides && slides.length) {
                  swiper.virtual.slides = [...slides];
                  domSlidesAssigned = true;
                  slides.forEach((slideEl, slideIndex) => {
                      slideEl.setAttribute("data-swiper-slide-index", slideIndex);
                      swiper.virtual.cache[slideIndex] = slideEl;
                      slideEl.remove()
                  })
              }
          }
          if (!domSlidesAssigned) {
              swiper.virtual.slides = swiper.params.virtual.slides
          }
          swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
          swiper.params.watchSlidesProgress = true;
          swiper.originalParams.watchSlidesProgress = true;
          update()
      });
      on("setTranslate", () => {
          if (!swiper.params.virtual.enabled) return;
          if (swiper.params.cssMode && !swiper._immediateVirtual) {
              clearTimeout(cssModeTimeout);
              cssModeTimeout = setTimeout(() => {
                  update()
              }, 100)
          } else {
              update()
          }
      });
      on("init update resize", () => {
          if (!swiper.params.virtual.enabled) return;
          if (swiper.params.cssMode) {
              setCSSProperty(swiper.wrapperEl, "--swiper-virtual-size", `${swiper.virtualSize}px`)
          }
      });
      Object.assign(swiper.virtual, {
          appendSlide: appendSlide,
          prependSlide: prependSlide,
          removeSlide: removeSlide,
          removeAllSlides: removeAllSlides,
          update: update
      })
  }

  function Keyboard(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const document = getDocument();
      const window = getWindow();
      swiper.keyboard = {
          enabled: false
      };
      extendParams({
          keyboard: {
              enabled: false,
              onlyInViewport: true,
              pageUpDown: true
          }
      });

      function handle(event) {
          if (!swiper.enabled) return;
          const {
              rtlTranslate: rtl
          } = swiper;
          let e = event;
          if (e.originalEvent) e = e.originalEvent;
          const kc = e.keyCode || e.charCode;
          const pageUpDown = swiper.params.keyboard.pageUpDown;
          const isPageUp = pageUpDown && kc === 33;
          const isPageDown = pageUpDown && kc === 34;
          const isArrowLeft = kc === 37;
          const isArrowRight = kc === 39;
          const isArrowUp = kc === 38;
          const isArrowDown = kc === 40;
          if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
              return false
          }
          if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
              return false
          }
          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
              return undefined
          }
          if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === "input" || document.activeElement.nodeName.toLowerCase() === "textarea")) {
              return undefined
          }
          if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
              let inView = false;
              if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
                  return undefined
              }
              const el = swiper.el;
              const swiperWidth = el.clientWidth;
              const swiperHeight = el.clientHeight;
              const windowWidth = window.innerWidth;
              const windowHeight = window.innerHeight;
              const swiperOffset = elementOffset(el);
              if (rtl) swiperOffset.left -= el.scrollLeft;
              const swiperCoord = [
                  [swiperOffset.left, swiperOffset.top],
                  [swiperOffset.left + swiperWidth, swiperOffset.top],
                  [swiperOffset.left, swiperOffset.top + swiperHeight],
                  [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]
              ];
              for (let i = 0; i < swiperCoord.length; i += 1) {
                  const point = swiperCoord[i];
                  if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                      if (point[0] === 0 && point[1] === 0) continue;
                      inView = true
                  }
              }
              if (!inView) return undefined
          }
          if (swiper.isHorizontal()) {
              if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                  if (e.preventDefault) e.preventDefault();
                  else e.returnValue = false
              }
              if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
              if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev()
          } else {
              if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                  if (e.preventDefault) e.preventDefault();
                  else e.returnValue = false
              }
              if (isPageDown || isArrowDown) swiper.slideNext();
              if (isPageUp || isArrowUp) swiper.slidePrev()
          }
          emit("keyPress", kc);
          return undefined
      }

      function enable() {
          if (swiper.keyboard.enabled) return;
          document.addEventListener("keydown", handle);
          swiper.keyboard.enabled = true
      }

      function disable() {
          if (!swiper.keyboard.enabled) return;
          document.removeEventListener("keydown", handle);
          swiper.keyboard.enabled = false
      }
      on("init", () => {
          if (swiper.params.keyboard.enabled) {
              enable()
          }
      });
      on("destroy", () => {
          if (swiper.keyboard.enabled) {
              disable()
          }
      });
      Object.assign(swiper.keyboard, {
          enable: enable,
          disable: disable
      })
  }

  function Mousewheel(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const window = getWindow();
      extendParams({
          mousewheel: {
              enabled: false,
              releaseOnEdges: false,
              invert: false,
              forceToAxis: false,
              sensitivity: 1,
              eventsTarget: "container",
              thresholdDelta: null,
              thresholdTime: null,
              noMousewheelClass: "swiper-no-mousewheel"
          }
      });
      swiper.mousewheel = {
          enabled: false
      };
      let timeout;
      let lastScrollTime = now();
      let lastEventBeforeSnap;
      const recentWheelEvents = [];

      function normalize(e) {
          const PIXEL_STEP = 10;
          const LINE_HEIGHT = 40;
          const PAGE_HEIGHT = 800;
          let sX = 0;
          let sY = 0;
          let pX = 0;
          let pY = 0;
          if ("detail" in e) {
              sY = e.detail
          }
          if ("wheelDelta" in e) {
              sY = -e.wheelDelta / 120
          }
          if ("wheelDeltaY" in e) {
              sY = -e.wheelDeltaY / 120
          }
          if ("wheelDeltaX" in e) {
              sX = -e.wheelDeltaX / 120
          }
          if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
              sX = sY;
              sY = 0
          }
          pX = sX * PIXEL_STEP;
          pY = sY * PIXEL_STEP;
          if ("deltaY" in e) {
              pY = e.deltaY
          }
          if ("deltaX" in e) {
              pX = e.deltaX
          }
          if (e.shiftKey && !pX) {
              pX = pY;
              pY = 0
          }
          if ((pX || pY) && e.deltaMode) {
              if (e.deltaMode === 1) {
                  pX *= LINE_HEIGHT;
                  pY *= LINE_HEIGHT
              } else {
                  pX *= PAGE_HEIGHT;
                  pY *= PAGE_HEIGHT
              }
          }
          if (pX && !sX) {
              sX = pX < 1 ? -1 : 1
          }
          if (pY && !sY) {
              sY = pY < 1 ? -1 : 1
          }
          return {
              spinX: sX,
              spinY: sY,
              pixelX: pX,
              pixelY: pY
          }
      }

      function handleMouseEnter() {
          if (!swiper.enabled) return;
          swiper.mouseEntered = true
      }

      function handleMouseLeave() {
          if (!swiper.enabled) return;
          swiper.mouseEntered = false
      }

      function animateSlider(newEvent) {
          if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
              return false
          }
          if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
              return false
          }
          if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
              return true
          }
          if (newEvent.direction < 0) {
              if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                  swiper.slideNext();
                  emit("scroll", newEvent.raw)
              }
          } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
              swiper.slidePrev();
              emit("scroll", newEvent.raw)
          }
          lastScrollTime = (new window.Date).getTime();
          return false
      }

      function releaseScroll(newEvent) {
          const params = swiper.params.mousewheel;
          if (newEvent.direction < 0) {
              if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                  return true
              }
          } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
              return true
          }
          return false
      }

      function handle(event) {
          let e = event;
          let disableParentSwiper = true;
          if (!swiper.enabled) return;
          if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
          const params = swiper.params.mousewheel;
          if (swiper.params.cssMode) {
              e.preventDefault()
          }
          let targetEl = swiper.el;
          if (swiper.params.mousewheel.eventsTarget !== "container") {
              targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget)
          }
          const targetElContainsTarget = targetEl && targetEl.contains(e.target);
          if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
          if (e.originalEvent) e = e.originalEvent;
          let delta = 0;
          const rtlFactor = swiper.rtlTranslate ? -1 : 1;
          const data = normalize(e);
          if (params.forceToAxis) {
              if (swiper.isHorizontal()) {
                  if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
                  else return true
              } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
              else return true
          } else {
              delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY
          }
          if (delta === 0) return true;
          if (params.invert) delta = -delta;
          let positions = swiper.getTranslate() + delta * params.sensitivity;
          if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
          if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
          disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
          if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
          if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
              const newEvent = {
                  time: now(),
                  delta: Math.abs(delta),
                  direction: Math.sign(delta),
                  raw: event
              };
              if (recentWheelEvents.length >= 2) {
                  recentWheelEvents.shift()
              }
              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              recentWheelEvents.push(newEvent);
              if (prevEvent) {
                  if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                      animateSlider(newEvent)
                  }
              } else {
                  animateSlider(newEvent)
              }
              if (releaseScroll(newEvent)) {
                  return true
              }
          } else {
              const newEvent = {
                  time: now(),
                  delta: Math.abs(delta),
                  direction: Math.sign(delta)
              };
              const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
              if (!ignoreWheelEvents) {
                  lastEventBeforeSnap = undefined;
                  let position = swiper.getTranslate() + delta * params.sensitivity;
                  const wasBeginning = swiper.isBeginning;
                  const wasEnd = swiper.isEnd;
                  if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                  if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                  swiper.setTransition(0);
                  swiper.setTranslate(position);
                  swiper.updateProgress();
                  swiper.updateActiveIndex();
                  swiper.updateSlidesClasses();
                  if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                      swiper.updateSlidesClasses()
                  }
                  if (swiper.params.loop) {
                      swiper.loopFix({
                          direction: newEvent.direction < 0 ? "next" : "prev",
                          byMousewheel: true
                      })
                  }
                  if (swiper.params.freeMode.sticky) {
                      clearTimeout(timeout);
                      timeout = undefined;
                      if (recentWheelEvents.length >= 15) {
                          recentWheelEvents.shift()
                      }
                      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
                      const firstEvent = recentWheelEvents[0];
                      recentWheelEvents.push(newEvent);
                      if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                          recentWheelEvents.splice(0)
                      } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                          const snapToThreshold = delta > 0 ? .8 : .2;
                          lastEventBeforeSnap = newEvent;
                          recentWheelEvents.splice(0);
                          timeout = nextTick(() => {
                              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold)
                          }, 0)
                      }
                      if (!timeout) {
                          timeout = nextTick(() => {
                              const snapToThreshold = .5;
                              lastEventBeforeSnap = newEvent;
                              recentWheelEvents.splice(0);
                              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold)
                          }, 500)
                      }
                  }
                  if (!ignoreWheelEvents) emit("scroll", e);
                  if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                  if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
                      return true
                  }
              }
          }
          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
          return false
      }

      function events(method) {
          let targetEl = swiper.el;
          if (swiper.params.mousewheel.eventsTarget !== "container") {
              targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget)
          }
          targetEl[method]("mouseenter", handleMouseEnter);
          targetEl[method]("mouseleave", handleMouseLeave);
          targetEl[method]("wheel", handle)
      }

      function enable() {
          if (swiper.params.cssMode) {
              swiper.wrapperEl.removeEventListener("wheel", handle);
              return true
          }
          if (swiper.mousewheel.enabled) return false;
          events("addEventListener");
          swiper.mousewheel.enabled = true;
          return true
      }

      function disable() {
          if (swiper.params.cssMode) {
              swiper.wrapperEl.addEventListener(event, handle);
              return true
          }
          if (!swiper.mousewheel.enabled) return false;
          events("removeEventListener");
          swiper.mousewheel.enabled = false;
          return true
      }
      on("init", () => {
          if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
              disable()
          }
          if (swiper.params.mousewheel.enabled) enable()
      });
      on("destroy", () => {
          if (swiper.params.cssMode) {
              enable()
          }
          if (swiper.mousewheel.enabled) disable()
      });
      Object.assign(swiper.mousewheel, {
          enable: enable,
          disable: disable
      })
  }

  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
      if (swiper.params.createElements) {
          Object.keys(checkProps).forEach(key => {
              if (!params[key] && params.auto === true) {
                  let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                  if (!element) {
                      element = createElement("div", checkProps[key]);
                      element.className = checkProps[key];
                      swiper.el.append(element)
                  }
                  params[key] = element;
                  originalParams[key] = element
              }
          })
      }
      return params
  }

  function Navigation(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      extendParams({
          navigation: {
              nextEl: null,
              prevEl: null,
              hideOnClick: false,
              disabledClass: "swiper-button-disabled",
              hiddenClass: "swiper-button-hidden",
              lockClass: "swiper-button-lock",
              navigationDisabledClass: "swiper-navigation-disabled"
          }
      });
      swiper.navigation = {
          nextEl: null,
          prevEl: null
      };
      const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

      function getEl(el) {
          let res;
          if (el && typeof el === "string" && swiper.isElement) {
              res = swiper.el.querySelector(el);
              if (res) return res
          }
          if (el) {
              if (typeof el === "string") res = [...document.querySelectorAll(el)];
              if (swiper.params.uniqueNavElements && typeof el === "string" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
                  res = swiper.el.querySelector(el)
              }
          }
          if (el && !res) return el;
          return res
      }

      function toggleEl(el, disabled) {
          const params = swiper.params.navigation;
          el = makeElementsArray(el);
          el.forEach(subEl => {
              if (subEl) {
                  subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                  if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                  if (swiper.params.watchOverflow && swiper.enabled) {
                      subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass)
                  }
              }
          })
      }

      function update() {
          const {
              nextEl,
              prevEl
          } = swiper.navigation;
          if (swiper.params.loop) {
              toggleEl(prevEl, false);
              toggleEl(nextEl, false);
              return
          }
          toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
          toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind)
      }

      function onPrevClick(e) {
          e.preventDefault();
          if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
          swiper.slidePrev();
          emit("navigationPrev")
      }

      function onNextClick(e) {
          e.preventDefault();
          if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
          swiper.slideNext();
          emit("navigationNext")
      }

      function init() {
          const params = swiper.params.navigation;
          swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
              nextEl: "swiper-button-next",
              prevEl: "swiper-button-prev"
          });
          if (!(params.nextEl || params.prevEl)) return;
          let nextEl = getEl(params.nextEl);
          let prevEl = getEl(params.prevEl);
          Object.assign(swiper.navigation, {
              nextEl: nextEl,
              prevEl: prevEl
          });
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          const initButton = (el, dir) => {
              if (el) {
                  el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick)
              }
              if (!swiper.enabled && el) {
                  el.classList.add(...params.lockClass.split(" "))
              }
          };
          nextEl.forEach(el => initButton(el, "next"));
          prevEl.forEach(el => initButton(el, "prev"))
      }

      function destroy() {
          let {
              nextEl,
              prevEl
          } = swiper.navigation;
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          const destroyButton = (el, dir) => {
              el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
              el.classList.remove(...swiper.params.navigation.disabledClass.split(" "))
          };
          nextEl.forEach(el => destroyButton(el, "next"));
          prevEl.forEach(el => destroyButton(el, "prev"))
      }
      on("init", () => {
          if (swiper.params.navigation.enabled === false) {
              disable()
          } else {
              init();
              update()
          }
      });
      on("toEdge fromEdge lock unlock", () => {
          update()
      });
      on("destroy", () => {
          destroy()
      });
      on("enable disable", () => {
          let {
              nextEl,
              prevEl
          } = swiper.navigation;
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          if (swiper.enabled) {
              update();
              return
          } [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.add(swiper.params.navigation.lockClass))
      });
      on("click", (_s, e) => {
          let {
              nextEl,
              prevEl
          } = swiper.navigation;
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          const targetEl = e.target;
          if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
              if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
              let isHidden;
              if (nextEl.length) {
                  isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass)
              } else if (prevEl.length) {
                  isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass)
              }
              if (isHidden === true) {
                  emit("navigationShow")
              } else {
                  emit("navigationHide")
              } [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass))
          }
      });
      const enable = () => {
          swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
          init();
          update()
      };
      const disable = () => {
          swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
          destroy()
      };
      Object.assign(swiper.navigation, {
          enable: enable,
          disable: disable,
          update: update,
          init: init,
          destroy: destroy
      })
  }

  function classesToSelector(classes) {
      if (classes === void 0) {
          classes = ""
      }
      return `.${classes.trim().replace(/([\.:!+\/])/g,"\\$1").replace(/ /g,".")}`
  }

  function Pagination(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const pfx = "swiper-pagination";
      extendParams({
          pagination: {
              el: null,
              bulletElement: "span",
              clickable: false,
              hideOnClick: false,
              renderBullet: null,
              renderProgressbar: null,
              renderFraction: null,
              renderCustom: null,
              progressbarOpposite: false,
              type: "bullets",
              dynamicBullets: false,
              dynamicMainBullets: 1,
              formatFractionCurrent: number => number,
              formatFractionTotal: number => number,
              bulletClass: `${pfx}-bullet`,
              bulletActiveClass: `${pfx}-bullet-active`,
              modifierClass: `${pfx}-`,
              currentClass: `${pfx}-current`,
              totalClass: `${pfx}-total`,
              hiddenClass: `${pfx}-hidden`,
              progressbarFillClass: `${pfx}-progressbar-fill`,
              progressbarOppositeClass: `${pfx}-progressbar-opposite`,
              clickableClass: `${pfx}-clickable`,
              lockClass: `${pfx}-lock`,
              horizontalClass: `${pfx}-horizontal`,
              verticalClass: `${pfx}-vertical`,
              paginationDisabledClass: `${pfx}-disabled`
          }
      });
      swiper.pagination = {
          el: null,
          bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;
      const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

      function isPaginationDisabled() {
          return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0
      }

      function setSideBullets(bulletEl, position) {
          const {
              bulletActiveClass
          } = swiper.params.pagination;
          if (!bulletEl) return;
          bulletEl = bulletEl[`${position==="prev"?"previous":"next"}ElementSibling`];
          if (bulletEl) {
              bulletEl.classList.add(`${bulletActiveClass}-${position}`);
              bulletEl = bulletEl[`${position==="prev"?"previous":"next"}ElementSibling`];
              if (bulletEl) {
                  bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`)
              }
          }
      }

      function onBulletClick(e) {
          const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
          if (!bulletEl) {
              return
          }
          e.preventDefault();
          const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
          if (swiper.params.loop) {
              if (swiper.realIndex === index) return;
              swiper.slideToLoop(index)
          } else {
              swiper.slideTo(index)
          }
      }

      function update() {
          const rtl = swiper.rtl;
          const params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          let el = swiper.pagination.el;
          el = makeElementsArray(el);
          let current;
          let previousIndex;
          const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
          const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
          if (swiper.params.loop) {
              previousIndex = swiper.previousRealIndex || 0;
              current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex
          } else if (typeof swiper.snapIndex !== "undefined") {
              current = swiper.snapIndex;
              previousIndex = swiper.previousSnapIndex
          } else {
              previousIndex = swiper.previousIndex || 0;
              current = swiper.activeIndex || 0
          }
          if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
              const bullets = swiper.pagination.bullets;
              let firstIndex;
              let lastIndex;
              let midIndex;
              if (params.dynamicBullets) {
                  bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                  el.forEach(subEl => {
                      subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize*(params.dynamicMainBullets+4)}px`
                  });
                  if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
                      dynamicBulletIndex += current - (previousIndex || 0);
                      if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                          dynamicBulletIndex = params.dynamicMainBullets - 1
                      } else if (dynamicBulletIndex < 0) {
                          dynamicBulletIndex = 0
                      }
                  }
                  firstIndex = Math.max(current - dynamicBulletIndex, 0);
                  lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                  midIndex = (lastIndex + firstIndex) / 2
              }
              bullets.forEach(bulletEl => {
                  const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === "string" && s.includes(" ") ? s.split(" ") : s).flat();
                  bulletEl.classList.remove(...classesToRemove)
              });
              if (el.length > 1) {
                  bullets.forEach(bullet => {
                      const bulletIndex = elementIndex(bullet);
                      if (bulletIndex === current) {
                          bullet.classList.add(...params.bulletActiveClass.split(" "))
                      } else if (swiper.isElement) {
                          bullet.setAttribute("part", "bullet")
                      }
                      if (params.dynamicBullets) {
                          if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "))
                          }
                          if (bulletIndex === firstIndex) {
                              setSideBullets(bullet, "prev")
                          }
                          if (bulletIndex === lastIndex) {
                              setSideBullets(bullet, "next")
                          }
                      }
                  })
              } else {
                  const bullet = bullets[current];
                  if (bullet) {
                      bullet.classList.add(...params.bulletActiveClass.split(" "))
                  }
                  if (swiper.isElement) {
                      bullets.forEach((bulletEl, bulletIndex) => {
                          bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet")
                      })
                  }
                  if (params.dynamicBullets) {
                      const firstDisplayedBullet = bullets[firstIndex];
                      const lastDisplayedBullet = bullets[lastIndex];
                      for (let i = firstIndex; i <= lastIndex; i += 1) {
                          if (bullets[i]) {
                              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(" "))
                          }
                      }
                      setSideBullets(firstDisplayedBullet, "prev");
                      setSideBullets(lastDisplayedBullet, "next")
                  }
              }
              if (params.dynamicBullets) {
                  const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                  const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                  const offsetProp = rtl ? "right" : "left";
                  bullets.forEach(bullet => {
                      bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`
                  })
              }
          }
          el.forEach((subEl, subElIndex) => {
              if (params.type === "fraction") {
                  subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {
                      fractionEl.textContent = params.formatFractionCurrent(current + 1)
                  });
                  subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {
                      totalEl.textContent = params.formatFractionTotal(total)
                  })
              }
              if (params.type === "progressbar") {
                  let progressbarDirection;
                  if (params.progressbarOpposite) {
                      progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"
                  } else {
                      progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical"
                  }
                  const scale = (current + 1) / total;
                  let scaleX = 1;
                  let scaleY = 1;
                  if (progressbarDirection === "horizontal") {
                      scaleX = scale
                  } else {
                      scaleY = scale
                  }
                  subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
                      progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                      progressEl.style.transitionDuration = `${swiper.params.speed}ms`
                  })
              }
              if (params.type === "custom" && params.renderCustom) {
                  subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                  if (subElIndex === 0) emit("paginationRender", subEl)
              } else {
                  if (subElIndex === 0) emit("paginationRender", subEl);
                  emit("paginationUpdate", subEl)
              }
              if (swiper.params.watchOverflow && swiper.enabled) {
                  subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass)
              }
          })
      }

      function render() {
          const params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
          let el = swiper.pagination.el;
          el = makeElementsArray(el);
          let paginationHTML = "";
          if (params.type === "bullets") {
              let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
              if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
                  numberOfBullets = slidesLength
              }
              for (let i = 0; i < numberOfBullets; i += 1) {
                  if (params.renderBullet) {
                      paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass)
                  } else {
                      paginationHTML += `<${params.bulletElement} ${swiper.isElement?'part="bullet"':""} class="${params.bulletClass}"></${params.bulletElement}>`
                  }
              }
          }
          if (params.type === "fraction") {
              if (params.renderFraction) {
                  paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass)
              } else {
                  paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`
              }
          }
          if (params.type === "progressbar") {
              if (params.renderProgressbar) {
                  paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass)
              } else {
                  paginationHTML = `<span class="${params.progressbarFillClass}"></span>`
              }
          }
          swiper.pagination.bullets = [];
          el.forEach(subEl => {
              if (params.type !== "custom") {
                  subEl.innerHTML = paginationHTML || ""
              }
              if (params.type === "bullets") {
                  swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)))
              }
          });
          if (params.type !== "custom") {
              emit("paginationRender", el[0])
          }
      }

      function init() {
          swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
              el: "swiper-pagination"
          });
          const params = swiper.params.pagination;
          if (!params.el) return;
          let el;
          if (typeof params.el === "string" && swiper.isElement) {
              el = swiper.el.querySelector(params.el)
          }
          if (!el && typeof params.el === "string") {
              el = [...document.querySelectorAll(params.el)]
          }
          if (!el) {
              el = params.el
          }
          if (!el || el.length === 0) return;
          if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
              el = [...swiper.el.querySelectorAll(params.el)];
              if (el.length > 1) {
                  el = el.filter(subEl => {
                      if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                      return true
                  })[0]
              }
          }
          if (Array.isArray(el) && el.length === 1) el = el[0];
          Object.assign(swiper.pagination, {
              el: el
          });
          el = makeElementsArray(el);
          el.forEach(subEl => {
              if (params.type === "bullets" && params.clickable) {
                  subEl.classList.add(...(params.clickableClass || "").split(" "))
              }
              subEl.classList.add(params.modifierClass + params.type);
              subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
              if (params.type === "bullets" && params.dynamicBullets) {
                  subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                  dynamicBulletIndex = 0;
                  if (params.dynamicMainBullets < 1) {
                      params.dynamicMainBullets = 1
                  }
              }
              if (params.type === "progressbar" && params.progressbarOpposite) {
                  subEl.classList.add(params.progressbarOppositeClass)
              }
              if (params.clickable) {
                  subEl.addEventListener("click", onBulletClick)
              }
              if (!swiper.enabled) {
                  subEl.classList.add(params.lockClass)
              }
          })
      }

      function destroy() {
          const params = swiper.params.pagination;
          if (isPaginationDisabled()) return;
          let el = swiper.pagination.el;
          if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => {
                  subEl.classList.remove(params.hiddenClass);
                  subEl.classList.remove(params.modifierClass + params.type);
                  subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                  if (params.clickable) {
                      subEl.classList.remove(...(params.clickableClass || "").split(" "));
                      subEl.removeEventListener("click", onBulletClick)
                  }
              })
          }
          if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(" ")))
      }
      on("changeDirection", () => {
          if (!swiper.pagination || !swiper.pagination.el) return;
          const params = swiper.params.pagination;
          let {
              el
          } = swiper.pagination;
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.classList.remove(params.horizontalClass, params.verticalClass);
              subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass)
          })
      });
      on("init", () => {
          if (swiper.params.pagination.enabled === false) {
              disable()
          } else {
              init();
              render();
              update()
          }
      });
      on("activeIndexChange", () => {
          if (typeof swiper.snapIndex === "undefined") {
              update()
          }
      });
      on("snapIndexChange", () => {
          update()
      });
      on("snapGridLengthChange", () => {
          render();
          update()
      });
      on("destroy", () => {
          destroy()
      });
      on("enable disable", () => {
          let {
              el
          } = swiper.pagination;
          if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass))
          }
      });
      on("lock unlock", () => {
          update()
      });
      on("click", (_s, e) => {
          const targetEl = e.target;
          const el = makeElementsArray(swiper.pagination.el);
          if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
              if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
              const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
              if (isHidden === true) {
                  emit("paginationShow")
              } else {
                  emit("paginationHide")
              }
              el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass))
          }
      });
      const enable = () => {
          swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
          let {
              el
          } = swiper.pagination;
          if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass))
          }
          init();
          render();
          update()
      };
      const disable = () => {
          swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
          let {
              el
          } = swiper.pagination;
          if (el) {
              el = makeElementsArray(el);
              el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass))
          }
          destroy()
      };
      Object.assign(swiper.pagination, {
          enable: enable,
          disable: disable,
          render: render,
          update: update,
          init: init,
          destroy: destroy
      })
  }

  function Scrollbar(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const document = getDocument();
      let isTouched = false;
      let timeout = null;
      let dragTimeout = null;
      let dragStartPos;
      let dragSize;
      let trackSize;
      let divider;
      extendParams({
          scrollbar: {
              el: null,
              dragSize: "auto",
              hide: false,
              draggable: false,
              snapOnRelease: true,
              lockClass: "swiper-scrollbar-lock",
              dragClass: "swiper-scrollbar-drag",
              scrollbarDisabledClass: "swiper-scrollbar-disabled",
              horizontalClass: `swiper-scrollbar-horizontal`,
              verticalClass: `swiper-scrollbar-vertical`
          }
      });
      swiper.scrollbar = {
          el: null,
          dragEl: null
      };

      function setTranslate() {
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          const {
              scrollbar,
              rtlTranslate: rtl
          } = swiper;
          const {
              dragEl,
              el
          } = scrollbar;
          const params = swiper.params.scrollbar;
          const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
          let newSize = dragSize;
          let newPos = (trackSize - dragSize) * progress;
          if (rtl) {
              newPos = -newPos;
              if (newPos > 0) {
                  newSize = dragSize - newPos;
                  newPos = 0
              } else if (-newPos + dragSize > trackSize) {
                  newSize = trackSize + newPos
              }
          } else if (newPos < 0) {
              newSize = dragSize + newPos;
              newPos = 0
          } else if (newPos + dragSize > trackSize) {
              newSize = trackSize - newPos
          }
          if (swiper.isHorizontal()) {
              dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
              dragEl.style.width = `${newSize}px`
          } else {
              dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
              dragEl.style.height = `${newSize}px`
          }
          if (params.hide) {
              clearTimeout(timeout);
              el.style.opacity = 1;
              timeout = setTimeout(() => {
                  el.style.opacity = 0;
                  el.style.transitionDuration = "400ms"
              }, 1e3)
          }
      }

      function setTransition(duration) {
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`
      }

      function updateSize() {
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          const {
              scrollbar
          } = swiper;
          const {
              dragEl,
              el
          } = scrollbar;
          dragEl.style.width = "";
          dragEl.style.height = "";
          trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
          divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
          if (swiper.params.scrollbar.dragSize === "auto") {
              dragSize = trackSize * divider
          } else {
              dragSize = parseInt(swiper.params.scrollbar.dragSize, 10)
          }
          if (swiper.isHorizontal()) {
              dragEl.style.width = `${dragSize}px`
          } else {
              dragEl.style.height = `${dragSize}px`
          }
          if (divider >= 1) {
              el.style.display = "none"
          } else {
              el.style.display = ""
          }
          if (swiper.params.scrollbar.hide) {
              el.style.opacity = 0
          }
          if (swiper.params.watchOverflow && swiper.enabled) {
              scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](swiper.params.scrollbar.lockClass)
          }
      }

      function getPointerPosition(e) {
          return swiper.isHorizontal() ? e.clientX : e.clientY
      }

      function setDragPosition(e) {
          const {
              scrollbar,
              rtlTranslate: rtl
          } = swiper;
          const {
              el
          } = scrollbar;
          let positionRatio;
          positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
          positionRatio = Math.max(Math.min(positionRatio, 1), 0);
          if (rtl) {
              positionRatio = 1 - positionRatio
          }
          const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
          swiper.updateProgress(position);
          swiper.setTranslate(position);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses()
      }

      function onDragStart(e) {
          const params = swiper.params.scrollbar;
          const {
              scrollbar,
              wrapperEl
          } = swiper;
          const {
              el,
              dragEl
          } = scrollbar;
          isTouched = true;
          dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
          e.preventDefault();
          e.stopPropagation();
          wrapperEl.style.transitionDuration = "100ms";
          dragEl.style.transitionDuration = "100ms";
          setDragPosition(e);
          clearTimeout(dragTimeout);
          el.style.transitionDuration = "0ms";
          if (params.hide) {
              el.style.opacity = 1
          }
          if (swiper.params.cssMode) {
              swiper.wrapperEl.style["scroll-snap-type"] = "none"
          }
          emit("scrollbarDragStart", e)
      }

      function onDragMove(e) {
          const {
              scrollbar,
              wrapperEl
          } = swiper;
          const {
              el,
              dragEl
          } = scrollbar;
          if (!isTouched) return;
          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
          setDragPosition(e);
          wrapperEl.style.transitionDuration = "0ms";
          el.style.transitionDuration = "0ms";
          dragEl.style.transitionDuration = "0ms";
          emit("scrollbarDragMove", e)
      }

      function onDragEnd(e) {
          const params = swiper.params.scrollbar;
          const {
              scrollbar,
              wrapperEl
          } = swiper;
          const {
              el
          } = scrollbar;
          if (!isTouched) return;
          isTouched = false;
          if (swiper.params.cssMode) {
              swiper.wrapperEl.style["scroll-snap-type"] = "";
              wrapperEl.style.transitionDuration = ""
          }
          if (params.hide) {
              clearTimeout(dragTimeout);
              dragTimeout = nextTick(() => {
                  el.style.opacity = 0;
                  el.style.transitionDuration = "400ms"
              }, 1e3)
          }
          emit("scrollbarDragEnd", e);
          if (params.snapOnRelease) {
              swiper.slideToClosest()
          }
      }

      function events(method) {
          const {
              scrollbar,
              params
          } = swiper;
          const el = scrollbar.el;
          if (!el) return;
          const target = el;
          const activeListener = params.passiveListeners ? {
              passive: false,
              capture: false
          } : false;
          const passiveListener = params.passiveListeners ? {
              passive: true,
              capture: false
          } : false;
          if (!target) return;
          const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
          target[eventMethod]("pointerdown", onDragStart, activeListener);
          document[eventMethod]("pointermove", onDragMove, activeListener);
          document[eventMethod]("pointerup", onDragEnd, passiveListener)
      }

      function enableDraggable() {
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          events("on")
      }

      function disableDraggable() {
          if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
          events("off")
      }

      function init() {
          const {
              scrollbar,
              el: swiperEl
          } = swiper;
          swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
              el: "swiper-scrollbar"
          });
          const params = swiper.params.scrollbar;
          if (!params.el) return;
          let el;
          if (typeof params.el === "string" && swiper.isElement) {
              el = swiper.el.querySelector(params.el)
          }
          if (!el && typeof params.el === "string") {
              el = document.querySelectorAll(params.el);
              if (!el.length) return
          } else if (!el) {
              el = params.el
          }
          if (swiper.params.uniqueNavElements && typeof params.el === "string" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
              el = swiperEl.querySelector(params.el)
          }
          if (el.length > 0) el = el[0];
          el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
          let dragEl;
          if (el) {
              dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
              if (!dragEl) {
                  dragEl = createElement("div", swiper.params.scrollbar.dragClass);
                  el.append(dragEl)
              }
          }
          Object.assign(scrollbar, {
              el: el,
              dragEl: dragEl
          });
          if (params.draggable) {
              enableDraggable()
          }
          if (el) {
              el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass))
          }
      }

      function destroy() {
          const params = swiper.params.scrollbar;
          const el = swiper.scrollbar.el;
          if (el) {
              el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass))
          }
          disableDraggable()
      }
      on("init", () => {
          if (swiper.params.scrollbar.enabled === false) {
              disable()
          } else {
              init();
              updateSize();
              setTranslate()
          }
      });
      on("update resize observerUpdate lock unlock", () => {
          updateSize()
      });
      on("setTranslate", () => {
          setTranslate()
      });
      on("setTransition", (_s, duration) => {
          setTransition(duration)
      });
      on("enable disable", () => {
          const {
              el
          } = swiper.scrollbar;
          if (el) {
              el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass))
          }
      });
      on("destroy", () => {
          destroy()
      });
      const enable = () => {
          swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
          if (swiper.scrollbar.el) {
              swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass))
          }
          init();
          updateSize();
          setTranslate()
      };
      const disable = () => {
          swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
          if (swiper.scrollbar.el) {
              swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass))
          }
          destroy()
      };
      Object.assign(swiper.scrollbar, {
          enable: enable,
          disable: disable,
          updateSize: updateSize,
          setTranslate: setTranslate,
          init: init,
          destroy: destroy
      })
  }

  function Parallax(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          parallax: {
              enabled: false
          }
      });
      const elementsSelector = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]";
      const setTransform = (el, progress) => {
          const {
              rtl
          } = swiper;
          const rtlFactor = rtl ? -1 : 1;
          const p = el.getAttribute("data-swiper-parallax") || "0";
          let x = el.getAttribute("data-swiper-parallax-x");
          let y = el.getAttribute("data-swiper-parallax-y");
          const scale = el.getAttribute("data-swiper-parallax-scale");
          const opacity = el.getAttribute("data-swiper-parallax-opacity");
          const rotate = el.getAttribute("data-swiper-parallax-rotate");
          if (x || y) {
              x = x || "0";
              y = y || "0"
          } else if (swiper.isHorizontal()) {
              x = p;
              y = "0"
          } else {
              y = p;
              x = "0"
          }
          if (x.indexOf("%") >= 0) {
              x = `${parseInt(x,10)*progress*rtlFactor}%`
          } else {
              x = `${x*progress*rtlFactor}px`
          }
          if (y.indexOf("%") >= 0) {
              y = `${parseInt(y,10)*progress}%`
          } else {
              y = `${y*progress}px`
          }
          if (typeof opacity !== "undefined" && opacity !== null) {
              const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
              el.style.opacity = currentOpacity
          }
          let transform = `translate3d(${x}, ${y}, 0px)`;
          if (typeof scale !== "undefined" && scale !== null) {
              const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
              transform += ` scale(${currentScale})`
          }
          if (rotate && typeof rotate !== "undefined" && rotate !== null) {
              const currentRotate = rotate * progress * -1;
              transform += ` rotate(${currentRotate}deg)`
          }
          el.style.transform = transform
      };
      const setTranslate = () => {
          const {
              el,
              slides,
              progress,
              snapGrid,
              isElement
          } = swiper;
          const elements = elementChildren(el, elementsSelector);
          if (swiper.isElement) {
              elements.push(...elementChildren(swiper.hostEl, elementsSelector))
          }
          elements.forEach(subEl => {
              setTransform(subEl, progress)
          });
          slides.forEach((slideEl, slideIndex) => {
              let slideProgress = slideEl.progress;
              if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
                  slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1)
              }
              slideProgress = Math.min(Math.max(slideProgress, -1), 1);
              slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach(subEl => {
                  setTransform(subEl, slideProgress)
              })
          })
      };
      const setTransition = function(duration) {
          if (duration === void 0) {
              duration = swiper.params.speed
          }
          const {
              el,
              hostEl
          } = swiper;
          const elements = [...el.querySelectorAll(elementsSelector)];
          if (swiper.isElement) {
              elements.push(...hostEl.querySelectorAll(elementsSelector))
          }
          elements.forEach(parallaxEl => {
              let parallaxDuration = parseInt(parallaxEl.getAttribute("data-swiper-parallax-duration"), 10) || duration;
              if (duration === 0) parallaxDuration = 0;
              parallaxEl.style.transitionDuration = `${parallaxDuration}ms`
          })
      };
      on("beforeInit", () => {
          if (!swiper.params.parallax.enabled) return;
          swiper.params.watchSlidesProgress = true;
          swiper.originalParams.watchSlidesProgress = true
      });
      on("init", () => {
          if (!swiper.params.parallax.enabled) return;
          setTranslate()
      });
      on("setTranslate", () => {
          if (!swiper.params.parallax.enabled) return;
          setTranslate()
      });
      on("setTransition", (_swiper, duration) => {
          if (!swiper.params.parallax.enabled) return;
          setTransition(duration)
      })
  }

  function Zoom(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit
      } = _ref;
      const window = getWindow();
      extendParams({
          zoom: {
              enabled: false,
              maxRatio: 3,
              minRatio: 1,
              toggle: true,
              containerClass: "swiper-zoom-container",
              zoomedSlideClass: "swiper-slide-zoomed"
          }
      });
      swiper.zoom = {
          enabled: false
      };
      let currentScale = 1;
      let isScaling = false;
      let fakeGestureTouched;
      let fakeGestureMoved;
      const evCache = [];
      const gesture = {
          originX: 0,
          originY: 0,
          slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          imageEl: undefined,
          imageWrapEl: undefined,
          maxRatio: 3
      };
      const image = {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {}
      };
      const velocity = {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined
      };
      let scale = 1;
      Object.defineProperty(swiper.zoom, "scale", {
          get() {
              return scale
          },
          set(value) {
              if (scale !== value) {
                  const imageEl = gesture.imageEl;
                  const slideEl = gesture.slideEl;
                  emit("zoomChange", value, imageEl, slideEl)
              }
              scale = value
          }
      });

      function getDistanceBetweenTouches() {
          if (evCache.length < 2) return 1;
          const x1 = evCache[0].pageX;
          const y1 = evCache[0].pageY;
          const x2 = evCache[1].pageX;
          const y2 = evCache[1].pageY;
          const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
          return distance
      }

      function getScaleOrigin() {
          if (evCache.length < 2) return {
              x: null,
              y: null
          };
          const box = gesture.imageEl.getBoundingClientRect();
          return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window.scrollX) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window.scrollY) / currentScale]
      }

      function getSlideSelector() {
          return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`
      }

      function eventWithinSlide(e) {
          const slideSelector = getSlideSelector();
          if (e.target.matches(slideSelector)) return true;
          if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
          return false
      }

      function eventWithinZoomContainer(e) {
          const selector = `.${swiper.params.zoom.containerClass}`;
          if (e.target.matches(selector)) return true;
          if ([...swiper.hostEl.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
          return false
      }

      function onGestureStart(e) {
          if (e.pointerType === "mouse") {
              evCache.splice(0, evCache.length)
          }
          if (!eventWithinSlide(e)) return;
          const params = swiper.params.zoom;
          fakeGestureTouched = false;
          fakeGestureMoved = false;
          evCache.push(e);
          if (evCache.length < 2) {
              return
          }
          fakeGestureTouched = true;
          gesture.scaleStart = getDistanceBetweenTouches();
          if (!gesture.slideEl) {
              gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
              if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                  imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                  gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0]
              } else {
                  gesture.imageWrapEl = undefined
              }
              if (!gesture.imageWrapEl) {
                  gesture.imageEl = undefined;
                  return
              }
              gesture.maxRatio = gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio
          }
          if (gesture.imageEl) {
              const [originX, originY] = getScaleOrigin();
              gesture.originX = originX;
              gesture.originY = originY;
              gesture.imageEl.style.transitionDuration = "0ms"
          }
          isScaling = true
      }

      function onGestureChange(e) {
          if (!eventWithinSlide(e)) return;
          const params = swiper.params.zoom;
          const zoom = swiper.zoom;
          const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
          if (pointerIndex >= 0) evCache[pointerIndex] = e;
          if (evCache.length < 2) {
              return
          }
          fakeGestureMoved = true;
          gesture.scaleMove = getDistanceBetweenTouches();
          if (!gesture.imageEl) {
              return
          }
          zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
          if (zoom.scale > gesture.maxRatio) {
              zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** .5
          }
          if (zoom.scale < params.minRatio) {
              zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** .5
          }
          gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`
      }

      function onGestureEnd(e) {
          if (!eventWithinSlide(e)) return;
          if (e.pointerType === "mouse" && e.type === "pointerout") return;
          const params = swiper.params.zoom;
          const zoom = swiper.zoom;
          const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
          if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
          if (!fakeGestureTouched || !fakeGestureMoved) {
              return
          }
          fakeGestureTouched = false;
          fakeGestureMoved = false;
          if (!gesture.imageEl) return;
          zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
          gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
          gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
          currentScale = zoom.scale;
          isScaling = false;
          if (zoom.scale > 1 && gesture.slideEl) {
              gesture.slideEl.classList.add(`${params.zoomedSlideClass}`)
          } else if (zoom.scale <= 1 && gesture.slideEl) {
              gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`)
          }
          if (zoom.scale === 1) {
              gesture.originX = 0;
              gesture.originY = 0;
              gesture.slideEl = undefined
          }
      }

      function onTouchStart(e) {
          const device = swiper.device;
          if (!gesture.imageEl) return;
          if (image.isTouched) return;
          if (device.android && e.cancelable) e.preventDefault();
          image.isTouched = true;
          const event = evCache.length > 0 ? evCache[0] : e;
          image.touchesStart.x = event.pageX;
          image.touchesStart.y = event.pageY
      }

      function onTouchMove(e) {
          if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;
          const zoom = swiper.zoom;
          if (!gesture.imageEl) return;
          if (!image.isTouched || !gesture.slideEl) return;
          if (!image.isMoved) {
              image.width = gesture.imageEl.offsetWidth;
              image.height = gesture.imageEl.offsetHeight;
              image.startX = getTranslate(gesture.imageWrapEl, "x") || 0;
              image.startY = getTranslate(gesture.imageWrapEl, "y") || 0;
              gesture.slideWidth = gesture.slideEl.offsetWidth;
              gesture.slideHeight = gesture.slideEl.offsetHeight;
              gesture.imageWrapEl.style.transitionDuration = "0ms"
          }
          const scaledWidth = image.width * zoom.scale;
          const scaledHeight = image.height * zoom.scale;
          if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
          image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
          const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
          if (touchesDiff > 5) {
              swiper.allowClick = false
          }
          if (!image.isMoved && !isScaling) {
              if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                  image.isTouched = false;
                  return
              }
              if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                  image.isTouched = false;
                  return
              }
          }
          if (e.cancelable) {
              e.preventDefault()
          }
          e.stopPropagation();
          image.isMoved = true;
          const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
          const {
              originX,
              originY
          } = gesture;
          image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
          image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
          if (image.currentX < image.minX) {
              image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** .8
          }
          if (image.currentX > image.maxX) {
              image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** .8
          }
          if (image.currentY < image.minY) {
              image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** .8
          }
          if (image.currentY > image.maxY) {
              image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** .8
          }
          if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
          if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
          if (!velocity.prevTime) velocity.prevTime = Date.now();
          velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
          velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
          if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
          if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
          velocity.prevPositionX = image.touchesCurrent.x;
          velocity.prevPositionY = image.touchesCurrent.y;
          velocity.prevTime = Date.now();
          gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`
      }

      function onTouchEnd() {
          const zoom = swiper.zoom;
          if (!gesture.imageEl) return;
          if (!image.isTouched || !image.isMoved) {
              image.isTouched = false;
              image.isMoved = false;
              return
          }
          image.isTouched = false;
          image.isMoved = false;
          let momentumDurationX = 300;
          let momentumDurationY = 300;
          const momentumDistanceX = velocity.x * momentumDurationX;
          const newPositionX = image.currentX + momentumDistanceX;
          const momentumDistanceY = velocity.y * momentumDurationY;
          const newPositionY = image.currentY + momentumDistanceY;
          if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
          if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
          const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
          image.currentX = newPositionX;
          image.currentY = newPositionY;
          const scaledWidth = image.width * zoom.scale;
          const scaledHeight = image.height * zoom.scale;
          image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
          image.maxX = -image.minX;
          image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
          image.maxY = -image.minY;
          image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
          image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
          gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
          gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`
      }

      function onTransitionEnd() {
          const zoom = swiper.zoom;
          if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
              if (gesture.imageEl) {
                  gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)"
              }
              if (gesture.imageWrapEl) {
                  gesture.imageWrapEl.style.transform = "translate3d(0,0,0)"
              }
              gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
              zoom.scale = 1;
              currentScale = 1;
              gesture.slideEl = undefined;
              gesture.imageEl = undefined;
              gesture.imageWrapEl = undefined;
              gesture.originX = 0;
              gesture.originY = 0
          }
      }

      function zoomIn(e) {
          const zoom = swiper.zoom;
          const params = swiper.params.zoom;
          if (!gesture.slideEl) {
              if (e && e.target) {
                  gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`)
              }
              if (!gesture.slideEl) {
                  if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                      gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0]
                  } else {
                      gesture.slideEl = swiper.slides[swiper.activeIndex]
                  }
              }
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                  imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                  gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0]
              } else {
                  gesture.imageWrapEl = undefined
              }
          }
          if (!gesture.imageEl || !gesture.imageWrapEl) return;
          if (swiper.params.cssMode) {
              swiper.wrapperEl.style.overflow = "hidden";
              swiper.wrapperEl.style.touchAction = "none"
          }
          gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
          let touchX;
          let touchY;
          let offsetX;
          let offsetY;
          let diffX;
          let diffY;
          let translateX;
          let translateY;
          let imageWidth;
          let imageHeight;
          let scaledWidth;
          let scaledHeight;
          let translateMinX;
          let translateMinY;
          let translateMaxX;
          let translateMaxY;
          let slideWidth;
          let slideHeight;
          if (typeof image.touchesStart.x === "undefined" && e) {
              touchX = e.pageX;
              touchY = e.pageY
          } else {
              touchX = image.touchesStart.x;
              touchY = image.touchesStart.y
          }
          const forceZoomRatio = typeof e === "number" ? e : null;
          if (currentScale === 1 && forceZoomRatio) {
              touchX = undefined;
              touchY = undefined
          }
          zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio;
          currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio;
          if (e && !(currentScale === 1 && forceZoomRatio)) {
              slideWidth = gesture.slideEl.offsetWidth;
              slideHeight = gesture.slideEl.offsetHeight;
              offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
              offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
              diffX = offsetX + slideWidth / 2 - touchX;
              diffY = offsetY + slideHeight / 2 - touchY;
              imageWidth = gesture.imageEl.offsetWidth;
              imageHeight = gesture.imageEl.offsetHeight;
              scaledWidth = imageWidth * zoom.scale;
              scaledHeight = imageHeight * zoom.scale;
              translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
              translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
              translateMaxX = -translateMinX;
              translateMaxY = -translateMinY;
              translateX = diffX * zoom.scale;
              translateY = diffY * zoom.scale;
              if (translateX < translateMinX) {
                  translateX = translateMinX
              }
              if (translateX > translateMaxX) {
                  translateX = translateMaxX
              }
              if (translateY < translateMinY) {
                  translateY = translateMinY
              }
              if (translateY > translateMaxY) {
                  translateY = translateMaxY
              }
          } else {
              translateX = 0;
              translateY = 0
          }
          if (forceZoomRatio && zoom.scale === 1) {
              gesture.originX = 0;
              gesture.originY = 0
          }
          gesture.imageWrapEl.style.transitionDuration = "300ms";
          gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
          gesture.imageEl.style.transitionDuration = "300ms";
          gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`
      }

      function zoomOut() {
          const zoom = swiper.zoom;
          const params = swiper.params.zoom;
          if (!gesture.slideEl) {
              if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                  gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0]
              } else {
                  gesture.slideEl = swiper.slides[swiper.activeIndex]
              }
              let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
              if (imageEl) {
                  imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]
              }
              gesture.imageEl = imageEl;
              if (imageEl) {
                  gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0]
              } else {
                  gesture.imageWrapEl = undefined
              }
          }
          if (!gesture.imageEl || !gesture.imageWrapEl) return;
          if (swiper.params.cssMode) {
              swiper.wrapperEl.style.overflow = "";
              swiper.wrapperEl.style.touchAction = ""
          }
          zoom.scale = 1;
          currentScale = 1;
          gesture.imageWrapEl.style.transitionDuration = "300ms";
          gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
          gesture.imageEl.style.transitionDuration = "300ms";
          gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
          gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
          gesture.slideEl = undefined;
          gesture.originX = 0;
          gesture.originY = 0
      }

      function zoomToggle(e) {
          const zoom = swiper.zoom;
          if (zoom.scale && zoom.scale !== 1) {
              zoomOut()
          } else {
              zoomIn(e)
          }
      }

      function getListeners() {
          const passiveListener = swiper.params.passiveListeners ? {
              passive: true,
              capture: false
          } : false;
          const activeListenerWithCapture = swiper.params.passiveListeners ? {
              passive: false,
              capture: true
          } : true;
          return {
              passiveListener: passiveListener,
              activeListenerWithCapture: activeListenerWithCapture
          }
      }

      function enable() {
          const zoom = swiper.zoom;
          if (zoom.enabled) return;
          zoom.enabled = true;
          const {
              passiveListener,
              activeListenerWithCapture
          } = getListeners();
          swiper.wrapperEl.addEventListener("pointerdown", onGestureStart, passiveListener);
          swiper.wrapperEl.addEventListener("pointermove", onGestureChange, activeListenerWithCapture);
          ["pointerup", "pointercancel", "pointerout"].forEach(eventName => {
              swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener)
          });
          swiper.wrapperEl.addEventListener("pointermove", onTouchMove, activeListenerWithCapture)
      }

      function disable() {
          const zoom = swiper.zoom;
          if (!zoom.enabled) return;
          zoom.enabled = false;
          const {
              passiveListener,
              activeListenerWithCapture
          } = getListeners();
          swiper.wrapperEl.removeEventListener("pointerdown", onGestureStart, passiveListener);
          swiper.wrapperEl.removeEventListener("pointermove", onGestureChange, activeListenerWithCapture);
          ["pointerup", "pointercancel", "pointerout"].forEach(eventName => {
              swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener)
          });
          swiper.wrapperEl.removeEventListener("pointermove", onTouchMove, activeListenerWithCapture)
      }
      on("init", () => {
          if (swiper.params.zoom.enabled) {
              enable()
          }
      });
      on("destroy", () => {
          disable()
      });
      on("touchStart", (_s, e) => {
          if (!swiper.zoom.enabled) return;
          onTouchStart(e)
      });
      on("touchEnd", (_s, e) => {
          if (!swiper.zoom.enabled) return;
          onTouchEnd()
      });
      on("doubleTap", (_s, e) => {
          if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
              zoomToggle(e)
          }
      });
      on("transitionEnd", () => {
          if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
              onTransitionEnd()
          }
      });
      on("slideChange", () => {
          if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
              onTransitionEnd()
          }
      });
      Object.assign(swiper.zoom, {
          enable: enable,
          disable: disable,
          "in": zoomIn,
          out: zoomOut,
          toggle: zoomToggle
      })
  }

  function Controller(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          controller: {
              control: undefined,
              inverse: false,
              by: "slide"
          }
      });
      swiper.controller = {
          control: undefined
      };

      function LinearSpline(x, y) {
          const binarySearch = function search() {
              let maxIndex;
              let minIndex;
              let guess;
              return (array, val) => {
                  minIndex = -1;
                  maxIndex = array.length;
                  while (maxIndex - minIndex > 1) {
                      guess = maxIndex + minIndex >> 1;
                      if (array[guess] <= val) {
                          minIndex = guess
                      } else {
                          maxIndex = guess
                      }
                  }
                  return maxIndex
              }
          }();
          this.x = x;
          this.y = y;
          this.lastIndex = x.length - 1;
          let i1;
          let i3;
          this.interpolate = function interpolate(x2) {
              if (!x2) return 0;
              i3 = binarySearch(this.x, x2);
              i1 = i3 - 1;
              return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1]
          };
          return this
      }

      function getInterpolateFunction(c) {
          swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid)
      }

      function setTranslate(_t, byController) {
          const controlled = swiper.controller.control;
          let multiplier;
          let controlledTranslate;
          const Swiper = swiper.constructor;

          function setControlledTranslate(c) {
              if (c.destroyed) return;
              const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
              if (swiper.params.controller.by === "slide") {
                  getInterpolateFunction(c);
                  controlledTranslate = -swiper.controller.spline.interpolate(-translate)
              }
              if (!controlledTranslate || swiper.params.controller.by === "container") {
                  multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                  if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
                      multiplier = 1
                  }
                  controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate()
              }
              if (swiper.params.controller.inverse) {
                  controlledTranslate = c.maxTranslate() - controlledTranslate
              }
              c.updateProgress(controlledTranslate);
              c.setTranslate(controlledTranslate, swiper);
              c.updateActiveIndex();
              c.updateSlidesClasses()
          }
          if (Array.isArray(controlled)) {
              for (let i = 0; i < controlled.length; i += 1) {
                  if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                      setControlledTranslate(controlled[i])
                  }
              }
          } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTranslate(controlled)
          }
      }

      function setTransition(duration, byController) {
          const Swiper = swiper.constructor;
          const controlled = swiper.controller.control;
          let i;

          function setControlledTransition(c) {
              if (c.destroyed) return;
              c.setTransition(duration, swiper);
              if (duration !== 0) {
                  c.transitionStart();
                  if (c.params.autoHeight) {
                      nextTick(() => {
                          c.updateAutoHeight()
                      })
                  }
                  elementTransitionEnd(c.wrapperEl, () => {
                      if (!controlled) return;
                      c.transitionEnd()
                  })
              }
          }
          if (Array.isArray(controlled)) {
              for (i = 0; i < controlled.length; i += 1) {
                  if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                      setControlledTransition(controlled[i])
                  }
              }
          } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTransition(controlled)
          }
      }

      function removeSpline() {
          if (!swiper.controller.control) return;
          if (swiper.controller.spline) {
              swiper.controller.spline = undefined;
              delete swiper.controller.spline
          }
      }
      on("beforeInit", () => {
          if (typeof window !== "undefined" && (typeof swiper.params.controller.control === "string" || swiper.params.controller.control instanceof HTMLElement)) {
              const controlElement = document.querySelector(swiper.params.controller.control);
              if (controlElement && controlElement.swiper) {
                  swiper.controller.control = controlElement.swiper
              } else if (controlElement) {
                  const onControllerSwiper = e => {
                      swiper.controller.control = e.detail[0];
                      swiper.update();
                      controlElement.removeEventListener("init", onControllerSwiper)
                  };
                  controlElement.addEventListener("init", onControllerSwiper)
              }
              return
          }
          swiper.controller.control = swiper.params.controller.control
      });
      on("update", () => {
          removeSpline()
      });
      on("resize", () => {
          removeSpline()
      });
      on("observerUpdate", () => {
          removeSpline()
      });
      on("setTranslate", (_s, translate, byController) => {
          if (!swiper.controller.control || swiper.controller.control.destroyed) return;
          swiper.controller.setTranslate(translate, byController)
      });
      on("setTransition", (_s, duration, byController) => {
          if (!swiper.controller.control || swiper.controller.control.destroyed) return;
          swiper.controller.setTransition(duration, byController)
      });
      Object.assign(swiper.controller, {
          setTranslate: setTranslate,
          setTransition: setTransition
      })
  }

  function A11y(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          a11y: {
              enabled: true,
              notificationClass: "swiper-notification",
              prevSlideMessage: "Previous slide",
              nextSlideMessage: "Next slide",
              firstSlideMessage: "This is the first slide",
              lastSlideMessage: "This is the last slide",
              paginationBulletMessage: "Go to slide {{index}}",
              slideLabelMessage: "{{index}} / {{slidesLength}}",
              containerMessage: null,
              containerRoleDescriptionMessage: null,
              itemRoleDescriptionMessage: null,
              slideRole: "group",
              id: null
          }
      });
      swiper.a11y = {
          clicked: false
      };
      let liveRegion = null;

      function notify(message) {
          const notification = liveRegion;
          if (notification.length === 0) return;
          notification.innerHTML = "";
          notification.innerHTML = message
      }
      const makeElementsArray = el => (Array.isArray(el) ? el : [el]).filter(e => !!e);

      function getRandomNumber(size) {
          if (size === void 0) {
              size = 16
          }
          const randomChar = () => Math.round(16 * Math.random()).toString(16);
          return "x".repeat(size).replace(/x/g, randomChar)
      }

      function makeElFocusable(el) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("tabIndex", "0")
          })
      }

      function makeElNotFocusable(el) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("tabIndex", "-1")
          })
      }

      function addElRole(el, role) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("role", role)
          })
      }

      function addElRoleDescription(el, description) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-roledescription", description)
          })
      }

      function addElControls(el, controls) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-controls", controls)
          })
      }

      function addElLabel(el, label) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-label", label)
          })
      }

      function addElId(el, id) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("id", id)
          })
      }

      function addElLive(el, live) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-live", live)
          })
      }

      function disableEl(el) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-disabled", true)
          })
      }

      function enableEl(el) {
          el = makeElementsArray(el);
          el.forEach(subEl => {
              subEl.setAttribute("aria-disabled", false)
          })
      }

      function onEnterOrSpaceKey(e) {
          if (e.keyCode !== 13 && e.keyCode !== 32) return;
          const params = swiper.params.a11y;
          const targetEl = e.target;
          if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
              if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return
          }
          if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {
              if (!(swiper.isEnd && !swiper.params.loop)) {
                  swiper.slideNext()
              }
              if (swiper.isEnd) {
                  notify(params.lastSlideMessage)
              } else {
                  notify(params.nextSlideMessage)
              }
          }
          if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {
              if (!(swiper.isBeginning && !swiper.params.loop)) {
                  swiper.slidePrev()
              }
              if (swiper.isBeginning) {
                  notify(params.firstSlideMessage)
              } else {
                  notify(params.prevSlideMessage)
              }
          }
          if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
              targetEl.click()
          }
      }

      function updateNavigation() {
          if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
          const {
              nextEl,
              prevEl
          } = swiper.navigation;
          if (prevEl) {
              if (swiper.isBeginning) {
                  disableEl(prevEl);
                  makeElNotFocusable(prevEl)
              } else {
                  enableEl(prevEl);
                  makeElFocusable(prevEl)
              }
          }
          if (nextEl) {
              if (swiper.isEnd) {
                  disableEl(nextEl);
                  makeElNotFocusable(nextEl)
              } else {
                  enableEl(nextEl);
                  makeElFocusable(nextEl)
              }
          }
      }

      function hasPagination() {
          return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length
      }

      function hasClickablePagination() {
          return hasPagination() && swiper.params.pagination.clickable
      }

      function updatePagination() {
          const params = swiper.params.a11y;
          if (!hasPagination()) return;
          swiper.pagination.bullets.forEach(bulletEl => {
              if (swiper.params.pagination.clickable) {
                  makeElFocusable(bulletEl);
                  if (!swiper.params.pagination.renderBullet) {
                      addElRole(bulletEl, "button");
                      addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1))
                  }
              }
              if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
                  bulletEl.setAttribute("aria-current", "true")
              } else {
                  bulletEl.removeAttribute("aria-current")
              }
          })
      }
      const initNavEl = (el, wrapperId, message) => {
          makeElFocusable(el);
          if (el.tagName !== "BUTTON") {
              addElRole(el, "button");
              el.addEventListener("keydown", onEnterOrSpaceKey)
          }
          addElLabel(el, message);
          addElControls(el, wrapperId)
      };
      const handlePointerDown = () => {
          swiper.a11y.clicked = true
      };
      const handlePointerUp = () => {
          requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                  if (!swiper.destroyed) {
                      swiper.a11y.clicked = false
                  }
              })
          })
      };
      const handleFocus = e => {
          if (swiper.a11y.clicked) return;
          const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
          if (!slideEl || !swiper.slides.includes(slideEl)) return;
          const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
          const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
          if (isActive || isVisible) return;
          if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
          if (swiper.isHorizontal()) {
              swiper.el.scrollLeft = 0
          } else {
              swiper.el.scrollTop = 0
          }
          swiper.slideTo(swiper.slides.indexOf(slideEl), 0)
      };
      const initSlides = () => {
          const params = swiper.params.a11y;
          if (params.itemRoleDescriptionMessage) {
              addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage)
          }
          if (params.slideRole) {
              addElRole(swiper.slides, params.slideRole)
          }
          const slidesLength = swiper.slides.length;
          if (params.slideLabelMessage) {
              swiper.slides.forEach((slideEl, index) => {
                  const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10) : index;
                  const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                  addElLabel(slideEl, ariaLabelMessage)
              })
          }
      };
      const init = () => {
          const params = swiper.params.a11y;
          swiper.el.append(liveRegion);
          const containerEl = swiper.el;
          if (params.containerRoleDescriptionMessage) {
              addElRoleDescription(containerEl, params.containerRoleDescriptionMessage)
          }
          if (params.containerMessage) {
              addElLabel(containerEl, params.containerMessage)
          }
          const wrapperEl = swiper.wrapperEl;
          const wrapperId = params.id || wrapperEl.getAttribute("id") || `swiper-wrapper-${getRandomNumber(16)}`;
          const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
          addElId(wrapperEl, wrapperId);
          addElLive(wrapperEl, live);
          initSlides();
          let {
              nextEl,
              prevEl
          } = swiper.navigation ? swiper.navigation : {};
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          if (nextEl) {
              nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage))
          }
          if (prevEl) {
              prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage))
          }
          if (hasClickablePagination()) {
              const paginationEl = makeElementsArray(swiper.pagination.el);
              paginationEl.forEach(el => {
                  el.addEventListener("keydown", onEnterOrSpaceKey)
              })
          }
          swiper.el.addEventListener("focus", handleFocus, true);
          swiper.el.addEventListener("pointerdown", handlePointerDown, true);
          swiper.el.addEventListener("pointerup", handlePointerUp, true)
      };

      function destroy() {
          if (liveRegion) liveRegion.remove();
          let {
              nextEl,
              prevEl
          } = swiper.navigation ? swiper.navigation : {};
          nextEl = makeElementsArray(nextEl);
          prevEl = makeElementsArray(prevEl);
          if (nextEl) {
              nextEl.forEach(el => el.removeEventListener("keydown", onEnterOrSpaceKey))
          }
          if (prevEl) {
              prevEl.forEach(el => el.removeEventListener("keydown", onEnterOrSpaceKey))
          }
          if (hasClickablePagination()) {
              const paginationEl = makeElementsArray(swiper.pagination.el);
              paginationEl.forEach(el => {
                  el.removeEventListener("keydown", onEnterOrSpaceKey)
              })
          }
          swiper.el.removeEventListener("focus", handleFocus, true);
          swiper.el.removeEventListener("pointerdown", handlePointerDown, true);
          swiper.el.removeEventListener("pointerup", handlePointerUp, true)
      }
      on("beforeInit", () => {
          liveRegion = createElement("span", swiper.params.a11y.notificationClass);
          liveRegion.setAttribute("aria-live", "assertive");
          liveRegion.setAttribute("aria-atomic", "true")
      });
      on("afterInit", () => {
          if (!swiper.params.a11y.enabled) return;
          init()
      });
      on("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
          if (!swiper.params.a11y.enabled) return;
          initSlides()
      });
      on("fromEdge toEdge afterInit lock unlock", () => {
          if (!swiper.params.a11y.enabled) return;
          updateNavigation()
      });
      on("paginationUpdate", () => {
          if (!swiper.params.a11y.enabled) return;
          updatePagination()
      });
      on("destroy", () => {
          if (!swiper.params.a11y.enabled) return;
          destroy()
      })
  }

  function History(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          history: {
              enabled: false,
              root: "",
              replaceState: false,
              key: "slides",
              keepQuery: false
          }
      });
      let initialized = false;
      let paths = {};
      const slugify = text => {
          return text.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
      };
      const getPathValues = urlOverride => {
          const window = getWindow();
          let location;
          if (urlOverride) {
              location = new URL(urlOverride)
          } else {
              location = window.location
          }
          const pathArray = location.pathname.slice(1).split("/").filter(part => part !== "");
          const total = pathArray.length;
          const key = pathArray[total - 2];
          const value = pathArray[total - 1];
          return {
              key: key,
              value: value
          }
      };
      const setHistory = (key, index) => {
          const window = getWindow();
          if (!initialized || !swiper.params.history.enabled) return;
          let location;
          if (swiper.params.url) {
              location = new URL(swiper.params.url)
          } else {
              location = window.location
          }
          const slide = swiper.slides[index];
          let value = slugify(slide.getAttribute("data-history"));
          if (swiper.params.history.root.length > 0) {
              let root = swiper.params.history.root;
              if (root[root.length - 1] === "/") root = root.slice(0, root.length - 1);
              value = `${root}/${key?`${key}/`:""}${value}`
          } else if (!location.pathname.includes(key)) {
              value = `${key?`${key}/`:""}${value}`
          }
          if (swiper.params.history.keepQuery) {
              value += location.search
          }
          const currentState = window.history.state;
          if (currentState && currentState.value === value) {
              return
          }
          if (swiper.params.history.replaceState) {
              window.history.replaceState({
                  value: value
              }, null, value)
          } else {
              window.history.pushState({
                  value: value
              }, null, value)
          }
      };
      const scrollToSlide = (speed, value, runCallbacks) => {
          if (value) {
              for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
                  const slide = swiper.slides[i];
                  const slideHistory = slugify(slide.getAttribute("data-history"));
                  if (slideHistory === value) {
                      const index = swiper.getSlideIndex(slide);
                      swiper.slideTo(index, speed, runCallbacks)
                  }
              }
          } else {
              swiper.slideTo(0, speed, runCallbacks)
          }
      };
      const setHistoryPopState = () => {
          paths = getPathValues(swiper.params.url);
          scrollToSlide(swiper.params.speed, paths.value, false)
      };
      const init = () => {
          const window = getWindow();
          if (!swiper.params.history) return;
          if (!window.history || !window.history.pushState) {
              swiper.params.history.enabled = false;
              swiper.params.hashNavigation.enabled = true;
              return
          }
          initialized = true;
          paths = getPathValues(swiper.params.url);
          if (!paths.key && !paths.value) {
              if (!swiper.params.history.replaceState) {
                  window.addEventListener("popstate", setHistoryPopState)
              }
              return
          }
          scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
          if (!swiper.params.history.replaceState) {
              window.addEventListener("popstate", setHistoryPopState)
          }
      };
      const destroy = () => {
          const window = getWindow();
          if (!swiper.params.history.replaceState) {
              window.removeEventListener("popstate", setHistoryPopState)
          }
      };
      on("init", () => {
          if (swiper.params.history.enabled) {
              init()
          }
      });
      on("destroy", () => {
          if (swiper.params.history.enabled) {
              destroy()
          }
      });
      on("transitionEnd _freeModeNoMomentumRelease", () => {
          if (initialized) {
              setHistory(swiper.params.history.key, swiper.activeIndex)
          }
      });
      on("slideChange", () => {
          if (initialized && swiper.params.cssMode) {
              setHistory(swiper.params.history.key, swiper.activeIndex)
          }
      })
  }

  function HashNavigation(_ref) {
      let {
          swiper,
          extendParams,
          emit,
          on
      } = _ref;
      let initialized = false;
      const document = getDocument();
      const window = getWindow();
      extendParams({
          hashNavigation: {
              enabled: false,
              replaceState: false,
              watchState: false,
              getSlideIndex(_s, hash) {
                  if (swiper.virtual && swiper.params.virtual.enabled) {
                      const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute("data-hash") === hash)[0];
                      if (!slideWithHash) return 0;
                      const index = parseInt(slideWithHash.getAttribute("data-swiper-slide-index"), 10);
                      return index
                  }
                  return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0])
              }
          }
      });
      const onHashChange = () => {
          emit("hashChange");
          const newHash = document.location.hash.replace("#", "");
          const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
          const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") : "";
          if (newHash !== activeSlideHash) {
              const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
              if (typeof newIndex === "undefined" || Number.isNaN(newIndex)) return;
              swiper.slideTo(newIndex)
          }
      };
      const setHash = () => {
          if (!initialized || !swiper.params.hashNavigation.enabled) return;
          const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
          const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") || activeSlideEl.getAttribute("data-history") : "";
          if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
              window.history.replaceState(null, null, `#${activeSlideHash}` || "");
              emit("hashSet")
          } else {
              document.location.hash = activeSlideHash || "";
              emit("hashSet")
          }
      };
      const init = () => {
          if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
          initialized = true;
          const hash = document.location.hash.replace("#", "");
          if (hash) {
              const speed = 0;
              const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
              swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true)
          }
          if (swiper.params.hashNavigation.watchState) {
              window.addEventListener("hashchange", onHashChange)
          }
      };
      const destroy = () => {
          if (swiper.params.hashNavigation.watchState) {
              window.removeEventListener("hashchange", onHashChange)
          }
      };
      on("init", () => {
          if (swiper.params.hashNavigation.enabled) {
              init()
          }
      });
      on("destroy", () => {
          if (swiper.params.hashNavigation.enabled) {
              destroy()
          }
      });
      on("transitionEnd _freeModeNoMomentumRelease", () => {
          if (initialized) {
              setHash()
          }
      });
      on("slideChange", () => {
          if (initialized && swiper.params.cssMode) {
              setHash()
          }
      })
  }

  function Autoplay(_ref) {
      let {
          swiper,
          extendParams,
          on,
          emit,
          params
      } = _ref;
      swiper.autoplay = {
          running: false,
          paused: false,
          timeLeft: 0
      };
      extendParams({
          autoplay: {
              enabled: false,
              delay: 3e3,
              waitForTransition: true,
              disableOnInteraction: false,
              stopOnLastSlide: false,
              reverseDirection: false,
              pauseOnMouseEnter: false
          }
      });
      let timeout;
      let raf;
      let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
      let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
      let autoplayTimeLeft;
      let autoplayStartTime = (new Date).getTime();
      let wasPaused;
      let isTouched;
      let pausedByTouch;
      let touchStartTimeout;
      let slideChanged;
      let pausedByInteraction;
      let pausedByPointerEnter;

      function onTransitionEnd(e) {
          if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
          if (e.target !== swiper.wrapperEl) return;
          swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
          if (pausedByPointerEnter) {
              return
          }
          resume()
      }
      const calcTimeLeft = () => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          if (swiper.autoplay.paused) {
              wasPaused = true
          } else if (wasPaused) {
              autoplayDelayCurrent = autoplayTimeLeft;
              wasPaused = false
          }
          const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (new Date).getTime();
          swiper.autoplay.timeLeft = timeLeft;
          emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
          raf = requestAnimationFrame(() => {
              calcTimeLeft()
          })
      };
      const getSlideDelay = () => {
          let activeSlideEl;
          if (swiper.virtual && swiper.params.virtual.enabled) {
              activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains("swiper-slide-active"))[0]
          } else {
              activeSlideEl = swiper.slides[swiper.activeIndex]
          }
          if (!activeSlideEl) return undefined;
          const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
          return currentSlideDelay
      };
      const run = delayForce => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          cancelAnimationFrame(raf);
          calcTimeLeft();
          let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
          autoplayDelayTotal = swiper.params.autoplay.delay;
          autoplayDelayCurrent = swiper.params.autoplay.delay;
          const currentSlideDelay = getSlideDelay();
          if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
              delay = currentSlideDelay;
              autoplayDelayTotal = currentSlideDelay;
              autoplayDelayCurrent = currentSlideDelay
          }
          autoplayTimeLeft = delay;
          const speed = swiper.params.speed;
          const proceed = () => {
              if (!swiper || swiper.destroyed) return;
              if (swiper.params.autoplay.reverseDirection) {
                  if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                      swiper.slidePrev(speed, true, true);
                      emit("autoplay")
                  } else if (!swiper.params.autoplay.stopOnLastSlide) {
                      swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                      emit("autoplay")
                  }
              } else {
                  if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                      swiper.slideNext(speed, true, true);
                      emit("autoplay")
                  } else if (!swiper.params.autoplay.stopOnLastSlide) {
                      swiper.slideTo(0, speed, true, true);
                      emit("autoplay")
                  }
              }
              if (swiper.params.cssMode) {
                  autoplayStartTime = (new Date).getTime();
                  requestAnimationFrame(() => {
                      run()
                  })
              }
          };
          if (delay > 0) {
              clearTimeout(timeout);
              timeout = setTimeout(() => {
                  proceed()
              }, delay)
          } else {
              requestAnimationFrame(() => {
                  proceed()
              })
          }
          return delay
      };
      const start = () => {
          autoplayStartTime = (new Date).getTime();
          swiper.autoplay.running = true;
          run();
          emit("autoplayStart")
      };
      const stop = () => {
          swiper.autoplay.running = false;
          clearTimeout(timeout);
          cancelAnimationFrame(raf);
          emit("autoplayStop")
      };
      const pause = (internal, reset) => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          clearTimeout(timeout);
          if (!internal) {
              pausedByInteraction = true
          }
          const proceed = () => {
              emit("autoplayPause");
              if (swiper.params.autoplay.waitForTransition) {
                  swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd)
              } else {
                  resume()
              }
          };
          swiper.autoplay.paused = true;
          if (reset) {
              if (slideChanged) {
                  autoplayTimeLeft = swiper.params.autoplay.delay
              }
              slideChanged = false;
              proceed();
              return
          }
          const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
          autoplayTimeLeft = delay - ((new Date).getTime() - autoplayStartTime);
          if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
          if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
          proceed()
      };
      const resume = () => {
          if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
          autoplayStartTime = (new Date).getTime();
          if (pausedByInteraction) {
              pausedByInteraction = false;
              run(autoplayTimeLeft)
          } else {
              run()
          }
          swiper.autoplay.paused = false;
          emit("autoplayResume")
      };
      const onVisibilityChange = () => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          const document = getDocument();
          if (document.visibilityState === "hidden") {
              pausedByInteraction = true;
              pause(true)
          }
          if (document.visibilityState === "visible") {
              resume()
          }
      };
      const onPointerEnter = e => {
          if (e.pointerType !== "mouse") return;
          pausedByInteraction = true;
          pausedByPointerEnter = true;
          if (swiper.animating || swiper.autoplay.paused) return;
          pause(true)
      };
      const onPointerLeave = e => {
          if (e.pointerType !== "mouse") return;
          pausedByPointerEnter = false;
          if (swiper.autoplay.paused) {
              resume()
          }
      };
      const attachMouseEvents = () => {
          if (swiper.params.autoplay.pauseOnMouseEnter) {
              swiper.el.addEventListener("pointerenter", onPointerEnter);
              swiper.el.addEventListener("pointerleave", onPointerLeave)
          }
      };
      const detachMouseEvents = () => {
          swiper.el.removeEventListener("pointerenter", onPointerEnter);
          swiper.el.removeEventListener("pointerleave", onPointerLeave)
      };
      const attachDocumentEvents = () => {
          const document = getDocument();
          document.addEventListener("visibilitychange", onVisibilityChange)
      };
      const detachDocumentEvents = () => {
          const document = getDocument();
          document.removeEventListener("visibilitychange", onVisibilityChange)
      };
      on("init", () => {
          if (swiper.params.autoplay.enabled) {
              attachMouseEvents();
              attachDocumentEvents();
              start()
          }
      });
      on("destroy", () => {
          detachMouseEvents();
          detachDocumentEvents();
          if (swiper.autoplay.running) {
              stop()
          }
      });
      on("_freeModeStaticRelease", () => {
          if (pausedByTouch || pausedByInteraction) {
              resume()
          }
      });
      on("_freeModeNoMomentumRelease", () => {
          if (!swiper.params.autoplay.disableOnInteraction) {
              pause(true, true)
          } else {
              stop()
          }
      });
      on("beforeTransitionStart", (_s, speed, internal) => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
              pause(true, true)
          } else {
              stop()
          }
      });
      on("sliderFirstMove", () => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          if (swiper.params.autoplay.disableOnInteraction) {
              stop();
              return
          }
          isTouched = true;
          pausedByTouch = false;
          pausedByInteraction = false;
          touchStartTimeout = setTimeout(() => {
              pausedByInteraction = true;
              pausedByTouch = true;
              pause(true)
          }, 200)
      });
      on("touchEnd", () => {
          if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
          clearTimeout(touchStartTimeout);
          clearTimeout(timeout);
          if (swiper.params.autoplay.disableOnInteraction) {
              pausedByTouch = false;
              isTouched = false;
              return
          }
          if (pausedByTouch && swiper.params.cssMode) resume();
          pausedByTouch = false;
          isTouched = false
      });
      on("slideChange", () => {
          if (swiper.destroyed || !swiper.autoplay.running) return;
          slideChanged = true
      });
      Object.assign(swiper.autoplay, {
          start: start,
          stop: stop,
          pause: pause,
          resume: resume
      })
  }

  function Thumb(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          thumbs: {
              swiper: null,
              multipleActiveThumbs: true,
              autoScrollOffset: 0,
              slideThumbActiveClass: "swiper-slide-thumb-active",
              thumbsContainerClass: "swiper-thumbs"
          }
      });
      let initialized = false;
      let swiperCreated = false;
      swiper.thumbs = {
          swiper: null
      };

      function onThumbClick() {
          const thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper || thumbsSwiper.destroyed) return;
          const clickedIndex = thumbsSwiper.clickedIndex;
          const clickedSlide = thumbsSwiper.clickedSlide;
          if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
          if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
          let slideToIndex;
          if (thumbsSwiper.params.loop) {
              slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10)
          } else {
              slideToIndex = clickedIndex
          }
          if (swiper.params.loop) {
              swiper.slideToLoop(slideToIndex)
          } else {
              swiper.slideTo(slideToIndex)
          }
      }

      function init() {
          const {
              thumbs: thumbsParams
          } = swiper.params;
          if (initialized) return false;
          initialized = true;
          const SwiperClass = swiper.constructor;
          if (thumbsParams.swiper instanceof SwiperClass) {
              swiper.thumbs.swiper = thumbsParams.swiper;
              Object.assign(swiper.thumbs.swiper.originalParams, {
                  watchSlidesProgress: true,
                  slideToClickedSlide: false
              });
              Object.assign(swiper.thumbs.swiper.params, {
                  watchSlidesProgress: true,
                  slideToClickedSlide: false
              });
              swiper.thumbs.swiper.update()
          } else if (isObject(thumbsParams.swiper)) {
              const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
              Object.assign(thumbsSwiperParams, {
                  watchSlidesProgress: true,
                  slideToClickedSlide: false
              });
              swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
              swiperCreated = true
          }
          swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
          swiper.thumbs.swiper.on("tap", onThumbClick);
          return true
      }

      function update(initial) {
          const thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper || thumbsSwiper.destroyed) return;
          const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
          let thumbsToActivate = 1;
          const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
          if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
              thumbsToActivate = swiper.params.slidesPerView
          }
          if (!swiper.params.thumbs.multipleActiveThumbs) {
              thumbsToActivate = 1
          }
          thumbsToActivate = Math.floor(thumbsToActivate);
          thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
          if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
              for (let i = 0; i < thumbsToActivate; i += 1) {
                  elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex+i}"]`).forEach(slideEl => {
                      slideEl.classList.add(thumbActiveClass)
                  })
              }
          } else {
              for (let i = 0; i < thumbsToActivate; i += 1) {
                  if (thumbsSwiper.slides[swiper.realIndex + i]) {
                      thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass)
                  }
              }
          }
          const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
          const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
          if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
              const currentThumbsIndex = thumbsSwiper.activeIndex;
              let newThumbsIndex;
              let direction;
              if (thumbsSwiper.params.loop) {
                  const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`)[0];
                  newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                  direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev"
              } else {
                  newThumbsIndex = swiper.realIndex;
                  direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev"
              }
              if (useOffset) {
                  newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset
              }
              if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                  if (thumbsSwiper.params.centeredSlides) {
                      if (newThumbsIndex > currentThumbsIndex) {
                          newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1
                      } else {
                          newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1
                      }
                  } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1);
                  thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined)
              }
          }
      }
      on("beforeInit", () => {
          const {
              thumbs
          } = swiper.params;
          if (!thumbs || !thumbs.swiper) return;
          if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
              const document = getDocument();
              const getThumbsElementAndInit = () => {
                  const thumbsElement = typeof thumbs.swiper === "string" ? document.querySelector(thumbs.swiper) : thumbs.swiper;
                  if (thumbsElement && thumbsElement.swiper) {
                      thumbs.swiper = thumbsElement.swiper;
                      init();
                      update(true)
                  } else if (thumbsElement) {
                      const onThumbsSwiper = e => {
                          thumbs.swiper = e.detail[0];
                          thumbsElement.removeEventListener("init", onThumbsSwiper);
                          init();
                          update(true);
                          thumbs.swiper.update();
                          swiper.update()
                      };
                      thumbsElement.addEventListener("init", onThumbsSwiper)
                  }
                  return thumbsElement
              };
              const watchForThumbsToAppear = () => {
                  if (swiper.destroyed) return;
                  const thumbsElement = getThumbsElementAndInit();
                  if (!thumbsElement) {
                      requestAnimationFrame(watchForThumbsToAppear)
                  }
              };
              requestAnimationFrame(watchForThumbsToAppear)
          } else {
              init();
              update(true)
          }
      });
      on("slideChange update resize observerUpdate", () => {
          update()
      });
      on("setTransition", (_s, duration) => {
          const thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper || thumbsSwiper.destroyed) return;
          thumbsSwiper.setTransition(duration)
      });
      on("beforeDestroy", () => {
          const thumbsSwiper = swiper.thumbs.swiper;
          if (!thumbsSwiper || thumbsSwiper.destroyed) return;
          if (swiperCreated) {
              thumbsSwiper.destroy()
          }
      });
      Object.assign(swiper.thumbs, {
          init: init,
          update: update
      })
  }

  function freeMode(_ref) {
      let {
          swiper,
          extendParams,
          emit,
          once
      } = _ref;
      extendParams({
          freeMode: {
              enabled: false,
              momentum: true,
              momentumRatio: 1,
              momentumBounce: true,
              momentumBounceRatio: 1,
              momentumVelocityRatio: 1,
              sticky: false,
              minimumVelocity: .02
          }
      });

      function onTouchStart() {
          if (swiper.params.cssMode) return;
          const translate = swiper.getTranslate();
          swiper.setTranslate(translate);
          swiper.setTransition(0);
          swiper.touchEventsData.velocities.length = 0;
          swiper.freeMode.onTouchEnd({
              currentPos: swiper.rtl ? swiper.translate : -swiper.translate
          })
      }

      function onTouchMove() {
          if (swiper.params.cssMode) return;
          const {
              touchEventsData: data,
              touches
          } = swiper;
          if (data.velocities.length === 0) {
              data.velocities.push({
                  position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                  time: data.touchStartTime
              })
          }
          data.velocities.push({
              position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
              time: now()
          })
      }

      function onTouchEnd(_ref2) {
          let {
              currentPos
          } = _ref2;
          if (swiper.params.cssMode) return;
          const {
              params,
              wrapperEl,
              rtlTranslate: rtl,
              snapGrid,
              touchEventsData: data
          } = swiper;
          const touchEndTime = now();
          const timeDiff = touchEndTime - data.touchStartTime;
          if (currentPos < -swiper.minTranslate()) {
              swiper.slideTo(swiper.activeIndex);
              return
          }
          if (currentPos > -swiper.maxTranslate()) {
              if (swiper.slides.length < snapGrid.length) {
                  swiper.slideTo(snapGrid.length - 1)
              } else {
                  swiper.slideTo(swiper.slides.length - 1)
              }
              return
          }
          if (params.freeMode.momentum) {
              if (data.velocities.length > 1) {
                  const lastMoveEvent = data.velocities.pop();
                  const velocityEvent = data.velocities.pop();
                  const distance = lastMoveEvent.position - velocityEvent.position;
                  const time = lastMoveEvent.time - velocityEvent.time;
                  swiper.velocity = distance / time;
                  swiper.velocity /= 2;
                  if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                      swiper.velocity = 0
                  }
                  if (time > 150 || now() - lastMoveEvent.time > 300) {
                      swiper.velocity = 0
                  }
              } else {
                  swiper.velocity = 0
              }
              swiper.velocity *= params.freeMode.momentumVelocityRatio;
              data.velocities.length = 0;
              let momentumDuration = 1e3 * params.freeMode.momentumRatio;
              const momentumDistance = swiper.velocity * momentumDuration;
              let newPosition = swiper.translate + momentumDistance;
              if (rtl) newPosition = -newPosition;
              let doBounce = false;
              let afterBouncePosition;
              const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
              let needsLoopFix;
              if (newPosition < swiper.maxTranslate()) {
                  if (params.freeMode.momentumBounce) {
                      if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                          newPosition = swiper.maxTranslate() - bounceAmount
                      }
                      afterBouncePosition = swiper.maxTranslate();
                      doBounce = true;
                      data.allowMomentumBounce = true
                  } else {
                      newPosition = swiper.maxTranslate()
                  }
                  if (params.loop && params.centeredSlides) needsLoopFix = true
              } else if (newPosition > swiper.minTranslate()) {
                  if (params.freeMode.momentumBounce) {
                      if (newPosition - swiper.minTranslate() > bounceAmount) {
                          newPosition = swiper.minTranslate() + bounceAmount
                      }
                      afterBouncePosition = swiper.minTranslate();
                      doBounce = true;
                      data.allowMomentumBounce = true
                  } else {
                      newPosition = swiper.minTranslate()
                  }
                  if (params.loop && params.centeredSlides) needsLoopFix = true
              } else if (params.freeMode.sticky) {
                  let nextSlide;
                  for (let j = 0; j < snapGrid.length; j += 1) {
                      if (snapGrid[j] > -newPosition) {
                          nextSlide = j;
                          break
                      }
                  }
                  if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
                      newPosition = snapGrid[nextSlide]
                  } else {
                      newPosition = snapGrid[nextSlide - 1]
                  }
                  newPosition = -newPosition
              }
              if (needsLoopFix) {
                  once("transitionEnd", () => {
                      swiper.loopFix()
                  })
              }
              if (swiper.velocity !== 0) {
                  if (rtl) {
                      momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity)
                  } else {
                      momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity)
                  }
                  if (params.freeMode.sticky) {
                      const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                      const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                      if (moveDistance < currentSlideSize) {
                          momentumDuration = params.speed
                      } else if (moveDistance < 2 * currentSlideSize) {
                          momentumDuration = params.speed * 1.5
                      } else {
                          momentumDuration = params.speed * 2.5
                      }
                  }
              } else if (params.freeMode.sticky) {
                  swiper.slideToClosest();
                  return
              }
              if (params.freeMode.momentumBounce && doBounce) {
                  swiper.updateProgress(afterBouncePosition);
                  swiper.setTransition(momentumDuration);
                  swiper.setTranslate(newPosition);
                  swiper.transitionStart(true, swiper.swipeDirection);
                  swiper.animating = true;
                  elementTransitionEnd(wrapperEl, () => {
                      if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                      emit("momentumBounce");
                      swiper.setTransition(params.speed);
                      setTimeout(() => {
                          swiper.setTranslate(afterBouncePosition);
                          elementTransitionEnd(wrapperEl, () => {
                              if (!swiper || swiper.destroyed) return;
                              swiper.transitionEnd()
                          })
                      }, 0)
                  })
              } else if (swiper.velocity) {
                  emit("_freeModeNoMomentumRelease");
                  swiper.updateProgress(newPosition);
                  swiper.setTransition(momentumDuration);
                  swiper.setTranslate(newPosition);
                  swiper.transitionStart(true, swiper.swipeDirection);
                  if (!swiper.animating) {
                      swiper.animating = true;
                      elementTransitionEnd(wrapperEl, () => {
                          if (!swiper || swiper.destroyed) return;
                          swiper.transitionEnd()
                      })
                  }
              } else {
                  swiper.updateProgress(newPosition)
              }
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses()
          } else if (params.freeMode.sticky) {
              swiper.slideToClosest();
              return
          } else if (params.freeMode) {
              emit("_freeModeNoMomentumRelease")
          }
          if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
              emit("_freeModeStaticRelease");
              swiper.updateProgress();
              swiper.updateActiveIndex();
              swiper.updateSlidesClasses()
          }
      }
      Object.assign(swiper, {
          freeMode: {
              onTouchStart: onTouchStart,
              onTouchMove: onTouchMove,
              onTouchEnd: onTouchEnd
          }
      })
  }

  function Grid(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          grid: {
              rows: 1,
              fill: "column"
          }
      });
      let slidesNumberEvenToRows;
      let slidesPerRow;
      let numFullColumns;
      let wasMultiRow;
      const getSpaceBetween = () => {
          let spaceBetween = swiper.params.spaceBetween;
          if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
              spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size
          } else if (typeof spaceBetween === "string") {
              spaceBetween = parseFloat(spaceBetween)
          }
          return spaceBetween
      };
      const initSlides = slides => {
          const {
              slidesPerView
          } = swiper.params;
          const {
              rows,
              fill
          } = swiper.params.grid;
          const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
          numFullColumns = Math.floor(slidesLength / rows);
          if (Math.floor(slidesLength / rows) === slidesLength / rows) {
              slidesNumberEvenToRows = slidesLength
          } else {
              slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows
          }
          if (slidesPerView !== "auto" && fill === "row") {
              slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows)
          }
          slidesPerRow = slidesNumberEvenToRows / rows
      };
      const unsetSlides = () => {
          if (swiper.slides) {
              swiper.slides.forEach(slide => {
                  if (slide.swiperSlideGridSet) {
                      slide.style.height = "";
                      slide.style[swiper.getDirectionLabel("margin-top")] = ""
                  }
              })
          }
      };
      const updateSlide = (i, slide, slides) => {
          const {
              slidesPerGroup
          } = swiper.params;
          const spaceBetween = getSpaceBetween();
          const {
              rows,
              fill
          } = swiper.params.grid;
          const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
          let newSlideOrderIndex;
          let column;
          let row;
          if (fill === "row" && slidesPerGroup > 1) {
              const groupIndex = Math.floor(i / (slidesPerGroup * rows));
              const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
              const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
              row = Math.floor(slideIndexInGroup / columnsInGroup);
              column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
              newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
              slide.style.order = newSlideOrderIndex
          } else if (fill === "column") {
              column = Math.floor(i / rows);
              row = i - column * rows;
              if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                  row += 1;
                  if (row >= rows) {
                      row = 0;
                      column += 1
                  }
              }
          } else {
              row = Math.floor(i / slidesPerRow);
              column = i - row * slidesPerRow
          }
          slide.row = row;
          slide.column = column;
          slide.style.height = `calc((100% - ${(rows-1)*spaceBetween}px) / ${rows})`;
          slide.style[swiper.getDirectionLabel("margin-top")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : "";
          slide.swiperSlideGridSet = true
      };
      const updateWrapperSize = (slideSize, snapGrid) => {
          const {
              centeredSlides,
              roundLengths
          } = swiper.params;
          const spaceBetween = getSpaceBetween();
          const {
              rows
          } = swiper.params.grid;
          swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
          swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
          if (!swiper.params.cssMode) {
              swiper.wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize+spaceBetween}px`
          }
          if (centeredSlides) {
              const newSlidesGrid = [];
              for (let i = 0; i < snapGrid.length; i += 1) {
                  let slidesGridItem = snapGrid[i];
                  if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                  if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem)
              }
              snapGrid.splice(0, snapGrid.length);
              snapGrid.push(...newSlidesGrid)
          }
      };
      const onInit = () => {
          wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1
      };
      const onUpdate = () => {
          const {
              params,
              el
          } = swiper;
          const isMultiRow = params.grid && params.grid.rows > 1;
          if (wasMultiRow && !isMultiRow) {
              el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
              numFullColumns = 1;
              swiper.emitContainerClasses()
          } else if (!wasMultiRow && isMultiRow) {
              el.classList.add(`${params.containerModifierClass}grid`);
              if (params.grid.fill === "column") {
                  el.classList.add(`${params.containerModifierClass}grid-column`)
              }
              swiper.emitContainerClasses()
          }
          wasMultiRow = isMultiRow
      };
      on("init", onInit);
      on("update", onUpdate);
      swiper.grid = {
          initSlides: initSlides,
          unsetSlides: unsetSlides,
          updateSlide: updateSlide,
          updateWrapperSize: updateWrapperSize
      }
  }

  function appendSlide(slides) {
      const swiper = this;
      const {
          params,
          slidesEl
      } = swiper;
      if (params.loop) {
          swiper.loopDestroy()
      }
      const appendElement = slideEl => {
          if (typeof slideEl === "string") {
              const tempDOM = document.createElement("div");
              tempDOM.innerHTML = slideEl;
              slidesEl.append(tempDOM.children[0]);
              tempDOM.innerHTML = ""
          } else {
              slidesEl.append(slideEl)
          }
      };
      if (typeof slides === "object" && "length" in slides) {
          for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) appendElement(slides[i])
          }
      } else {
          appendElement(slides)
      }
      swiper.recalcSlides();
      if (params.loop) {
          swiper.loopCreate()
      }
      if (!params.observer || swiper.isElement) {
          swiper.update()
      }
  }

  function prependSlide(slides) {
      const swiper = this;
      const {
          params,
          activeIndex,
          slidesEl
      } = swiper;
      if (params.loop) {
          swiper.loopDestroy()
      }
      let newActiveIndex = activeIndex + 1;
      const prependElement = slideEl => {
          if (typeof slideEl === "string") {
              const tempDOM = document.createElement("div");
              tempDOM.innerHTML = slideEl;
              slidesEl.prepend(tempDOM.children[0]);
              tempDOM.innerHTML = ""
          } else {
              slidesEl.prepend(slideEl)
          }
      };
      if (typeof slides === "object" && "length" in slides) {
          for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) prependElement(slides[i])
          }
          newActiveIndex = activeIndex + slides.length
      } else {
          prependElement(slides)
      }
      swiper.recalcSlides();
      if (params.loop) {
          swiper.loopCreate()
      }
      if (!params.observer || swiper.isElement) {
          swiper.update()
      }
      swiper.slideTo(newActiveIndex, 0, false)
  }

  function addSlide(index, slides) {
      const swiper = this;
      const {
          params,
          activeIndex,
          slidesEl
      } = swiper;
      let activeIndexBuffer = activeIndex;
      if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy();
          swiper.recalcSlides()
      }
      const baseLength = swiper.slides.length;
      if (index <= 0) {
          swiper.prependSlide(slides);
          return
      }
      if (index >= baseLength) {
          swiper.appendSlide(slides);
          return
      }
      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      const slidesBuffer = [];
      for (let i = baseLength - 1; i >= index; i -= 1) {
          const currentSlide = swiper.slides[i];
          currentSlide.remove();
          slidesBuffer.unshift(currentSlide)
      }
      if (typeof slides === "object" && "length" in slides) {
          for (let i = 0; i < slides.length; i += 1) {
              if (slides[i]) slidesEl.append(slides[i])
          }
          newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer
      } else {
          slidesEl.append(slides)
      }
      for (let i = 0; i < slidesBuffer.length; i += 1) {
          slidesEl.append(slidesBuffer[i])
      }
      swiper.recalcSlides();
      if (params.loop) {
          swiper.loopCreate()
      }
      if (!params.observer || swiper.isElement) {
          swiper.update()
      }
      if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false)
      } else {
          swiper.slideTo(newActiveIndex, 0, false)
      }
  }

  function removeSlide(slidesIndexes) {
      const swiper = this;
      const {
          params,
          activeIndex
      } = swiper;
      let activeIndexBuffer = activeIndex;
      if (params.loop) {
          activeIndexBuffer -= swiper.loopedSlides;
          swiper.loopDestroy()
      }
      let newActiveIndex = activeIndexBuffer;
      let indexToRemove;
      if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
          for (let i = 0; i < slidesIndexes.length; i += 1) {
              indexToRemove = slidesIndexes[i];
              if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
              if (indexToRemove < newActiveIndex) newActiveIndex -= 1
          }
          newActiveIndex = Math.max(newActiveIndex, 0)
      } else {
          indexToRemove = slidesIndexes;
          if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
          newActiveIndex = Math.max(newActiveIndex, 0)
      }
      swiper.recalcSlides();
      if (params.loop) {
          swiper.loopCreate()
      }
      if (!params.observer || swiper.isElement) {
          swiper.update()
      }
      if (params.loop) {
          swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false)
      } else {
          swiper.slideTo(newActiveIndex, 0, false)
      }
  }

  function removeAllSlides() {
      const swiper = this;
      const slidesIndexes = [];
      for (let i = 0; i < swiper.slides.length; i += 1) {
          slidesIndexes.push(i)
      }
      swiper.removeSlide(slidesIndexes)
  }

  function Manipulation(_ref) {
      let {
          swiper
      } = _ref;
      Object.assign(swiper, {
          appendSlide: appendSlide.bind(swiper),
          prependSlide: prependSlide.bind(swiper),
          addSlide: addSlide.bind(swiper),
          removeSlide: removeSlide.bind(swiper),
          removeAllSlides: removeAllSlides.bind(swiper)
      })
  }

  function effectInit(params) {
      const {
          effect,
          swiper,
          on,
          setTranslate,
          setTransition,
          overwriteParams,
          perspective,
          recreateShadows,
          getEffectParams
      } = params;
      on("beforeInit", () => {
          if (swiper.params.effect !== effect) return;
          swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
          if (perspective && perspective()) {
              swiper.classNames.push(`${swiper.params.containerModifierClass}3d`)
          }
          const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
          Object.assign(swiper.params, overwriteParamsResult);
          Object.assign(swiper.originalParams, overwriteParamsResult)
      });
      on("setTranslate", () => {
          if (swiper.params.effect !== effect) return;
          setTranslate()
      });
      on("setTransition", (_s, duration) => {
          if (swiper.params.effect !== effect) return;
          setTransition(duration)
      });
      on("transitionEnd", () => {
          if (swiper.params.effect !== effect) return;
          if (recreateShadows) {
              if (!getEffectParams || !getEffectParams().slideShadows) return;
              swiper.slides.forEach(slideEl => {
                  slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(shadowEl => shadowEl.remove())
              });
              recreateShadows()
          }
      });
      let requireUpdateOnVirtual;
      on("virtualUpdate", () => {
          if (swiper.params.effect !== effect) return;
          if (!swiper.slides.length) {
              requireUpdateOnVirtual = true
          }
          requestAnimationFrame(() => {
              if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                  setTranslate();
                  requireUpdateOnVirtual = false
              }
          })
      })
  }

  function effectTarget(effectParams, slideEl) {
      const transformEl = getSlideTransformEl(slideEl);
      if (transformEl !== slideEl) {
          transformEl.style.backfaceVisibility = "hidden";
          transformEl.style["-webkit-backface-visibility"] = "hidden"
      }
      return transformEl
  }

  function effectVirtualTransitionEnd(_ref) {
      let {
          swiper,
          duration,
          transformElements,
          allSlides
      } = _ref;
      const {
          activeIndex
      } = swiper;
      const getSlide = el => {
          if (!el.parentElement) {
              const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
              return slide
          }
          return el.parentElement
      };
      if (swiper.params.virtualTranslate && duration !== 0) {
          let eventTriggered = false;
          let transitionEndTarget;
          if (allSlides) {
              transitionEndTarget = transformElements
          } else {
              transitionEndTarget = transformElements.filter(transformEl => {
                  const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
                  return swiper.getSlideIndex(el) === activeIndex
              })
          }
          transitionEndTarget.forEach(el => {
              elementTransitionEnd(el, () => {
                  if (eventTriggered) return;
                  if (!swiper || swiper.destroyed) return;
                  eventTriggered = true;
                  swiper.animating = false;
                  const evt = new window.CustomEvent("transitionend", {
                      bubbles: true,
                      cancelable: true
                  });
                  swiper.wrapperEl.dispatchEvent(evt)
              })
          })
      }
  }

  function EffectFade(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          fadeEffect: {
              crossFade: false
          }
      });
      const setTranslate = () => {
          const {
              slides
          } = swiper;
          const params = swiper.params.fadeEffect;
          for (let i = 0; i < slides.length; i += 1) {
              const slideEl = swiper.slides[i];
              const offset = slideEl.swiperSlideOffset;
              let tx = -offset;
              if (!swiper.params.virtualTranslate) tx -= swiper.translate;
              let ty = 0;
              if (!swiper.isHorizontal()) {
                  ty = tx;
                  tx = 0
              }
              const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.opacity = slideOpacity;
              targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`
          }
      };
      const setTransition = duration => {
          const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
          transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`
          });
          effectVirtualTransitionEnd({
              swiper: swiper,
              duration: duration,
              transformElements: transformElements,
              allSlides: true
          })
      };
      effectInit({
          effect: "fade",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: !swiper.params.cssMode
          })
      })
  }

  function EffectCube(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          cubeEffect: {
              slideShadows: true,
              shadow: true,
              shadowOffset: 20,
              shadowScale: .94
          }
      });
      const createSlideShadows = (slideEl, progress, isHorizontal) => {
          let shadowBefore = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
          let shadowAfter = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
          if (!shadowBefore) {
              shadowBefore = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal?"left":"top"}`.split(" "));
              slideEl.append(shadowBefore)
          }
          if (!shadowAfter) {
              shadowAfter = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal?"right":"bottom"}`.split(" "));
              slideEl.append(shadowAfter)
          }
          if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
          if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0)
      };
      const recreateShadows = () => {
          const isHorizontal = swiper.isHorizontal();
          swiper.slides.forEach(slideEl => {
              const progress = Math.max(Math.min(slideEl.progress, 1), -1);
              createSlideShadows(slideEl, progress, isHorizontal)
          })
      };
      const setTranslate = () => {
          const {
              el,
              wrapperEl,
              slides,
              width: swiperWidth,
              height: swiperHeight,
              rtlTranslate: rtl,
              size: swiperSize,
              browser
          } = swiper;
          const params = swiper.params.cubeEffect;
          const isHorizontal = swiper.isHorizontal();
          const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
          let wrapperRotate = 0;
          let cubeShadowEl;
          if (params.shadow) {
              if (isHorizontal) {
                  cubeShadowEl = swiper.wrapperEl.querySelector(".swiper-cube-shadow");
                  if (!cubeShadowEl) {
                      cubeShadowEl = createElement("div", "swiper-cube-shadow");
                      swiper.wrapperEl.append(cubeShadowEl)
                  }
                  cubeShadowEl.style.height = `${swiperWidth}px`
              } else {
                  cubeShadowEl = el.querySelector(".swiper-cube-shadow");
                  if (!cubeShadowEl) {
                      cubeShadowEl = createElement("div", "swiper-cube-shadow");
                      el.append(cubeShadowEl)
                  }
              }
          }
          for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              let slideIndex = i;
              if (isVirtual) {
                  slideIndex = parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10)
              }
              let slideAngle = slideIndex * 90;
              let round = Math.floor(slideAngle / 360);
              if (rtl) {
                  slideAngle = -slideAngle;
                  round = Math.floor(-slideAngle / 360)
              }
              const progress = Math.max(Math.min(slideEl.progress, 1), -1);
              let tx = 0;
              let ty = 0;
              let tz = 0;
              if (slideIndex % 4 === 0) {
                  tx = -round * 4 * swiperSize;
                  tz = 0
              } else if ((slideIndex - 1) % 4 === 0) {
                  tx = 0;
                  tz = -round * 4 * swiperSize
              } else if ((slideIndex - 2) % 4 === 0) {
                  tx = swiperSize + round * 4 * swiperSize;
                  tz = swiperSize
              } else if ((slideIndex - 3) % 4 === 0) {
                  tx = -swiperSize;
                  tz = 3 * swiperSize + swiperSize * 4 * round
              }
              if (rtl) {
                  tx = -tx
              }
              if (!isHorizontal) {
                  ty = tx;
                  tx = 0
              }
              const transform = `rotateX(${isHorizontal?0:-slideAngle}deg) rotateY(${isHorizontal?slideAngle:0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
              if (progress <= 1 && progress > -1) {
                  wrapperRotate = slideIndex * 90 + progress * 90;
                  if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                  if (swiper.browser && swiper.browser.isSafari && Math.abs(wrapperRotate) / 90 % 2 === 1) {
                      wrapperRotate += .001
                  }
              }
              slideEl.style.transform = transform;
              if (params.slideShadows) {
                  createSlideShadows(slideEl, progress, isHorizontal)
              }
          }
          wrapperEl.style.transformOrigin = `50% 50% -${swiperSize/2}px`;
          wrapperEl.style["-webkit-transform-origin"] = `50% 50% -${swiperSize/2}px`;
          if (params.shadow) {
              if (isHorizontal) {
                  cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth/2+params.shadowOffset}px, ${-swiperWidth/2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`
              } else {
                  const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                  const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                  const scale1 = params.shadowScale;
                  const scale2 = params.shadowScale / multiplier;
                  const offset = params.shadowOffset;
                  cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight/2+offset}px, ${-swiperHeight/2/scale2}px) rotateX(-89.99deg)`
              }
          }
          const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
          wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal()?0:wrapperRotate}deg) rotateY(${swiper.isHorizontal()?-wrapperRotate:0}deg)`;
          wrapperEl.style.setProperty("--swiper-cube-translate-z", `${zFactor}px`)
      };
      const setTransition = duration => {
          const {
              el,
              slides
          } = swiper;
          slides.forEach(slideEl => {
              slideEl.style.transitionDuration = `${duration}ms`;
              slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(subEl => {
                  subEl.style.transitionDuration = `${duration}ms`
              })
          });
          if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
              const shadowEl = el.querySelector(".swiper-cube-shadow");
              if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`
          }
      };
      effectInit({
          effect: "cube",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          recreateShadows: recreateShadows,
          getEffectParams: () => swiper.params.cubeEffect,
          perspective: () => true,
          overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              resistanceRatio: 0,
              spaceBetween: 0,
              centeredSlides: false,
              virtualTranslate: true
          })
      })
  }

  function createShadow(suffix, slideEl, side) {
      const shadowClass = `swiper-slide-shadow${side?`-${side}`:""}${suffix?` swiper-slide-shadow-${suffix}`:""}`;
      const shadowContainer = getSlideTransformEl(slideEl);
      let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(" ").join(".")}`);
      if (!shadowEl) {
          shadowEl = createElement("div", shadowClass.split(" "));
          shadowContainer.append(shadowEl)
      }
      return shadowEl
  }

  function EffectFlip(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          flipEffect: {
              slideShadows: true,
              limitRotation: true
          }
      });
      const createSlideShadows = (slideEl, progress) => {
          let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
          let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
          if (!shadowBefore) {
              shadowBefore = createShadow("flip", slideEl, swiper.isHorizontal() ? "left" : "top")
          }
          if (!shadowAfter) {
              shadowAfter = createShadow("flip", slideEl, swiper.isHorizontal() ? "right" : "bottom")
          }
          if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
          if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0)
      };
      const recreateShadows = () => {
          swiper.params.flipEffect;
          swiper.slides.forEach(slideEl => {
              let progress = slideEl.progress;
              if (swiper.params.flipEffect.limitRotation) {
                  progress = Math.max(Math.min(slideEl.progress, 1), -1)
              }
              createSlideShadows(slideEl, progress)
          })
      };
      const setTranslate = () => {
          const {
              slides,
              rtlTranslate: rtl
          } = swiper;
          const params = swiper.params.flipEffect;
          for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              let progress = slideEl.progress;
              if (swiper.params.flipEffect.limitRotation) {
                  progress = Math.max(Math.min(slideEl.progress, 1), -1)
              }
              const offset = slideEl.swiperSlideOffset;
              const rotate = -180 * progress;
              let rotateY = rotate;
              let rotateX = 0;
              let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
              let ty = 0;
              if (!swiper.isHorizontal()) {
                  ty = tx;
                  tx = 0;
                  rotateX = -rotateY;
                  rotateY = 0
              } else if (rtl) {
                  rotateY = -rotateY
              }
              if (swiper.browser && swiper.browser.isSafari) {
                  if (Math.abs(rotateY) / 90 % 2 === 1) {
                      rotateY += .001
                  }
                  if (Math.abs(rotateX) / 90 % 2 === 1) {
                      rotateX += .001
                  }
              }
              slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
              if (params.slideShadows) {
                  createSlideShadows(slideEl, progress)
              }
              const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform
          }
      };
      const setTransition = duration => {
          const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
          transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(shadowEl => {
                  shadowEl.style.transitionDuration = `${duration}ms`
              })
          });
          effectVirtualTransitionEnd({
              swiper: swiper,
              duration: duration,
              transformElements: transformElements
          })
      };
      effectInit({
          effect: "flip",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          recreateShadows: recreateShadows,
          getEffectParams: () => swiper.params.flipEffect,
          perspective: () => true,
          overwriteParams: () => ({
              slidesPerView: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: true,
              spaceBetween: 0,
              virtualTranslate: !swiper.params.cssMode
          })
      })
  }

  function EffectCoverflow(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          coverflowEffect: {
              rotate: 50,
              stretch: 0,
              depth: 100,
              scale: 1,
              modifier: 1,
              slideShadows: true
          }
      });
      const setTranslate = () => {
          const {
              width: swiperWidth,
              height: swiperHeight,
              slides,
              slidesSizesGrid
          } = swiper;
          const params = swiper.params.coverflowEffect;
          const isHorizontal = swiper.isHorizontal();
          const transform = swiper.translate;
          const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
          const rotate = isHorizontal ? params.rotate : -params.rotate;
          const translate = params.depth;
          for (let i = 0, length = slides.length; i < length; i += 1) {
              const slideEl = slides[i];
              const slideSize = slidesSizesGrid[i];
              const slideOffset = slideEl.swiperSlideOffset;
              const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
              const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
              let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
              let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
              let translateZ = -translate * Math.abs(offsetMultiplier);
              let stretch = params.stretch;
              if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
                  stretch = parseFloat(params.stretch) / 100 * slideSize
              }
              let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
              let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
              let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
              if (Math.abs(translateX) < .001) translateX = 0;
              if (Math.abs(translateY) < .001) translateY = 0;
              if (Math.abs(translateZ) < .001) translateZ = 0;
              if (Math.abs(rotateY) < .001) rotateY = 0;
              if (Math.abs(rotateX) < .001) rotateX = 0;
              if (Math.abs(scale) < .001) scale = 0;
              if (swiper.browser && swiper.browser.isSafari) {
                  if (Math.abs(rotateY) / 90 % 2 === 1) {
                      rotateY += .001
                  }
                  if (Math.abs(rotateX) / 90 % 2 === 1) {
                      rotateX += .001
                  }
              }
              const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = slideTransform;
              slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
              if (params.slideShadows) {
                  let shadowBeforeEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
                  let shadowAfterEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
                  if (!shadowBeforeEl) {
                      shadowBeforeEl = createShadow("coverflow", slideEl, isHorizontal ? "left" : "top")
                  }
                  if (!shadowAfterEl) {
                      shadowAfterEl = createShadow("coverflow", slideEl, isHorizontal ? "right" : "bottom")
                  }
                  if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                  if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0
              }
          }
      };
      const setTransition = duration => {
          const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
          transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(shadowEl => {
                  shadowEl.style.transitionDuration = `${duration}ms`
              })
          })
      };
      effectInit({
          effect: "coverflow",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          perspective: () => true,
          overwriteParams: () => ({
              watchSlidesProgress: true
          })
      })
  }

  function EffectCreative(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          creativeEffect: {
              limitProgress: 1,
              shadowPerProgress: false,
              progressMultiplier: 1,
              perspective: true,
              prev: {
                  translate: [0, 0, 0],
                  rotate: [0, 0, 0],
                  opacity: 1,
                  scale: 1
              },
              next: {
                  translate: [0, 0, 0],
                  rotate: [0, 0, 0],
                  opacity: 1,
                  scale: 1
              }
          }
      });
      const getTranslateValue = value => {
          if (typeof value === "string") return value;
          return `${value}px`
      };
      const setTranslate = () => {
          const {
              slides,
              wrapperEl,
              slidesSizesGrid
          } = swiper;
          const params = swiper.params.creativeEffect;
          const {
              progressMultiplier: multiplier
          } = params;
          const isCenteredSlides = swiper.params.centeredSlides;
          if (isCenteredSlides) {
              const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
              wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`
          }
          for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              const slideProgress = slideEl.progress;
              const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
              let originalProgress = progress;
              if (!isCenteredSlides) {
                  originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress)
              }
              const offset = slideEl.swiperSlideOffset;
              const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
              const r = [0, 0, 0];
              let custom = false;
              if (!swiper.isHorizontal()) {
                  t[1] = t[0];
                  t[0] = 0
              }
              let data = {
                  translate: [0, 0, 0],
                  rotate: [0, 0, 0],
                  scale: 1,
                  opacity: 1
              };
              if (progress < 0) {
                  data = params.next;
                  custom = true
              } else if (progress > 0) {
                  data = params.prev;
                  custom = true
              }
              t.forEach((value, index) => {
                  t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress*multiplier)}))`
              });
              r.forEach((value, index) => {
                  let val = data.rotate[index] * Math.abs(progress * multiplier);
                  if (swiper.browser && swiper.browser.isSafari && Math.abs(val) / 90 % 2 === 1) {
                      val += .001
                  }
                  r[index] = val
              });
              slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
              const translateString = t.join(", ");
              const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
              const scaleString = originalProgress < 0 ? `scale(${1+(1-data.scale)*originalProgress*multiplier})` : `scale(${1-(1-data.scale)*originalProgress*multiplier})`;
              const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
              const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
              if (custom && data.shadow || !custom) {
                  let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                  if (!shadowEl && data.shadow) {
                      shadowEl = createShadow("creative", slideEl)
                  }
                  if (shadowEl) {
                      const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                      shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1)
                  }
              }
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform;
              targetEl.style.opacity = opacityString;
              if (data.origin) {
                  targetEl.style.transformOrigin = data.origin
              }
          }
      };
      const setTransition = duration => {
          const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
          transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll(".swiper-slide-shadow").forEach(shadowEl => {
                  shadowEl.style.transitionDuration = `${duration}ms`
              })
          });
          effectVirtualTransitionEnd({
              swiper: swiper,
              duration: duration,
              transformElements: transformElements,
              allSlides: true
          })
      };
      effectInit({
          effect: "creative",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          perspective: () => swiper.params.creativeEffect.perspective,
          overwriteParams: () => ({
              watchSlidesProgress: true,
              virtualTranslate: !swiper.params.cssMode
          })
      })
  }

  function EffectCards(_ref) {
      let {
          swiper,
          extendParams,
          on
      } = _ref;
      extendParams({
          cardsEffect: {
              slideShadows: true,
              rotate: true,
              perSlideRotate: 2,
              perSlideOffset: 8
          }
      });
      const setTranslate = () => {
          const {
              slides,
              activeIndex,
              rtlTranslate: rtl
          } = swiper;
          const params = swiper.params.cardsEffect;
          const {
              startTranslate,
              isTouched
          } = swiper.touchEventsData;
          const currentTranslate = rtl ? -swiper.translate : swiper.translate;
          for (let i = 0; i < slides.length; i += 1) {
              const slideEl = slides[i];
              const slideProgress = slideEl.progress;
              const progress = Math.min(Math.max(slideProgress, -4), 4);
              let offset = slideEl.swiperSlideOffset;
              if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                  swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`
              }
              if (swiper.params.centeredSlides && swiper.params.cssMode) {
                  offset -= slides[0].swiperSlideOffset
              }
              let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
              let tY = 0;
              const tZ = -100 * Math.abs(progress);
              let scale = 1;
              let rotate = -params.perSlideRotate * progress;
              let tXAdd = params.perSlideOffset - Math.abs(progress) * .75;
              const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
              const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
              const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
              if (isSwipeToNext || isSwipeToPrev) {
                  const subProgress = (1 - Math.abs((Math.abs(progress) - .5) / .5)) ** .5;
                  rotate += -28 * progress * subProgress;
                  scale += -.5 * subProgress;
                  tXAdd += 96 * subProgress;
                  tY = `${-25*subProgress*Math.abs(progress)}%`
              }
              if (progress < 0) {
                  tX = `calc(${tX}px ${rtl?"-":"+"} (${tXAdd*Math.abs(progress)}%))`
              } else if (progress > 0) {
                  tX = `calc(${tX}px ${rtl?"-":"+"} (-${tXAdd*Math.abs(progress)}%))`
              } else {
                  tX = `${tX}px`
              }
              if (!swiper.isHorizontal()) {
                  const prevY = tY;
                  tY = tX;
                  tX = prevY
              }
              const scaleString = progress < 0 ? `${1+(1-scale)*progress}` : `${1-(1-scale)*progress}`;
              const transform = `
      translate3d(${tX}, ${tY}, ${tZ}px)
      rotateZ(${params.rotate?rtl?-rotate:rotate:0}deg)
      scale(${scaleString})
    `;
              if (params.slideShadows) {
                  let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                  if (!shadowEl) {
                      shadowEl = createShadow("cards", slideEl)
                  }
                  if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - .5) / .5, 0), 1)
              }
              slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
              const targetEl = effectTarget(params, slideEl);
              targetEl.style.transform = transform
          }
      };
      const setTransition = duration => {
          const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
          transformElements.forEach(el => {
              el.style.transitionDuration = `${duration}ms`;
              el.querySelectorAll(".swiper-slide-shadow").forEach(shadowEl => {
                  shadowEl.style.transitionDuration = `${duration}ms`
              })
          });
          effectVirtualTransitionEnd({
              swiper: swiper,
              duration: duration,
              transformElements: transformElements
          })
      };
      effectInit({
          effect: "cards",
          swiper: swiper,
          on: on,
          setTranslate: setTranslate,
          setTransition: setTransition,
          perspective: () => true,
          overwriteParams: () => ({
              watchSlidesProgress: true,
              virtualTranslate: !swiper.params.cssMode
          })
      })
  }
  const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];
  Swiper.use(modules);
  return Swiper
}();